// Copyright 2025 Oleg Maximenko
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.



#pragma once


#include <type_traits>
#include "antlr4-runtime.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable : 4456 4457 )
#endif


class  GQLParser : public antlr4::Parser {
public:
  enum {
    IMPLIES = 1, BOOLEAN_LITERAL = 2, SINGLE_QUOTED_CHARACTER_SEQUENCE = 3, 
    DOUBLE_QUOTED_CHARACTER_SEQUENCE = 4, ACCENT_QUOTED_CHARACTER_SEQUENCE = 5, 
    NO_ESCAPE = 6, BYTE_STRING_LITERAL = 7, UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX = 8, 
    UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX = 9, UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX = 10, 
    UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX = 11, UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX = 12, 
    UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX = 13, 
    UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX = 14, UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX = 15, 
    UNSIGNED_DECIMAL_INTEGER = 16, UNSIGNED_HEXADECIMAL_INTEGER = 17, UNSIGNED_OCTAL_INTEGER = 18, 
    UNSIGNED_BINARY_INTEGER = 19, ABS = 20, ACOS = 21, ALL = 22, ALL_DIFFERENT = 23, 
    AND = 24, ANY = 25, ARRAY = 26, AS = 27, ASC = 28, ASCENDING = 29, ASIN = 30, 
    AT = 31, ATAN = 32, AVG = 33, BIG = 34, BIGINT = 35, BINARY = 36, BOOL = 37, 
    BOOLEAN = 38, BOTH = 39, BTRIM = 40, BY = 41, BYTE_LENGTH = 42, BYTES = 43, 
    CALL = 44, CARDINALITY = 45, CASE = 46, CAST = 47, CEIL = 48, CEILING = 49, 
    CHAR = 50, CHAR_LENGTH = 51, CHARACTER_LENGTH = 52, CHARACTERISTICS = 53, 
    CLOSE = 54, COALESCE = 55, COLLECT_LIST = 56, COMMIT = 57, COPY = 58, 
    COS = 59, COSH = 60, COT = 61, COUNT = 62, CREATE = 63, CURRENT_DATE = 64, 
    CURRENT_GRAPH = 65, CURRENT_PROPERTY_GRAPH = 66, CURRENT_SCHEMA = 67, 
    CURRENT_TIME = 68, CURRENT_TIMESTAMP = 69, DATE = 70, DATETIME = 71, 
    DAY = 72, DEC = 73, DECIMAL = 74, DEGREES = 75, DELETE = 76, DESC = 77, 
    DESCENDING = 78, DETACH = 79, DISTINCT = 80, DOUBLE = 81, DROP = 82, 
    DURATION = 83, DURATION_BETWEEN = 84, ELEMENT_ID = 85, ELSE = 86, END = 87, 
    EXCEPT = 88, EXISTS = 89, EXP = 90, FILTER = 91, FINISH = 92, FLOAT = 93, 
    FLOAT16 = 94, FLOAT32 = 95, FLOAT64 = 96, FLOAT128 = 97, FLOAT256 = 98, 
    FLOOR = 99, FOR = 100, FROM = 101, GROUP = 102, HAVING = 103, HOME_GRAPH = 104, 
    HOME_PROPERTY_GRAPH = 105, HOME_SCHEMA = 106, HOUR = 107, IF = 108, 
    IN = 109, INSERT = 110, INT = 111, INTEGER = 112, INT8 = 113, INTEGER8 = 114, 
    INT16 = 115, INTEGER16 = 116, INT32 = 117, INTEGER32 = 118, INT64 = 119, 
    INTEGER64 = 120, INT128 = 121, INTEGER128 = 122, INT256 = 123, INTEGER256 = 124, 
    INTERSECT = 125, INTERVAL = 126, IS = 127, LEADING = 128, LEFT = 129, 
    LET = 130, LIKE = 131, LIMIT = 132, LIST = 133, LN = 134, LOCAL = 135, 
    LOCAL_DATETIME = 136, LOCAL_TIME = 137, LOCAL_TIMESTAMP = 138, LOG_KW = 139, 
    LOG10 = 140, LOWER = 141, LTRIM = 142, MATCH = 143, MAX = 144, MIN = 145, 
    MINUTE = 146, MOD = 147, MONTH = 148, NEXT = 149, NODETACH = 150, NORMALIZE = 151, 
    NOT = 152, NOTHING = 153, NULL_KW = 154, NULLS = 155, NULLIF = 156, 
    OCTET_LENGTH = 157, OF = 158, OFFSET = 159, OPTIONAL = 160, OR = 161, 
    ORDER = 162, OTHERWISE = 163, PARAMETER = 164, PARAMETERS = 165, PATH = 166, 
    PATH_LENGTH = 167, PATHS = 168, PERCENTILE_CONT = 169, PERCENTILE_DISC = 170, 
    POWER = 171, PRECISION = 172, PROPERTY_EXISTS = 173, RADIANS = 174, 
    REAL = 175, RECORD = 176, REMOVE = 177, REPLACE = 178, RESET = 179, 
    RETURN = 180, RIGHT = 181, ROLLBACK = 182, RTRIM = 183, SAME = 184, 
    SCHEMA = 185, SECOND = 186, SELECT = 187, SESSION = 188, SESSION_USER = 189, 
    SET = 190, SIGNED = 191, SIN = 192, SINH = 193, SIZE = 194, SKIP_RESERVED_WORD = 195, 
    SMALL = 196, SMALLINT = 197, SQRT = 198, START = 199, STDDEV_POP = 200, 
    STDDEV_SAMP = 201, STRING = 202, SUM = 203, TAN = 204, TANH = 205, THEN = 206, 
    TIME = 207, TIMESTAMP = 208, TRAILING = 209, TRIM = 210, TYPED = 211, 
    UBIGINT = 212, UINT = 213, UINT8 = 214, UINT16 = 215, UINT32 = 216, 
    UINT64 = 217, UINT128 = 218, UINT256 = 219, UNION = 220, UNSIGNED = 221, 
    UPPER = 222, USE = 223, USMALLINT = 224, VALUE = 225, VARBINARY = 226, 
    VARCHAR = 227, VARIABLE = 228, WHEN = 229, WHERE = 230, WITH = 231, 
    XOR = 232, YEAR = 233, YIELD = 234, ZONED = 235, ZONED_DATETIME = 236, 
    ZONED_TIME = 237, ABSTRACT = 238, AGGREGATE = 239, AGGREGATES = 240, 
    ALTER = 241, CATALOG = 242, CLEAR = 243, CLONE = 244, CONSTRAINT = 245, 
    CURRENT_ROLE = 246, CURRENT_USER = 247, DATA = 248, DIRECTORY = 249, 
    DRYRUN = 250, EXACT = 251, EXISTING = 252, FUNCTION = 253, GQLSTATUS = 254, 
    GRANT = 255, INSTANT = 256, INFINITY_KW = 257, NUMBER = 258, NUMERIC = 259, 
    ON = 260, OPEN = 261, PARTITION = 262, PROCEDURE = 263, PRODUCT = 264, 
    PROJECT = 265, QUERY = 266, RECORDS = 267, REFERENCE = 268, RENAME = 269, 
    REVOKE = 270, SUBSTRING = 271, SYSTEM_USER = 272, TEMPORAL = 273, UNIQUE = 274, 
    UNIT = 275, VALUES = 276, ACYCLIC = 277, BINDING = 278, BINDINGS = 279, 
    CONNECTING = 280, DESTINATION = 281, DIFFERENT = 282, DIRECTED = 283, 
    EDGE = 284, EDGES = 285, ELEMENT = 286, ELEMENTS = 287, FIRST = 288, 
    GRAPH = 289, GROUPS = 290, KEEP = 291, LABEL = 292, LABELED = 293, LABELS = 294, 
    LAST = 295, NFC = 296, NFD = 297, NFKC = 298, NFKD = 299, NO = 300, 
    NODE = 301, NORMALIZED = 302, ONLY = 303, ORDINALITY = 304, PROPERTY = 305, 
    READ = 306, RELATIONSHIP = 307, RELATIONSHIPS = 308, REPEATABLE = 309, 
    SHORTEST = 310, SIMPLE = 311, SOURCE = 312, TABLE = 313, TEMP = 314, 
    TO = 315, TRAIL = 316, TRANSACTION = 317, TYPE = 318, UNDIRECTED = 319, 
    VERTEX = 320, WALK = 321, WITHOUT = 322, WRITE = 323, ZONE = 324, REGULAR_IDENTIFIER = 325, 
    SUBSTITUTED_PARAMETER_REFERENCE = 326, GENERAL_PARAMETER_REFERENCE = 327, 
    MULTISET_ALTERNATION_OPERATOR = 328, BRACKET_RIGHT_ARROW = 329, BRACKET_TILDE_RIGHT_ARROW = 330, 
    CONCATENATION_OPERATOR = 331, DOUBLE_COLON = 332, DOUBLE_DOLLAR_SIGN = 333, 
    DOUBLE_PERIOD = 334, GREATER_THAN_OR_EQUALS_OPERATOR = 335, LEFT_ARROW = 336, 
    LEFT_ARROW_TILDE = 337, LEFT_ARROW_BRACKET = 338, LEFT_ARROW_TILDE_BRACKET = 339, 
    LEFT_MINUS_RIGHT = 340, LEFT_MINUS_SLASH = 341, LEFT_TILDE_SLASH = 342, 
    LESS_THAN_OR_EQUALS_OPERATOR = 343, MINUS_LEFT_BRACKET = 344, MINUS_SLASH = 345, 
    NOT_EQUALS_OPERATOR = 346, RIGHT_ARROW = 347, RIGHT_BRACKET_MINUS = 348, 
    RIGHT_BRACKET_TILDE = 349, RIGHT_DOUBLE_ARROW = 350, SLASH_MINUS = 351, 
    SLASH_MINUS_RIGHT = 352, SLASH_TILDE = 353, SLASH_TILDE_RIGHT = 354, 
    TILDE_LEFT_BRACKET = 355, TILDE_RIGHT_ARROW = 356, TILDE_SLASH = 357, 
    AMPERSAND = 358, ASTERISK = 359, COLON = 360, COMMA = 361, COMMERCIAL_AT = 362, 
    DOLLAR_SIGN = 363, DOUBLE_QUOTE = 364, EQUALS_OPERATOR = 365, EXCLAMATION_MARK = 366, 
    RIGHT_ANGLE_BRACKET = 367, GRAVE_ACCENT = 368, LEFT_BRACE = 369, LEFT_BRACKET = 370, 
    LEFT_PAREN = 371, LEFT_ANGLE_BRACKET = 372, MINUS_SIGN = 373, PERCENT = 374, 
    PERIOD = 375, PLUS_SIGN = 376, QUESTION_MARK = 377, QUOTE = 378, REVERSE_SOLIDUS = 379, 
    RIGHT_BRACE = 380, RIGHT_BRACKET = 381, RIGHT_PAREN = 382, SOLIDUS = 383, 
    TILDE = 384, UNDERSCORE = 385, VERTICAL_BAR = 386, SP = 387, WHITESPACE = 388, 
    BRACKETED_COMMENT = 389, SIMPLE_COMMENT_SOLIDUS = 390, SIMPLE_COMMENT_MINUS = 391
  };

  enum {
    RuleGqlProgram = 0, RuleProgramActivity = 1, RuleSessionActivity = 2, 
    RuleTransactionActivity = 3, RuleEndTransactionCommand = 4, RuleSessionSetCommand = 5, 
    RuleSessionSetSchemaClause = 6, RuleSessionSetGraphClause = 7, RuleSessionSetTimeZoneClause = 8, 
    RuleSetTimeZoneValue = 9, RuleSessionSetParameterClause = 10, RuleSessionSetGraphParameterClause = 11, 
    RuleSessionSetBindingTableParameterClause = 12, RuleSessionSetValueParameterClause = 13, 
    RuleSessionSetParameterName = 14, RuleSessionResetCommand = 15, RuleSessionResetArguments = 16, 
    RuleSessionCloseCommand = 17, RuleSessionParameterSpecification = 18, 
    RuleStartTransactionCommand = 19, RuleTransactionCharacteristics = 20, 
    RuleTransactionMode = 21, RuleTransactionAccessMode = 22, RuleRollbackCommand = 23, 
    RuleCommitCommand = 24, RuleNestedProcedureSpecification = 25, RuleProcedureSpecification = 26, 
    RuleNestedDataModifyingProcedureSpecification = 27, RuleNestedQuerySpecification = 28, 
    RuleProcedureBody = 29, RuleBindingVariableDefinitionBlock = 30, RuleBindingVariableDefinition = 31, 
    RuleStatementBlock = 32, RuleStatement = 33, RuleNextStatement = 34, 
    RuleGraphVariableDefinition = 35, RuleOptTypedGraphInitializer = 36, 
    RuleGraphInitializer = 37, RuleBindingTableVariableDefinition = 38, 
    RuleOptTypedBindingTableInitializer = 39, RuleBindingTableInitializer = 40, 
    RuleValueVariableDefinition = 41, RuleOptTypedValueInitializer = 42, 
    RuleValueInitializer = 43, RuleGraphExpression = 44, RuleCurrentGraph = 45, 
    RuleBindingTableExpression = 46, RuleNestedBindingTableQuerySpecification = 47, 
    RuleObjectExpressionPrimary = 48, RuleLinearCatalogModifyingStatement = 49, 
    RuleSimpleCatalogModifyingStatement = 50, RulePrimitiveCatalogModifyingStatement = 51, 
    RuleCreateSchemaStatement = 52, RuleDropSchemaStatement = 53, RuleCreateGraphStatement = 54, 
    RuleOpenGraphType = 55, RuleOfGraphType = 56, RuleGraphTypeLikeGraph = 57, 
    RuleGraphSource = 58, RuleDropGraphStatement = 59, RuleCreateGraphTypeStatement = 60, 
    RuleGraphTypeSource = 61, RuleCopyOfGraphType = 62, RuleDropGraphTypeStatement = 63, 
    RuleCallCatalogModifyingProcedureStatement = 64, RuleLinearDataModifyingStatement = 65, 
    RuleFocusedLinearDataModifyingStatement = 66, RuleFocusedLinearDataModifyingStatementBody = 67, 
    RuleFocusedNestedDataModifyingProcedureSpecification = 68, RuleAmbientLinearDataModifyingStatement = 69, 
    RuleAmbientLinearDataModifyingStatementBody = 70, RuleSimpleLinearDataAccessingStatement = 71, 
    RuleSimpleDataAccessingStatement = 72, RuleSimpleDataModifyingStatement = 73, 
    RulePrimitiveDataModifyingStatement = 74, RuleInsertStatement = 75, 
    RuleSetStatement = 76, RuleSetItemList = 77, RuleSetItem = 78, RuleSetPropertyItem = 79, 
    RuleSetAllPropertiesItem = 80, RuleSetLabelItem = 81, RuleRemoveStatement = 82, 
    RuleRemoveItemList = 83, RuleRemoveItem = 84, RuleRemovePropertyItem = 85, 
    RuleRemoveLabelItem = 86, RuleDeleteStatement = 87, RuleDeleteItemList = 88, 
    RuleDeleteItem = 89, RuleCallDataModifyingProcedureStatement = 90, RuleCompositeQueryStatement = 91, 
    RuleCompositeQueryExpression = 92, RuleQueryConjunction = 93, RuleSetOperator = 94, 
    RuleCompositeQueryPrimary = 95, RuleLinearQueryStatement = 96, RuleFocusedLinearQueryStatement = 97, 
    RuleFocusedLinearQueryStatementPart = 98, RuleFocusedLinearQueryAndPrimitiveResultStatementPart = 99, 
    RuleFocusedPrimitiveResultStatement = 100, RuleFocusedNestedQuerySpecification = 101, 
    RuleAmbientLinearQueryStatement = 102, RuleSimpleLinearQueryStatement = 103, 
    RuleSimpleQueryStatement = 104, RulePrimitiveQueryStatement = 105, RuleMatchStatement = 106, 
    RuleSimpleMatchStatement = 107, RuleOptionalMatchStatement = 108, RuleOptionalOperand = 109, 
    RuleMatchStatementBlock = 110, RuleCallQueryStatement = 111, RuleFilterStatement = 112, 
    RuleLetStatement = 113, RuleLetVariableDefinitionList = 114, RuleLetVariableDefinition = 115, 
    RuleForStatement = 116, RuleForItem = 117, RuleForItemAlias = 118, RuleForItemSource = 119, 
    RuleForOrdinalityOrOffset = 120, RuleOrderByAndPageStatement = 121, 
    RulePrimitiveResultStatement = 122, RuleReturnStatement = 123, RuleReturnStatementBody = 124, 
    RuleReturnItemList = 125, RuleReturnItem = 126, RuleReturnItemAlias = 127, 
    RuleSelectStatement = 128, RuleSelectItemList = 129, RuleSelectItem = 130, 
    RuleSelectItemAlias = 131, RuleHavingClause = 132, RuleSelectStatementBody = 133, 
    RuleSelectGraphMatchList = 134, RuleSelectGraphMatch = 135, RuleSelectQuerySpecification = 136, 
    RuleCallProcedureStatement = 137, RuleProcedureCall = 138, RuleInlineProcedureCall = 139, 
    RuleVariableScopeClause = 140, RuleBindingVariableReferenceList = 141, 
    RuleNamedProcedureCall = 142, RuleProcedureArgumentList = 143, RuleProcedureArgument = 144, 
    RuleAtSchemaClause = 145, RuleUseGraphClause = 146, RuleGraphPatternBindingTable = 147, 
    RuleGraphPatternYieldClause = 148, RuleGraphPatternYieldItemList = 149, 
    RuleGraphPatternYieldItem = 150, RuleGraphPattern = 151, RuleMatchMode = 152, 
    RuleRepeatableElementsMatchMode = 153, RuleDifferentEdgesMatchMode = 154, 
    RuleElementBindingsOrElements = 155, RuleEdgeBindingsOrEdges = 156, 
    RulePathPatternList = 157, RulePathPattern = 158, RulePathVariableDeclaration = 159, 
    RuleKeepClause = 160, RuleGraphPatternWhereClause = 161, RuleInsertGraphPattern = 162, 
    RuleInsertPathPatternList = 163, RuleInsertPathPattern = 164, RuleInsertNodePattern = 165, 
    RuleInsertEdgePattern = 166, RuleInsertEdgePointingLeft = 167, RuleInsertEdgePointingRight = 168, 
    RuleInsertEdgeUndirected = 169, RuleInsertElementPatternFiller = 170, 
    RuleLabelAndPropertySetSpecification = 171, RulePathPatternPrefix = 172, 
    RulePathModePrefix = 173, RulePathMode = 174, RulePathSearchPrefix = 175, 
    RuleAllPathSearch = 176, RulePathOrPaths = 177, RuleAnyPathSearch = 178, 
    RuleNumberOfPaths = 179, RuleShortestPathSearch = 180, RuleAllShortestPathSearch = 181, 
    RuleAnyShortestPathSearch = 182, RuleCountedShortestPathSearch = 183, 
    RuleCountedShortestGroupSearch = 184, RuleNumberOfGroups = 185, RulePathPatternExpression = 186, 
    RulePathTerm = 187, RulePathFactor = 188, RulePathPrimary = 189, RuleElementPattern = 190, 
    RuleNodePattern = 191, RuleElementPatternFiller = 192, RuleElementVariableDeclaration = 193, 
    RuleIsLabelExpression = 194, RuleIsOrColon = 195, RuleElementPatternPredicate = 196, 
    RuleElementPatternWhereClause = 197, RuleElementPropertySpecification = 198, 
    RulePropertyKeyValuePairList = 199, RulePropertyKeyValuePair = 200, 
    RuleEdgePattern = 201, RuleFullEdgePattern = 202, RuleFullEdgePointingLeft = 203, 
    RuleFullEdgeUndirected = 204, RuleFullEdgePointingRight = 205, RuleFullEdgeLeftOrUndirected = 206, 
    RuleFullEdgeUndirectedOrRight = 207, RuleFullEdgeLeftOrRight = 208, 
    RuleFullEdgeAnyDirection = 209, RuleAbbreviatedEdgePattern = 210, RuleParenthesizedPathPatternExpression = 211, 
    RuleSubpathVariableDeclaration = 212, RuleParenthesizedPathPatternWhereClause = 213, 
    RuleLabelExpression = 214, RulePathVariableReference = 215, RuleElementVariableReference = 216, 
    RuleGraphPatternQuantifier = 217, RuleFixedQuantifier = 218, RuleGeneralQuantifier = 219, 
    RuleLowerBound = 220, RuleUpperBound = 221, RuleSimplifiedPathPatternExpression = 222, 
    RuleSimplifiedDefaultingLeft = 223, RuleSimplifiedDefaultingUndirected = 224, 
    RuleSimplifiedDefaultingRight = 225, RuleSimplifiedDefaultingLeftOrUndirected = 226, 
    RuleSimplifiedDefaultingUndirectedOrRight = 227, RuleSimplifiedDefaultingLeftOrRight = 228, 
    RuleSimplifiedDefaultingAnyDirection = 229, RuleSimplifiedContents = 230, 
    RuleSimplifiedPathUnion = 231, RuleSimplifiedMultisetAlternation = 232, 
    RuleSimplifiedTerm = 233, RuleSimplifiedFactorLow = 234, RuleSimplifiedFactorHigh = 235, 
    RuleSimplifiedQuantified = 236, RuleSimplifiedQuestioned = 237, RuleSimplifiedTertiary = 238, 
    RuleSimplifiedDirectionOverride = 239, RuleSimplifiedOverrideLeft = 240, 
    RuleSimplifiedOverrideUndirected = 241, RuleSimplifiedOverrideRight = 242, 
    RuleSimplifiedOverrideLeftOrUndirected = 243, RuleSimplifiedOverrideUndirectedOrRight = 244, 
    RuleSimplifiedOverrideLeftOrRight = 245, RuleSimplifiedOverrideAnyDirection = 246, 
    RuleSimplifiedSecondary = 247, RuleSimplifiedNegation = 248, RuleSimplifiedPrimary = 249, 
    RuleWhereClause = 250, RuleYieldClause = 251, RuleYieldItemList = 252, 
    RuleYieldItem = 253, RuleYieldItemName = 254, RuleYieldItemAlias = 255, 
    RuleGroupByClause = 256, RuleGroupingElementList = 257, RuleGroupingElement = 258, 
    RuleEmptyGroupingSet = 259, RuleOrderByClause = 260, RuleSortSpecificationList = 261, 
    RuleSortSpecification = 262, RuleSortKey = 263, RuleOrderingSpecification = 264, 
    RuleNullOrdering = 265, RuleLimitClause = 266, RuleOffsetClause = 267, 
    RuleOffsetSynonym = 268, RuleSchemaReference = 269, RuleAbsoluteCatalogSchemaReference = 270, 
    RuleCatalogSchemaParentAndName = 271, RuleRelativeCatalogSchemaReference = 272, 
    RulePredefinedSchemaReference = 273, RuleAbsoluteDirectoryPath = 274, 
    RuleRelativeDirectoryPath = 275, RuleSimpleDirectoryPath = 276, RuleGraphReference = 277, 
    RuleCatalogGraphParentAndName = 278, RuleHomeGraph = 279, RuleGraphTypeReference = 280, 
    RuleCatalogGraphTypeParentAndName = 281, RuleBindingTableReference = 282, 
    RuleProcedureReference = 283, RuleCatalogProcedureParentAndName = 284, 
    RuleCatalogObjectParentReference = 285, RuleReferenceParameterSpecification = 286, 
    RuleNestedGraphTypeSpecification = 287, RuleGraphTypeSpecificationBody = 288, 
    RuleElementTypeList = 289, RuleElementTypeSpecification = 290, RuleNodeTypeSpecification = 291, 
    RuleNodeTypePattern = 292, RuleNodeTypePhrase = 293, RuleNodeTypePhraseFiller = 294, 
    RuleNodeTypeFiller = 295, RuleLocalNodeTypeAlias = 296, RuleNodeTypeImpliedContent = 297, 
    RuleNodeTypeKeyLabelSet = 298, RuleNodeTypeLabelSet = 299, RuleNodeTypePropertyTypes = 300, 
    RuleEdgeTypeSpecification = 301, RuleEdgeTypePattern = 302, RuleEdgeTypePhrase = 303, 
    RuleEdgeTypePhraseFiller = 304, RuleEdgeTypeFiller = 305, RuleEdgeTypeImpliedContent = 306, 
    RuleEdgeTypeKeyLabelSet = 307, RuleEdgeTypeLabelSet = 308, RuleEdgeTypePropertyTypes = 309, 
    RuleEdgeTypePatternDirected = 310, RuleEdgeTypePatternPointingRight = 311, 
    RuleEdgeTypePatternPointingLeft = 312, RuleEdgeTypePatternUndirected = 313, 
    RuleArcTypePointingRight = 314, RuleArcTypePointingLeft = 315, RuleArcTypeUndirected = 316, 
    RuleSourceNodeTypeReference = 317, RuleDestinationNodeTypeReference = 318, 
    RuleEdgeKind = 319, RuleEndpointPairPhrase = 320, RuleEndpointPair = 321, 
    RuleEndpointPairDirected = 322, RuleEndpointPairPointingRight = 323, 
    RuleEndpointPairPointingLeft = 324, RuleEndpointPairUndirected = 325, 
    RuleConnectorPointingRight = 326, RuleConnectorUndirected = 327, RuleSourceNodeTypeAlias = 328, 
    RuleDestinationNodeTypeAlias = 329, RuleLabelSetPhrase = 330, RuleLabelSetSpecification = 331, 
    RulePropertyTypesSpecification = 332, RulePropertyTypeList = 333, RulePropertyType = 334, 
    RulePropertyValueType = 335, RuleBindingTableType = 336, RuleValueType = 337, 
    RuleTyped = 338, RulePredefinedType = 339, RuleBooleanType = 340, RuleCharacterStringType = 341, 
    RuleByteStringType = 342, RuleMinLength = 343, RuleMaxLength = 344, 
    RuleFixedLength = 345, RuleNumericType = 346, RuleExactNumericType = 347, 
    RuleBinaryExactNumericType = 348, RuleSignedBinaryExactNumericType = 349, 
    RuleUnsignedBinaryExactNumericType = 350, RuleVerboseBinaryExactNumericType = 351, 
    RuleDecimalExactNumericType = 352, RulePrecision = 353, RuleScale = 354, 
    RuleApproximateNumericType = 355, RuleTemporalType = 356, RuleTemporalInstantType = 357, 
    RuleDatetimeType = 358, RuleLocaldatetimeType = 359, RuleDateType = 360, 
    RuleTimeType = 361, RuleLocaltimeType = 362, RuleTemporalDurationType = 363, 
    RuleTemporalDurationQualifier = 364, RuleReferenceValueType = 365, RuleImmaterialValueType = 366, 
    RuleNullType = 367, RuleEmptyType = 368, RuleGraphReferenceValueType = 369, 
    RuleClosedGraphReferenceValueType = 370, RuleOpenGraphReferenceValueType = 371, 
    RuleBindingTableReferenceValueType = 372, RuleNodeReferenceValueType = 373, 
    RuleClosedNodeReferenceValueType = 374, RuleOpenNodeReferenceValueType = 375, 
    RuleEdgeReferenceValueType = 376, RuleClosedEdgeReferenceValueType = 377, 
    RuleOpenEdgeReferenceValueType = 378, RulePathValueType = 379, RuleListValueTypeName = 380, 
    RuleListValueTypeNameSynonym = 381, RuleRecordType = 382, RuleFieldTypesSpecification = 383, 
    RuleFieldTypeList = 384, RuleNotNull = 385, RuleFieldType = 386, RuleSearchCondition = 387, 
    RulePredicate = 388, RuleCompOp = 389, RuleExistsPredicate = 390, RuleNullPredicate = 391, 
    RuleNullPredicatePart2 = 392, RuleValueTypePredicate = 393, RuleValueTypePredicatePart2 = 394, 
    RuleNormalizedPredicatePart2 = 395, RuleDirectedPredicate = 396, RuleDirectedPredicatePart2 = 397, 
    RuleLabeledPredicate = 398, RuleLabeledPredicatePart2 = 399, RuleIsLabeledOrColon = 400, 
    RuleSourceDestinationPredicate = 401, RuleNodeReference = 402, RuleSourcePredicatePart2 = 403, 
    RuleDestinationPredicatePart2 = 404, RuleEdgeReference = 405, RuleAll_differentPredicate = 406, 
    RuleSamePredicate = 407, RuleProperty_existsPredicate = 408, RuleValueExpression = 409, 
    RuleValueFunction = 410, RuleBooleanValueExpression = 411, RuleCharacterOrByteStringFunction = 412, 
    RuleSubCharacterOrByteString = 413, RuleTrimSingleCharacterOrByteString = 414, 
    RuleFoldCharacterString = 415, RuleTrimMultiCharacterCharacterString = 416, 
    RuleNormalizeCharacterString = 417, RuleNodeReferenceValueExpression = 418, 
    RuleEdgeReferenceValueExpression = 419, RuleAggregatingValueExpression = 420, 
    RuleValueExpressionPrimary = 421, RuleParenthesizedValueExpression = 422, 
    RuleNonParenthesizedValueExpressionPrimary = 423, RuleNonParenthesizedValueExpressionPrimarySpecialCase = 424, 
    RuleUnsignedValueSpecification = 425, RuleNonNegativeIntegerSpecification = 426, 
    RuleGeneralValueSpecification = 427, RuleDynamicParameterSpecification = 428, 
    RuleLetValueExpression = 429, RuleValueQueryExpression = 430, RuleCaseExpression = 431, 
    RuleCaseAbbreviation = 432, RuleCaseSpecification = 433, RuleSimpleCase = 434, 
    RuleSearchedCase = 435, RuleSimpleWhenClause = 436, RuleSearchedWhenClause = 437, 
    RuleElseClause = 438, RuleCaseOperand = 439, RuleWhenOperandList = 440, 
    RuleWhenOperand = 441, RuleResult = 442, RuleResultExpression = 443, 
    RuleCastSpecification = 444, RuleCastOperand = 445, RuleCastTarget = 446, 
    RuleAggregateFunction = 447, RuleGeneralSetFunction = 448, RuleBinarySetFunction = 449, 
    RuleGeneralSetFunctionType = 450, RuleSetQuantifier = 451, RuleBinarySetFunctionType = 452, 
    RuleDependentValueExpression = 453, RuleIndependentValueExpression = 454, 
    RuleElement_idFunction = 455, RuleBindingVariableReference = 456, RulePathValueExpression = 457, 
    RulePathValueConstructor = 458, RulePathValueConstructorByEnumeration = 459, 
    RulePathElementList = 460, RulePathElementListStart = 461, RulePathElementListStep = 462, 
    RuleListValueExpression = 463, RuleListValueFunction = 464, RuleTrimListFunction = 465, 
    RuleElementsFunction = 466, RuleListValueConstructor = 467, RuleListValueConstructorByEnumeration = 468, 
    RuleListElementList = 469, RuleListElement = 470, RuleRecordConstructor = 471, 
    RuleFieldsSpecification = 472, RuleFieldList = 473, RuleField = 474, 
    RuleTruthValue = 475, RuleNumericValueExpression = 476, RuleNumericValueFunction = 477, 
    RuleLengthExpression = 478, RuleCardinalityExpression = 479, RuleCardinalityExpressionArgument = 480, 
    RuleCharLengthExpression = 481, RuleByteLengthExpression = 482, RulePathLengthExpression = 483, 
    RuleAbsoluteValueExpression = 484, RuleModulusExpression = 485, RuleNumericValueExpressionDividend = 486, 
    RuleNumericValueExpressionDivisor = 487, RuleTrigonometricFunction = 488, 
    RuleTrigonometricFunctionName = 489, RuleGeneralLogarithmFunction = 490, 
    RuleGeneralLogarithmBase = 491, RuleGeneralLogarithmArgument = 492, 
    RuleCommonLogarithm = 493, RuleNaturalLogarithm = 494, RuleExponentialFunction = 495, 
    RulePowerFunction = 496, RuleNumericValueExpressionBase = 497, RuleNumericValueExpressionExponent = 498, 
    RuleSquareRoot = 499, RuleFloorFunction = 500, RuleCeilingFunction = 501, 
    RuleCharacterStringValueExpression = 502, RuleByteStringValueExpression = 503, 
    RuleTrimOperands = 504, RuleTrimCharacterOrByteStringSource = 505, RuleTrimSpecification = 506, 
    RuleTrimCharacterOrByteString = 507, RuleNormalForm = 508, RuleStringLength = 509, 
    RuleDatetimeValueExpression = 510, RuleDatetimeValueFunction = 511, 
    RuleDateFunction = 512, RuleTimeFunction = 513, RuleLocaltimeFunction = 514, 
    RuleDatetimeFunction = 515, RuleLocaldatetimeFunction = 516, RuleDateFunctionParameters = 517, 
    RuleTimeFunctionParameters = 518, RuleDatetimeFunctionParameters = 519, 
    RuleDurationValueExpression = 520, RuleDatetimeSubtraction = 521, RuleDatetimeSubtractionParameters = 522, 
    RuleDatetimeValueExpression1 = 523, RuleDatetimeValueExpression2 = 524, 
    RuleDurationValueFunction = 525, RuleDurationFunction = 526, RuleDurationFunctionParameters = 527, 
    RuleObjectName = 528, RuleObjectNameOrBindingVariable = 529, RuleDirectoryName = 530, 
    RuleSchemaName = 531, RuleGraphName = 532, RuleDelimitedGraphName = 533, 
    RuleGraphTypeName = 534, RuleNodeTypeName = 535, RuleEdgeTypeName = 536, 
    RuleBindingTableName = 537, RuleDelimitedBindingTableName = 538, RuleProcedureName = 539, 
    RuleLabelName = 540, RulePropertyName = 541, RuleFieldName = 542, RuleElementVariable = 543, 
    RulePathVariable = 544, RuleSubpathVariable = 545, RuleBindingVariable = 546, 
    RuleUnsignedLiteral = 547, RuleGeneralLiteral = 548, RuleTemporalLiteral = 549, 
    RuleDateLiteral = 550, RuleTimeLiteral = 551, RuleDatetimeLiteral = 552, 
    RuleListLiteral = 553, RuleRecordLiteral = 554, RuleIdentifier = 555, 
    RuleRegularIdentifier = 556, RuleTimeZoneString = 557, RuleCharacterStringLiteral = 558, 
    RuleUnsignedNumericLiteral = 559, RuleExactNumericLiteral = 560, RuleApproximateNumericLiteral = 561, 
    RuleUnsignedInteger = 562, RuleUnsignedDecimalInteger = 563, RuleNullLiteral = 564, 
    RuleDateString = 565, RuleTimeString = 566, RuleDatetimeString = 567, 
    RuleDurationLiteral = 568, RuleDurationString = 569, RuleNodeSynonym = 570, 
    RuleEdgesSynonym = 571, RuleEdgeSynonym = 572, RuleNonReservedWords = 573
  };

  explicit GQLParser(antlr4::TokenStream *input);

  GQLParser(antlr4::TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options);

  ~GQLParser() override;

  std::string getGrammarFileName() const override;

  const antlr4::atn::ATN& getATN() const override;

  const std::vector<std::string>& getRuleNames() const override;

  const antlr4::dfa::Vocabulary& getVocabulary() const override;

  antlr4::atn::SerializedATNView getSerializedATN() const override;

  template<typename T> struct is_shared_ptr : std::false_type {};
  template<typename T> struct is_shared_ptr<std::shared_ptr<T>> : std::true_type {};

  template<typename T> struct is_unique_ptr : std::false_type {};
  template<typename T> struct is_unique_ptr<std::unique_ptr<T>> : std::true_type {};

  template<typename T>
  auto get_raw_pointer(T& value) {
    if constexpr (std::is_pointer_v<std::decay_t<T>>) {
        // If it's a raw pointer, return it directly
        return value;
    } else if constexpr (is_unique_ptr<std::decay_t<T>>::value || is_shared_ptr<std::decay_t<T>>::value) {
        // If it's a smart pointer, return the raw pointer from .get()
        return value.get();
    } else {
        // Otherwise, return a pointer to the value itself
        return &value;
    }
  }

  template <typename Class, typename Enabled = void>
  struct has_ExitRule : std::false_type {};

  template <typename Class>
  struct has_ExitRule<Class,
                     std::enable_if_t<std::is_member_function_pointer_v<
                         decltype(&std::remove_pointer_t<Class>::ExitRule)>>> : std::true_type {};

  template <typename Class, typename Enabled = void>
  struct has_OnToken : std::false_type {};

  template <typename Class>
  struct has_OnToken<Class,
                     std::enable_if_t<std::is_member_function_pointer_v<
                         decltype(&std::remove_pointer_t<Class>::OnToken)>>> : std::true_type {};


  template<typename ContextT>
  antlr4::ParserRuleContext* gqlProgram(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 0, GQLParser::RuleGqlProgram);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1157);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1148);
        {
          auto childCtxHolder = ctx->EnterProgramActivity();
          programActivity(get_raw_pointer(childCtxHolder));
        }
        setState(1150);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::SESSION) {
          setState(1149);
          {
            auto childCtxHolder = ctx->EnterSessionCloseCommand();
            sessionCloseCommand(get_raw_pointer(childCtxHolder));
          }
        }
        setState(1152);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::EOF) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::EOF);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1154);
        {
          auto childCtxHolder = ctx->EnterSessionCloseCommand();
          sessionCloseCommand(get_raw_pointer(childCtxHolder));
        }
        setState(1155);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::EOF) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::EOF);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* programActivity(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 2, GQLParser::RuleProgramActivity);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1161);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::SESSION: {
          enterOuterAlt(_localctx, 1);
          setState(1159);
          {
            auto childCtxHolder = ctx->EnterSessionActivity();
            sessionActivity(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::AT:
        case GQLParser::CALL:
        case GQLParser::COMMIT:
        case GQLParser::CREATE:
        case GQLParser::DELETE:
        case GQLParser::DETACH:
        case GQLParser::DROP:
        case GQLParser::FILTER:
        case GQLParser::FINISH:
        case GQLParser::FOR:
        case GQLParser::INSERT:
        case GQLParser::LET:
        case GQLParser::LIMIT:
        case GQLParser::MATCH:
        case GQLParser::NODETACH:
        case GQLParser::OFFSET:
        case GQLParser::OPTIONAL:
        case GQLParser::ORDER:
        case GQLParser::REMOVE:
        case GQLParser::RETURN:
        case GQLParser::ROLLBACK:
        case GQLParser::SELECT:
        case GQLParser::SET:
        case GQLParser::SKIP_RESERVED_WORD:
        case GQLParser::START:
        case GQLParser::USE:
        case GQLParser::VALUE:
        case GQLParser::BINDING:
        case GQLParser::GRAPH:
        case GQLParser::PROPERTY:
        case GQLParser::TABLE:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(1160);
          {
            auto childCtxHolder = ctx->EnterTransactionActivity();
            transactionActivity(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sessionActivity(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 4, GQLParser::RuleSessionActivity);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      setState(1179);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1164); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1163);
                  {
                    auto childCtxHolder = ctx->EnterSessionResetCommand();
                    sessionResetCommand(get_raw_pointer(childCtxHolder));
                  }
                  break;
                }

          default:
            throw antlr4::NoViableAltException(this);
          }
          setState(1166); 
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
        } while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1169); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1168);
                  {
                    auto childCtxHolder = ctx->EnterSessionSetCommand();
                    sessionSetCommand(get_raw_pointer(childCtxHolder));
                  }
                  break;
                }

          default:
            throw antlr4::NoViableAltException(this);
          }
          setState(1171); 
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx);
        } while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER);
        setState(1176);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx);
        while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1173);
            {
              auto childCtxHolder = ctx->EnterSessionResetCommand();
              sessionResetCommand(get_raw_pointer(childCtxHolder));
            } 
          }
          setState(1178);
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx);
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* transactionActivity(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 6, GQLParser::RuleTransactionActivity);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1193);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::START: {
          enterOuterAlt(_localctx, 1);
          setState(1181);
          {
            auto childCtxHolder = ctx->EnterStartTransactionCommand();
            startTransactionCommand(get_raw_pointer(childCtxHolder));
          }
          setState(1186);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (((((_la - 31) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 31)) & 3461332977278001153) != 0) || ((((_la - 100) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 100)) & 6342202976706233345) != 0) || ((((_la - 177) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 177)) & 351843721159689) != 0) || ((((_la - 278) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 278)) & 34493958145) != 0) || _la == GQLParser::LEFT_BRACE) {
            setState(1182);
            {
              auto childCtxHolder = ctx->EnterProcedureSpecification();
              procedureSpecification(get_raw_pointer(childCtxHolder));
            }
            setState(1184);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == GQLParser::COMMIT || _la == GQLParser::ROLLBACK) {
              setState(1183);
              {
                auto childCtxHolder = ctx->EnterEndTransactionCommand();
                endTransactionCommand(get_raw_pointer(childCtxHolder));
              }
            }
          }
          break;
        }

        case GQLParser::AT:
        case GQLParser::CALL:
        case GQLParser::CREATE:
        case GQLParser::DELETE:
        case GQLParser::DETACH:
        case GQLParser::DROP:
        case GQLParser::FILTER:
        case GQLParser::FINISH:
        case GQLParser::FOR:
        case GQLParser::INSERT:
        case GQLParser::LET:
        case GQLParser::LIMIT:
        case GQLParser::MATCH:
        case GQLParser::NODETACH:
        case GQLParser::OFFSET:
        case GQLParser::OPTIONAL:
        case GQLParser::ORDER:
        case GQLParser::REMOVE:
        case GQLParser::RETURN:
        case GQLParser::SELECT:
        case GQLParser::SET:
        case GQLParser::SKIP_RESERVED_WORD:
        case GQLParser::USE:
        case GQLParser::VALUE:
        case GQLParser::BINDING:
        case GQLParser::GRAPH:
        case GQLParser::PROPERTY:
        case GQLParser::TABLE:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(1188);
          {
            auto childCtxHolder = ctx->EnterProcedureSpecification();
            procedureSpecification(get_raw_pointer(childCtxHolder));
          }
          setState(1190);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::COMMIT || _la == GQLParser::ROLLBACK) {
            setState(1189);
            {
              auto childCtxHolder = ctx->EnterEndTransactionCommand();
              endTransactionCommand(get_raw_pointer(childCtxHolder));
            }
          }
          break;
        }

        case GQLParser::COMMIT:
        case GQLParser::ROLLBACK: {
          enterOuterAlt(_localctx, 3);
          setState(1192);
          {
            auto childCtxHolder = ctx->EnterEndTransactionCommand();
            endTransactionCommand(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* endTransactionCommand(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 8, GQLParser::RuleEndTransactionCommand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1197);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ROLLBACK: {
          enterOuterAlt(_localctx, 1);
          setState(1195);
          {
            auto childCtxHolder = ctx->EnterRollbackCommand();
            rollbackCommand(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::COMMIT: {
          enterOuterAlt(_localctx, 2);
          setState(1196);
          {
            auto childCtxHolder = ctx->EnterCommitCommand();
            commitCommand(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sessionSetCommand(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 10, GQLParser::RuleSessionSetCommand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1199);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SESSION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SESSION);
      setState(1200);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SET);
      setState(1205);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
      case 1: {
        setState(1201);
        {
          auto childCtxHolder = ctx->EnterSessionSetSchemaClause();
          sessionSetSchemaClause(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        setState(1202);
        {
          auto childCtxHolder = ctx->EnterSessionSetGraphClause();
          sessionSetGraphClause(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        setState(1203);
        {
          auto childCtxHolder = ctx->EnterSessionSetTimeZoneClause();
          sessionSetTimeZoneClause(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        setState(1204);
        {
          auto childCtxHolder = ctx->EnterSessionSetParameterClause();
          sessionSetParameterClause(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sessionSetSchemaClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 12, GQLParser::RuleSessionSetSchemaClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1207);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SCHEMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SCHEMA);
      setState(1208);
      {
        auto childCtxHolder = ctx->EnterSchemaReference();
        schemaReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sessionSetGraphClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 14, GQLParser::RuleSessionSetGraphClause);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1211);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PROPERTY) {
        setState(1210);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
      }
      setState(1213);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GRAPH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GRAPH);
      setState(1214);
      {
        auto childCtxHolder = ctx->EnterGraphExpression();
        graphExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sessionSetTimeZoneClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 16, GQLParser::RuleSessionSetTimeZoneClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1216);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TIME) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TIME);
      setState(1217);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ZONE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ZONE);
      setState(1218);
      {
        auto childCtxHolder = ctx->EnterSetTimeZoneValue();
        setTimeZoneValue(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* setTimeZoneValue(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 18, GQLParser::RuleSetTimeZoneValue);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1220);
      {
        auto childCtxHolder = ctx->EnterTimeZoneString();
        timeZoneString(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sessionSetParameterClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 20, GQLParser::RuleSessionSetParameterClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1225);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::GRAPH:
        case GQLParser::PROPERTY: {
          enterOuterAlt(_localctx, 1);
          setState(1222);
          {
            auto childCtxHolder = ctx->EnterSessionSetGraphParameterClause();
            sessionSetGraphParameterClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BINDING:
        case GQLParser::TABLE: {
          enterOuterAlt(_localctx, 2);
          setState(1223);
          {
            auto childCtxHolder = ctx->EnterSessionSetBindingTableParameterClause();
            sessionSetBindingTableParameterClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::VALUE: {
          enterOuterAlt(_localctx, 3);
          setState(1224);
          {
            auto childCtxHolder = ctx->EnterSessionSetValueParameterClause();
            sessionSetValueParameterClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sessionSetGraphParameterClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 22, GQLParser::RuleSessionSetGraphParameterClause);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1228);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PROPERTY) {
        setState(1227);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
      }
      setState(1230);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GRAPH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GRAPH);
      setState(1231);
      {
        auto childCtxHolder = ctx->EnterSessionSetParameterName();
        sessionSetParameterName(get_raw_pointer(childCtxHolder));
      }
      setState(1232);
      {
        auto childCtxHolder = ctx->EnterOptTypedGraphInitializer();
        optTypedGraphInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sessionSetBindingTableParameterClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 24, GQLParser::RuleSessionSetBindingTableParameterClause);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1235);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::BINDING) {
        setState(1234);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::BINDING) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::BINDING);
      }
      setState(1237);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TABLE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TABLE);
      setState(1238);
      {
        auto childCtxHolder = ctx->EnterSessionSetParameterName();
        sessionSetParameterName(get_raw_pointer(childCtxHolder));
      }
      setState(1239);
      {
        auto childCtxHolder = ctx->EnterOptTypedBindingTableInitializer();
        optTypedBindingTableInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sessionSetValueParameterClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 26, GQLParser::RuleSessionSetValueParameterClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1241);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::VALUE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::VALUE);
      setState(1242);
      {
        auto childCtxHolder = ctx->EnterSessionSetParameterName();
        sessionSetParameterName(get_raw_pointer(childCtxHolder));
      }
      setState(1243);
      {
        auto childCtxHolder = ctx->EnterOptTypedValueInitializer();
        optTypedValueInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sessionSetParameterName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 28, GQLParser::RuleSessionSetParameterName);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1248);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IF) {
        setState(1245);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::IF) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::IF);
        setState(1246);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
        setState(1247);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::EXISTS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::EXISTS);
      }
      setState(1250);
      {
        auto childCtxHolder = ctx->EnterSessionParameterSpecification();
        sessionParameterSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sessionResetCommand(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 30, GQLParser::RuleSessionResetCommand);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1252);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SESSION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SESSION);
      setState(1253);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RESET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RESET);
      setState(1255);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ALL

      || _la == GQLParser::CHARACTERISTICS || ((((_la - 164) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 164)) & 8796095119363) != 0) || ((((_la - 289) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 289)) & 274877972481) != 0)) {
        setState(1254);
        {
          auto childCtxHolder = ctx->EnterSessionResetArguments();
          sessionResetArguments(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sessionResetArguments(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 32, GQLParser::RuleSessionResetArguments);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1272);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ALL:
        case GQLParser::CHARACTERISTICS:
        case GQLParser::PARAMETERS: {
          enterOuterAlt(_localctx, 1);
          setState(1258);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::ALL) {
            setState(1257);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::ALL) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::ALL);
          }
          setState(1260);
          _la = _input->LA(1);
          if (!(_la == GQLParser::CHARACTERISTICS || _la == GQLParser::PARAMETERS)) {
            _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            antlr4::Token * token = consume();
            ctx->OnToken(token);
          }
          break;
        }

        case GQLParser::SCHEMA: {
          enterOuterAlt(_localctx, 2);
          setState(1261);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::SCHEMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::SCHEMA);
          break;
        }

        case GQLParser::GRAPH:
        case GQLParser::PROPERTY: {
          enterOuterAlt(_localctx, 3);
          setState(1263);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::PROPERTY) {
            setState(1262);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PROPERTY) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PROPERTY);
          }
          setState(1265);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::GRAPH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::GRAPH);
          break;
        }

        case GQLParser::TIME: {
          enterOuterAlt(_localctx, 4);
          setState(1266);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(1267);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONE);
          break;
        }

        case GQLParser::PARAMETER:
        case GQLParser::GENERAL_PARAMETER_REFERENCE: {
          enterOuterAlt(_localctx, 5);
          setState(1269);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::PARAMETER) {
            setState(1268);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PARAMETER) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PARAMETER);
          }
          setState(1271);
          {
            auto childCtxHolder = ctx->EnterSessionParameterSpecification();
            sessionParameterSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sessionCloseCommand(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 34, GQLParser::RuleSessionCloseCommand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1274);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SESSION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SESSION);
      setState(1275);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CLOSE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CLOSE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sessionParameterSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 36, GQLParser::RuleSessionParameterSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1277);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GENERAL_PARAMETER_REFERENCE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GENERAL_PARAMETER_REFERENCE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* startTransactionCommand(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 38, GQLParser::RuleStartTransactionCommand);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1279);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::START) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::START);
      setState(1280);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TRANSACTION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TRANSACTION);
      setState(1282);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::READ) {
        setState(1281);
        {
          auto childCtxHolder = ctx->EnterTransactionCharacteristics();
          transactionCharacteristics(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* transactionCharacteristics(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 40, GQLParser::RuleTransactionCharacteristics);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1284);
      {
        auto childCtxHolder = ctx->EnterTransactionMode();
        transactionMode(get_raw_pointer(childCtxHolder));
      }
      setState(1289);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(1285);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(1286);
        {
          auto childCtxHolder = ctx->EnterTransactionMode();
          transactionMode(get_raw_pointer(childCtxHolder));
        }
        setState(1291);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* transactionMode(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 42, GQLParser::RuleTransactionMode);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1292);
      {
        auto childCtxHolder = ctx->EnterTransactionAccessMode();
        transactionAccessMode(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* transactionAccessMode(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 44, GQLParser::RuleTransactionAccessMode);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1298);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1294);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::READ) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::READ);
        setState(1295);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::ONLY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::ONLY);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1296);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::READ) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::READ);
        setState(1297);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::WRITE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::WRITE);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* rollbackCommand(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 46, GQLParser::RuleRollbackCommand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1300);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ROLLBACK) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ROLLBACK);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* commitCommand(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 48, GQLParser::RuleCommitCommand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1302);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMIT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMIT);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nestedProcedureSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 50, GQLParser::RuleNestedProcedureSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1304);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(1305);
      {
        auto childCtxHolder = ctx->EnterProcedureSpecification();
        procedureSpecification(get_raw_pointer(childCtxHolder));
      }
      setState(1306);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* procedureSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 52, GQLParser::RuleProcedureSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1308);
      {
        auto childCtxHolder = ctx->EnterProcedureBody();
        procedureBody(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nestedDataModifyingProcedureSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 54, GQLParser::RuleNestedDataModifyingProcedureSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1310);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(1311);
      {
        auto childCtxHolder = ctx->EnterProcedureBody();
        procedureBody(get_raw_pointer(childCtxHolder));
      }
      setState(1312);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nestedQuerySpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 56, GQLParser::RuleNestedQuerySpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1314);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(1315);
      {
        auto childCtxHolder = ctx->EnterProcedureBody();
        procedureBody(get_raw_pointer(childCtxHolder));
      }
      setState(1316);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* procedureBody(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 58, GQLParser::RuleProcedureBody);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1319);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::AT) {
        setState(1318);
        {
          auto childCtxHolder = ctx->EnterAtSchemaClause();
          atSchemaClause(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1322);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::VALUE

      || _la == GQLParser::BINDING || ((((_la - 289) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 289)) & 16842753) != 0)) {
        setState(1321);
        {
          auto childCtxHolder = ctx->EnterBindingVariableDefinitionBlock();
          bindingVariableDefinitionBlock(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1324);
      {
        auto childCtxHolder = ctx->EnterStatementBlock();
        statementBlock(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* bindingVariableDefinitionBlock(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 60, GQLParser::RuleBindingVariableDefinitionBlock);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1327); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1326);
        {
          auto childCtxHolder = ctx->EnterBindingVariableDefinition();
          bindingVariableDefinition(get_raw_pointer(childCtxHolder));
        }
        setState(1329); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == GQLParser::VALUE

      || _la == GQLParser::BINDING || ((((_la - 289) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 289)) & 16842753) != 0));
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* bindingVariableDefinition(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 62, GQLParser::RuleBindingVariableDefinition);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1334);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::GRAPH:
        case GQLParser::PROPERTY: {
          enterOuterAlt(_localctx, 1);
          setState(1331);
          {
            auto childCtxHolder = ctx->EnterGraphVariableDefinition();
            graphVariableDefinition(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BINDING:
        case GQLParser::TABLE: {
          enterOuterAlt(_localctx, 2);
          setState(1332);
          {
            auto childCtxHolder = ctx->EnterBindingTableVariableDefinition();
            bindingTableVariableDefinition(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::VALUE: {
          enterOuterAlt(_localctx, 3);
          setState(1333);
          {
            auto childCtxHolder = ctx->EnterValueVariableDefinition();
            valueVariableDefinition(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* statementBlock(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 64, GQLParser::RuleStatementBlock);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1336);
      {
        auto childCtxHolder = ctx->EnterStatement();
        statement(get_raw_pointer(childCtxHolder));
      }
      setState(1340);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::NEXT) {
        setState(1337);
        {
          auto childCtxHolder = ctx->EnterNextStatement();
          nextStatement(get_raw_pointer(childCtxHolder));
        }
        setState(1342);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* statement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 66, GQLParser::RuleStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1346);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1343);
        {
          auto childCtxHolder = ctx->EnterLinearCatalogModifyingStatement();
          linearCatalogModifyingStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1344);
        {
          auto childCtxHolder = ctx->EnterLinearDataModifyingStatement();
          linearDataModifyingStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1345);
        {
          auto childCtxHolder = ctx->EnterCompositeQueryStatement();
          compositeQueryStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nextStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 68, GQLParser::RuleNextStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1348);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NEXT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NEXT);
      setState(1350);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::YIELD) {
        setState(1349);
        {
          auto childCtxHolder = ctx->EnterYieldClause();
          yieldClause(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1352);
      {
        auto childCtxHolder = ctx->EnterStatement();
        statement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphVariableDefinition(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 70, GQLParser::RuleGraphVariableDefinition);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1355);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PROPERTY) {
        setState(1354);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
      }
      setState(1357);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GRAPH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GRAPH);
      setState(1358);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
      setState(1359);
      {
        auto childCtxHolder = ctx->EnterOptTypedGraphInitializer();
        optTypedGraphInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* optTypedGraphInitializer(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 72, GQLParser::RuleOptTypedGraphInitializer);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1365);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ANY || _la == GQLParser::TYPED || ((((_la - 289) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 289)) & 8796093087745) != 0)) {
        setState(1362);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
          setState(1361);
          {
            auto childCtxHolder = ctx->EnterTyped();
            typed(get_raw_pointer(childCtxHolder));
          }
        }
        setState(1364);
        {
          auto childCtxHolder = ctx->EnterGraphReferenceValueType();
          graphReferenceValueType(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1367);
      {
        auto childCtxHolder = ctx->EnterGraphInitializer();
        graphInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphInitializer(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 74, GQLParser::RuleGraphInitializer);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1369);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EQUALS_OPERATOR);
      setState(1370);
      {
        auto childCtxHolder = ctx->EnterGraphExpression();
        graphExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* bindingTableVariableDefinition(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 76, GQLParser::RuleBindingTableVariableDefinition);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1373);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::BINDING) {
        setState(1372);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::BINDING) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::BINDING);
      }
      setState(1375);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TABLE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TABLE);
      setState(1376);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
      setState(1377);
      {
        auto childCtxHolder = ctx->EnterOptTypedBindingTableInitializer();
        optTypedBindingTableInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* optTypedBindingTableInitializer(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 78, GQLParser::RuleOptTypedBindingTableInitializer);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1383);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::TYPED || ((((_la - 278) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 278)) & 18014432869220353) != 0)) {
        setState(1380);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
          setState(1379);
          {
            auto childCtxHolder = ctx->EnterTyped();
            typed(get_raw_pointer(childCtxHolder));
          }
        }
        setState(1382);
        {
          auto childCtxHolder = ctx->EnterBindingTableReferenceValueType();
          bindingTableReferenceValueType(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1385);
      {
        auto childCtxHolder = ctx->EnterBindingTableInitializer();
        bindingTableInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* bindingTableInitializer(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 80, GQLParser::RuleBindingTableInitializer);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1387);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EQUALS_OPERATOR);
      setState(1388);
      {
        auto childCtxHolder = ctx->EnterBindingTableExpression();
        bindingTableExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* valueVariableDefinition(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 82, GQLParser::RuleValueVariableDefinition);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1390);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::VALUE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::VALUE);
      setState(1391);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
      setState(1392);
      {
        auto childCtxHolder = ctx->EnterOptTypedValueInitializer();
        optTypedValueInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* optTypedValueInitializer(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 84, GQLParser::RuleOptTypedValueInitializer);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1398);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1135228676472832) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 70)) & -9187345434035607527) != 0) || ((((_la - 135) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 135)) & 6989589922362163201) != 0) || ((((_la - 202) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 202)) & 8645246561) != 0) || ((((_la - 278) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 278)) & 18021030618466401) != 0) || _la == GQLParser::LEFT_BRACE

      || _la == GQLParser::LEFT_PAREN) {
        setState(1395);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
          setState(1394);
          {
            auto childCtxHolder = ctx->EnterTyped();
            typed(get_raw_pointer(childCtxHolder));
          }
        }
        setState(1397);
        {
          auto childCtxHolder = ctx->EnterValueType();
          valueType(0, get_raw_pointer(childCtxHolder));
        }
      }
      setState(1400);
      {
        auto childCtxHolder = ctx->EnterValueInitializer();
        valueInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* valueInitializer(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 86, GQLParser::RuleValueInitializer);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1402);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EQUALS_OPERATOR);
      setState(1403);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 88, GQLParser::RuleGraphExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1409);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1405);
        {
          auto childCtxHolder = ctx->EnterGraphReference();
          graphReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1406);
        {
          auto childCtxHolder = ctx->EnterObjectExpressionPrimary();
          objectExpressionPrimary(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1407);
        {
          auto childCtxHolder = ctx->EnterObjectNameOrBindingVariable();
          objectNameOrBindingVariable(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(1408);
        {
          auto childCtxHolder = ctx->EnterCurrentGraph();
          currentGraph(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* currentGraph(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 90, GQLParser::RuleCurrentGraph);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1411);
      _la = _input->LA(1);
      if (!(_la == GQLParser::CURRENT_GRAPH

      || _la == GQLParser::CURRENT_PROPERTY_GRAPH)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* bindingTableExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 92, GQLParser::RuleBindingTableExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1417);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1413);
        {
          auto childCtxHolder = ctx->EnterNestedBindingTableQuerySpecification();
          nestedBindingTableQuerySpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1414);
        {
          auto childCtxHolder = ctx->EnterBindingTableReference();
          bindingTableReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1415);
        {
          auto childCtxHolder = ctx->EnterObjectExpressionPrimary();
          objectExpressionPrimary(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(1416);
        {
          auto childCtxHolder = ctx->EnterObjectNameOrBindingVariable();
          objectNameOrBindingVariable(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nestedBindingTableQuerySpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 94, GQLParser::RuleNestedBindingTableQuerySpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1419);
      {
        auto childCtxHolder = ctx->EnterNestedQuerySpecification();
        nestedQuerySpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* objectExpressionPrimary(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 96, GQLParser::RuleObjectExpressionPrimary);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1425);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1421);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::VARIABLE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::VARIABLE);
        setState(1422);
        {
          auto childCtxHolder = ctx->EnterValueExpressionPrimary();
          valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1423);
        {
          auto childCtxHolder = ctx->EnterParenthesizedValueExpression();
          parenthesizedValueExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1424);
        {
          auto childCtxHolder = ctx->EnterNonParenthesizedValueExpressionPrimarySpecialCase();
          nonParenthesizedValueExpressionPrimarySpecialCase(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* linearCatalogModifyingStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 98, GQLParser::RuleLinearCatalogModifyingStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1428); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1427);
        {
          auto childCtxHolder = ctx->EnterSimpleCatalogModifyingStatement();
          simpleCatalogModifyingStatement(get_raw_pointer(childCtxHolder));
        }
        setState(1430); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (((((_la - 44) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 44)) & 274878431233) != 0) || _la == GQLParser::OPTIONAL);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simpleCatalogModifyingStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 100, GQLParser::RuleSimpleCatalogModifyingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1434);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CREATE:
        case GQLParser::DROP: {
          enterOuterAlt(_localctx, 1);
          setState(1432);
          {
            auto childCtxHolder = ctx->EnterPrimitiveCatalogModifyingStatement();
            primitiveCatalogModifyingStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CALL:
        case GQLParser::OPTIONAL: {
          enterOuterAlt(_localctx, 2);
          setState(1433);
          {
            auto childCtxHolder = ctx->EnterCallCatalogModifyingProcedureStatement();
            callCatalogModifyingProcedureStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* primitiveCatalogModifyingStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 102, GQLParser::RulePrimitiveCatalogModifyingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1442);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1436);
        {
          auto childCtxHolder = ctx->EnterCreateSchemaStatement();
          createSchemaStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1437);
        {
          auto childCtxHolder = ctx->EnterDropSchemaStatement();
          dropSchemaStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1438);
        {
          auto childCtxHolder = ctx->EnterCreateGraphStatement();
          createGraphStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(1439);
        {
          auto childCtxHolder = ctx->EnterDropGraphStatement();
          dropGraphStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(1440);
        {
          auto childCtxHolder = ctx->EnterCreateGraphTypeStatement();
          createGraphTypeStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(1441);
        {
          auto childCtxHolder = ctx->EnterDropGraphTypeStatement();
          dropGraphTypeStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* createSchemaStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 104, GQLParser::RuleCreateSchemaStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1444);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CREATE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CREATE);
      setState(1445);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SCHEMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SCHEMA);
      setState(1449);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IF) {
        setState(1446);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::IF) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::IF);
        setState(1447);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
        setState(1448);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::EXISTS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::EXISTS);
      }
      setState(1451);
      {
        auto childCtxHolder = ctx->EnterCatalogSchemaParentAndName();
        catalogSchemaParentAndName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* dropSchemaStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 106, GQLParser::RuleDropSchemaStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1453);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DROP) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DROP);
      setState(1454);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SCHEMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SCHEMA);
      setState(1457);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IF) {
        setState(1455);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::IF) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::IF);
        setState(1456);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::EXISTS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::EXISTS);
      }
      setState(1459);
      {
        auto childCtxHolder = ctx->EnterCatalogSchemaParentAndName();
        catalogSchemaParentAndName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* createGraphStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 108, GQLParser::RuleCreateGraphStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1461);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CREATE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CREATE);
      setState(1477);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::GRAPH:
        case GQLParser::PROPERTY: {
          setState(1463);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::PROPERTY) {
            setState(1462);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PROPERTY) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PROPERTY);
          }
          setState(1465);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::GRAPH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::GRAPH);
          setState(1469);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::IF) {
            setState(1466);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::IF) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::IF);
            setState(1467);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::NOT) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::NOT);
            setState(1468);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::EXISTS) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::EXISTS);
          }
          break;
        }

        case GQLParser::OR: {
          setState(1471);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::OR) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::OR);
          setState(1472);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::REPLACE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::REPLACE);
          setState(1474);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::PROPERTY) {
            setState(1473);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PROPERTY) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PROPERTY);
          }
          setState(1476);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::GRAPH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::GRAPH);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
      setState(1479);
      {
        auto childCtxHolder = ctx->EnterCatalogGraphParentAndName();
        catalogGraphParentAndName(get_raw_pointer(childCtxHolder));
      }
      setState(1482);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
      case 1: {
        setState(1480);
        {
          auto childCtxHolder = ctx->EnterOpenGraphType();
          openGraphType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        setState(1481);
        {
          auto childCtxHolder = ctx->EnterOfGraphType();
          ofGraphType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(1485);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::AS) {
        setState(1484);
        {
          auto childCtxHolder = ctx->EnterGraphSource();
          graphSource(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* openGraphType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 110, GQLParser::RuleOpenGraphType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1488);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
        setState(1487);
        {
          auto childCtxHolder = ctx->EnterTyped();
          typed(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1490);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ANY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ANY);
      setState(1495);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::GRAPH

      || _la == GQLParser::PROPERTY) {
        setState(1492);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::PROPERTY) {
          setState(1491);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::PROPERTY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::PROPERTY);
        }
        setState(1494);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::GRAPH) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::GRAPH);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* ofGraphType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 112, GQLParser::RuleOfGraphType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1512);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1497);
        {
          auto childCtxHolder = ctx->EnterGraphTypeLikeGraph();
          graphTypeLikeGraph(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1499);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
          setState(1498);
          {
            auto childCtxHolder = ctx->EnterTyped();
            typed(get_raw_pointer(childCtxHolder));
          }
        }
        setState(1501);
        {
          auto childCtxHolder = ctx->EnterGraphTypeReference();
          graphTypeReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1503);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
          setState(1502);
          {
            auto childCtxHolder = ctx->EnterTyped();
            typed(get_raw_pointer(childCtxHolder));
          }
        }
        setState(1509);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::GRAPH

        || _la == GQLParser::PROPERTY) {
          setState(1506);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::PROPERTY) {
            setState(1505);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PROPERTY) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PROPERTY);
          }
          setState(1508);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::GRAPH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::GRAPH);
        }
        setState(1511);
        {
          auto childCtxHolder = ctx->EnterNestedGraphTypeSpecification();
          nestedGraphTypeSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphTypeLikeGraph(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 114, GQLParser::RuleGraphTypeLikeGraph);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1514);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LIKE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LIKE);
      setState(1515);
      {
        auto childCtxHolder = ctx->EnterGraphExpression();
        graphExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphSource(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 116, GQLParser::RuleGraphSource);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1517);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::AS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::AS);
      setState(1518);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COPY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COPY);
      setState(1519);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::OF) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::OF);
      setState(1520);
      {
        auto childCtxHolder = ctx->EnterGraphExpression();
        graphExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* dropGraphStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 118, GQLParser::RuleDropGraphStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1522);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DROP) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DROP);
      setState(1524);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PROPERTY) {
        setState(1523);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
      }
      setState(1526);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GRAPH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GRAPH);
      setState(1529);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IF) {
        setState(1527);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::IF) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::IF);
        setState(1528);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::EXISTS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::EXISTS);
      }
      setState(1531);
      {
        auto childCtxHolder = ctx->EnterCatalogGraphParentAndName();
        catalogGraphParentAndName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* createGraphTypeStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 120, GQLParser::RuleCreateGraphTypeStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1533);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CREATE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CREATE);
      setState(1551);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::GRAPH:
        case GQLParser::PROPERTY: {
          setState(1535);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::PROPERTY) {
            setState(1534);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PROPERTY) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PROPERTY);
          }
          setState(1537);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::GRAPH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::GRAPH);
          setState(1538);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TYPE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TYPE);
          setState(1542);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::IF) {
            setState(1539);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::IF) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::IF);
            setState(1540);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::NOT) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::NOT);
            setState(1541);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::EXISTS) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::EXISTS);
          }
          break;
        }

        case GQLParser::OR: {
          setState(1544);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::OR) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::OR);
          setState(1545);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::REPLACE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::REPLACE);
          setState(1547);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::PROPERTY) {
            setState(1546);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PROPERTY) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PROPERTY);
          }
          setState(1549);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::GRAPH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::GRAPH);
          setState(1550);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TYPE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TYPE);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
      setState(1553);
      {
        auto childCtxHolder = ctx->EnterCatalogGraphTypeParentAndName();
        catalogGraphTypeParentAndName(get_raw_pointer(childCtxHolder));
      }
      setState(1554);
      {
        auto childCtxHolder = ctx->EnterGraphTypeSource();
        graphTypeSource(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphTypeSource(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 122, GQLParser::RuleGraphTypeSource);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1565);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1557);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::AS) {
          setState(1556);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::AS) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::AS);
        }
        setState(1559);
        {
          auto childCtxHolder = ctx->EnterCopyOfGraphType();
          copyOfGraphType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1560);
        {
          auto childCtxHolder = ctx->EnterGraphTypeLikeGraph();
          graphTypeLikeGraph(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1562);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::AS) {
          setState(1561);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::AS) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::AS);
        }
        setState(1564);
        {
          auto childCtxHolder = ctx->EnterNestedGraphTypeSpecification();
          nestedGraphTypeSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* copyOfGraphType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 124, GQLParser::RuleCopyOfGraphType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1567);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COPY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COPY);
      setState(1568);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::OF) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::OF);
      setState(1569);
      {
        auto childCtxHolder = ctx->EnterGraphTypeReference();
        graphTypeReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* dropGraphTypeStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 126, GQLParser::RuleDropGraphTypeStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1571);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DROP) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DROP);
      setState(1573);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PROPERTY) {
        setState(1572);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
      }
      setState(1575);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GRAPH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GRAPH);
      setState(1576);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TYPE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TYPE);
      setState(1579);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IF) {
        setState(1577);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::IF) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::IF);
        setState(1578);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::EXISTS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::EXISTS);
      }
      setState(1581);
      {
        auto childCtxHolder = ctx->EnterCatalogGraphTypeParentAndName();
        catalogGraphTypeParentAndName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* callCatalogModifyingProcedureStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 128, GQLParser::RuleCallCatalogModifyingProcedureStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1583);
      {
        auto childCtxHolder = ctx->EnterCallProcedureStatement();
        callProcedureStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* linearDataModifyingStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 130, GQLParser::RuleLinearDataModifyingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1587);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::USE: {
          enterOuterAlt(_localctx, 1);
          setState(1585);
          {
            auto childCtxHolder = ctx->EnterFocusedLinearDataModifyingStatement();
            focusedLinearDataModifyingStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CALL:
        case GQLParser::DELETE:
        case GQLParser::DETACH:
        case GQLParser::FILTER:
        case GQLParser::FOR:
        case GQLParser::INSERT:
        case GQLParser::LET:
        case GQLParser::LIMIT:
        case GQLParser::MATCH:
        case GQLParser::NODETACH:
        case GQLParser::OFFSET:
        case GQLParser::OPTIONAL:
        case GQLParser::ORDER:
        case GQLParser::REMOVE:
        case GQLParser::SET:
        case GQLParser::SKIP_RESERVED_WORD:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(1586);
          {
            auto childCtxHolder = ctx->EnterAmbientLinearDataModifyingStatement();
            ambientLinearDataModifyingStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* focusedLinearDataModifyingStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 132, GQLParser::RuleFocusedLinearDataModifyingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1591);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1589);
        {
          auto childCtxHolder = ctx->EnterFocusedLinearDataModifyingStatementBody();
          focusedLinearDataModifyingStatementBody(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1590);
        {
          auto childCtxHolder = ctx->EnterFocusedNestedDataModifyingProcedureSpecification();
          focusedNestedDataModifyingProcedureSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* focusedLinearDataModifyingStatementBody(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 134, GQLParser::RuleFocusedLinearDataModifyingStatementBody);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1593);
      {
        auto childCtxHolder = ctx->EnterUseGraphClause();
        useGraphClause(get_raw_pointer(childCtxHolder));
      }
      setState(1594);
      {
        auto childCtxHolder = ctx->EnterSimpleLinearDataAccessingStatement();
        simpleLinearDataAccessingStatement(get_raw_pointer(childCtxHolder));
      }
      setState(1596);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::FINISH || _la == GQLParser::RETURN) {
        setState(1595);
        {
          auto childCtxHolder = ctx->EnterPrimitiveResultStatement();
          primitiveResultStatement(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* focusedNestedDataModifyingProcedureSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 136, GQLParser::RuleFocusedNestedDataModifyingProcedureSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1598);
      {
        auto childCtxHolder = ctx->EnterUseGraphClause();
        useGraphClause(get_raw_pointer(childCtxHolder));
      }
      setState(1599);
      {
        auto childCtxHolder = ctx->EnterNestedDataModifyingProcedureSpecification();
        nestedDataModifyingProcedureSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* ambientLinearDataModifyingStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 138, GQLParser::RuleAmbientLinearDataModifyingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1603);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CALL:
        case GQLParser::DELETE:
        case GQLParser::DETACH:
        case GQLParser::FILTER:
        case GQLParser::FOR:
        case GQLParser::INSERT:
        case GQLParser::LET:
        case GQLParser::LIMIT:
        case GQLParser::MATCH:
        case GQLParser::NODETACH:
        case GQLParser::OFFSET:
        case GQLParser::OPTIONAL:
        case GQLParser::ORDER:
        case GQLParser::REMOVE:
        case GQLParser::SET:
        case GQLParser::SKIP_RESERVED_WORD: {
          enterOuterAlt(_localctx, 1);
          setState(1601);
          {
            auto childCtxHolder = ctx->EnterAmbientLinearDataModifyingStatementBody();
            ambientLinearDataModifyingStatementBody(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(1602);
          {
            auto childCtxHolder = ctx->EnterNestedDataModifyingProcedureSpecification();
            nestedDataModifyingProcedureSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* ambientLinearDataModifyingStatementBody(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 140, GQLParser::RuleAmbientLinearDataModifyingStatementBody);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1605);
      {
        auto childCtxHolder = ctx->EnterSimpleLinearDataAccessingStatement();
        simpleLinearDataAccessingStatement(get_raw_pointer(childCtxHolder));
      }
      setState(1607);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::FINISH || _la == GQLParser::RETURN) {
        setState(1606);
        {
          auto childCtxHolder = ctx->EnterPrimitiveResultStatement();
          primitiveResultStatement(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simpleLinearDataAccessingStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 142, GQLParser::RuleSimpleLinearDataAccessingStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1610); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1609);
        {
          auto childCtxHolder = ctx->EnterSimpleDataAccessingStatement();
          simpleDataAccessingStatement(get_raw_pointer(childCtxHolder));
        }
        setState(1612); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == GQLParser::CALL || ((((_la - 76) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 76)) & 90072009744089097) != 0) || ((((_la - 143) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 143)) & 4644354296316033) != 0));
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simpleDataAccessingStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 144, GQLParser::RuleSimpleDataAccessingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1616);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1614);
        {
          auto childCtxHolder = ctx->EnterSimpleQueryStatement();
          simpleQueryStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1615);
        {
          auto childCtxHolder = ctx->EnterSimpleDataModifyingStatement();
          simpleDataModifyingStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simpleDataModifyingStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 146, GQLParser::RuleSimpleDataModifyingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1620);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::DELETE:
        case GQLParser::DETACH:
        case GQLParser::INSERT:
        case GQLParser::NODETACH:
        case GQLParser::REMOVE:
        case GQLParser::SET: {
          enterOuterAlt(_localctx, 1);
          setState(1618);
          {
            auto childCtxHolder = ctx->EnterPrimitiveDataModifyingStatement();
            primitiveDataModifyingStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CALL:
        case GQLParser::OPTIONAL: {
          enterOuterAlt(_localctx, 2);
          setState(1619);
          {
            auto childCtxHolder = ctx->EnterCallDataModifyingProcedureStatement();
            callDataModifyingProcedureStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* primitiveDataModifyingStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 148, GQLParser::RulePrimitiveDataModifyingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1626);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::INSERT: {
          enterOuterAlt(_localctx, 1);
          setState(1622);
          {
            auto childCtxHolder = ctx->EnterInsertStatement();
            insertStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::SET: {
          enterOuterAlt(_localctx, 2);
          setState(1623);
          {
            auto childCtxHolder = ctx->EnterSetStatement();
            setStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::REMOVE: {
          enterOuterAlt(_localctx, 3);
          setState(1624);
          {
            auto childCtxHolder = ctx->EnterRemoveStatement();
            removeStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DELETE:
        case GQLParser::DETACH:
        case GQLParser::NODETACH: {
          enterOuterAlt(_localctx, 4);
          setState(1625);
          {
            auto childCtxHolder = ctx->EnterDeleteStatement();
            deleteStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* insertStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 150, GQLParser::RuleInsertStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1628);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::INSERT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::INSERT);
      setState(1629);
      {
        auto childCtxHolder = ctx->EnterInsertGraphPattern();
        insertGraphPattern(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* setStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 152, GQLParser::RuleSetStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1631);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SET);
      setState(1632);
      {
        auto childCtxHolder = ctx->EnterSetItemList();
        setItemList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* setItemList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 154, GQLParser::RuleSetItemList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1634);
      {
        auto childCtxHolder = ctx->EnterSetItem();
        setItem(get_raw_pointer(childCtxHolder));
      }
      setState(1639);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(1635);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(1636);
        {
          auto childCtxHolder = ctx->EnterSetItem();
          setItem(get_raw_pointer(childCtxHolder));
        }
        setState(1641);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* setItem(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 156, GQLParser::RuleSetItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1645);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1642);
        {
          auto childCtxHolder = ctx->EnterSetPropertyItem();
          setPropertyItem(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1643);
        {
          auto childCtxHolder = ctx->EnterSetAllPropertiesItem();
          setAllPropertiesItem(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1644);
        {
          auto childCtxHolder = ctx->EnterSetLabelItem();
          setLabelItem(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* setPropertyItem(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 158, GQLParser::RuleSetPropertyItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1647);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(1648);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::PERIOD) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::PERIOD);
      setState(1649);
      {
        auto childCtxHolder = ctx->EnterPropertyName();
        propertyName(get_raw_pointer(childCtxHolder));
      }
      setState(1650);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EQUALS_OPERATOR);
      setState(1651);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* setAllPropertiesItem(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 160, GQLParser::RuleSetAllPropertiesItem);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1653);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(1654);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EQUALS_OPERATOR);
      setState(1655);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(1657);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE

      || _la == GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0)) {
        setState(1656);
        {
          auto childCtxHolder = ctx->EnterPropertyKeyValuePairList();
          propertyKeyValuePairList(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1659);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* setLabelItem(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 162, GQLParser::RuleSetLabelItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1661);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(1662);
      {
        auto childCtxHolder = ctx->EnterIsOrColon();
        isOrColon(get_raw_pointer(childCtxHolder));
      }
      setState(1663);
      {
        auto childCtxHolder = ctx->EnterLabelName();
        labelName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* removeStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 164, GQLParser::RuleRemoveStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1665);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::REMOVE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::REMOVE);
      setState(1666);
      {
        auto childCtxHolder = ctx->EnterRemoveItemList();
        removeItemList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* removeItemList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 166, GQLParser::RuleRemoveItemList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1668);
      {
        auto childCtxHolder = ctx->EnterRemoveItem();
        removeItem(get_raw_pointer(childCtxHolder));
      }
      setState(1673);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(1669);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(1670);
        {
          auto childCtxHolder = ctx->EnterRemoveItem();
          removeItem(get_raw_pointer(childCtxHolder));
        }
        setState(1675);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* removeItem(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 168, GQLParser::RuleRemoveItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1678);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1676);
        {
          auto childCtxHolder = ctx->EnterRemovePropertyItem();
          removePropertyItem(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1677);
        {
          auto childCtxHolder = ctx->EnterRemoveLabelItem();
          removeLabelItem(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* removePropertyItem(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 170, GQLParser::RuleRemovePropertyItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1680);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(1681);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::PERIOD) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::PERIOD);
      setState(1682);
      {
        auto childCtxHolder = ctx->EnterPropertyName();
        propertyName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* removeLabelItem(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 172, GQLParser::RuleRemoveLabelItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1684);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(1685);
      {
        auto childCtxHolder = ctx->EnterIsOrColon();
        isOrColon(get_raw_pointer(childCtxHolder));
      }
      setState(1686);
      {
        auto childCtxHolder = ctx->EnterLabelName();
        labelName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* deleteStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 174, GQLParser::RuleDeleteStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1689);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::DETACH || _la == GQLParser::NODETACH) {
        setState(1688);
        _la = _input->LA(1);
        if (!(_la == GQLParser::DETACH || _la == GQLParser::NODETACH)) {
          _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          antlr4::Token * token = consume();
          ctx->OnToken(token);
        }
      }
      setState(1691);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DELETE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DELETE);
      setState(1692);
      {
        auto childCtxHolder = ctx->EnterDeleteItemList();
        deleteItemList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* deleteItemList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 176, GQLParser::RuleDeleteItemList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1694);
      {
        auto childCtxHolder = ctx->EnterDeleteItem();
        deleteItem(get_raw_pointer(childCtxHolder));
      }
      setState(1699);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(1695);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(1696);
        {
          auto childCtxHolder = ctx->EnterDeleteItem();
          deleteItem(get_raw_pointer(childCtxHolder));
        }
        setState(1701);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* deleteItem(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 178, GQLParser::RuleDeleteItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1702);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* callDataModifyingProcedureStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 180, GQLParser::RuleCallDataModifyingProcedureStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1704);
      {
        auto childCtxHolder = ctx->EnterCallProcedureStatement();
        callProcedureStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* compositeQueryStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 182, GQLParser::RuleCompositeQueryStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1706);
      {
        auto childCtxHolder = ctx->EnterCompositeQueryExpression();
        compositeQueryExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }


  template<typename ContextT>
  antlr4::ParserRuleContext* compositeQueryExpression(ContextT* ctx) {
     return compositeQueryExpression(0, ctx);
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* compositeQueryExpression(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, parentState);
    antlr4::ParserRuleContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 184;
    enterRecursionRule(_localctx, 184, GQLParser::RuleCompositeQueryExpression, precedence);

      

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(1709);
      {
        auto childCtxHolder = ctx->EnterCompositeQueryPrimary();
        compositeQueryPrimary(get_raw_pointer(childCtxHolder));
      }
      _ctx->stop = _input->LT(-1);
      setState(1717);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleCompositeQueryExpression);
          ctx->PushCompositeQueryExpression();
          setState(1711);

          if (!(precpred(_ctx, 2))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(1712);
          {
            auto childCtxHolder = ctx->EnterQueryConjunction();
            queryConjunction(get_raw_pointer(childCtxHolder));
          }
          setState(1713);
          {
            auto childCtxHolder = ctx->EnterCompositeQueryPrimary();
            compositeQueryPrimary(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(1719);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* queryConjunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 186, GQLParser::RuleQueryConjunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1722);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::EXCEPT:
        case GQLParser::INTERSECT:
        case GQLParser::UNION: {
          enterOuterAlt(_localctx, 1);
          setState(1720);
          {
            auto childCtxHolder = ctx->EnterSetOperator();
            setOperator(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::OTHERWISE: {
          enterOuterAlt(_localctx, 2);
          setState(1721);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::OTHERWISE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::OTHERWISE);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* setOperator(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 188, GQLParser::RuleSetOperator);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1736);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::UNION: {
          enterOuterAlt(_localctx, 1);
          setState(1724);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UNION) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UNION);
          setState(1726);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::ALL

          || _la == GQLParser::DISTINCT) {
            setState(1725);
            {
              auto childCtxHolder = ctx->EnterSetQuantifier();
              setQuantifier(get_raw_pointer(childCtxHolder));
            }
          }
          break;
        }

        case GQLParser::EXCEPT: {
          enterOuterAlt(_localctx, 2);
          setState(1728);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::EXCEPT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::EXCEPT);
          setState(1730);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::ALL

          || _la == GQLParser::DISTINCT) {
            setState(1729);
            {
              auto childCtxHolder = ctx->EnterSetQuantifier();
              setQuantifier(get_raw_pointer(childCtxHolder));
            }
          }
          break;
        }

        case GQLParser::INTERSECT: {
          enterOuterAlt(_localctx, 3);
          setState(1732);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTERSECT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTERSECT);
          setState(1734);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::ALL

          || _la == GQLParser::DISTINCT) {
            setState(1733);
            {
              auto childCtxHolder = ctx->EnterSetQuantifier();
              setQuantifier(get_raw_pointer(childCtxHolder));
            }
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* compositeQueryPrimary(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 190, GQLParser::RuleCompositeQueryPrimary);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1738);
      {
        auto childCtxHolder = ctx->EnterLinearQueryStatement();
        linearQueryStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* linearQueryStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 192, GQLParser::RuleLinearQueryStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1742);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::SELECT:
        case GQLParser::USE: {
          enterOuterAlt(_localctx, 1);
          setState(1740);
          {
            auto childCtxHolder = ctx->EnterFocusedLinearQueryStatement();
            focusedLinearQueryStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CALL:
        case GQLParser::FILTER:
        case GQLParser::FINISH:
        case GQLParser::FOR:
        case GQLParser::LET:
        case GQLParser::LIMIT:
        case GQLParser::MATCH:
        case GQLParser::OFFSET:
        case GQLParser::OPTIONAL:
        case GQLParser::ORDER:
        case GQLParser::RETURN:
        case GQLParser::SKIP_RESERVED_WORD:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(1741);
          {
            auto childCtxHolder = ctx->EnterAmbientLinearQueryStatement();
            ambientLinearQueryStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* focusedLinearQueryStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 194, GQLParser::RuleFocusedLinearQueryStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      setState(1754);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1747);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx);
        while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1744);
            {
              auto childCtxHolder = ctx->EnterFocusedLinearQueryStatementPart();
              focusedLinearQueryStatementPart(get_raw_pointer(childCtxHolder));
            } 
          }
          setState(1749);
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx);
        }
        setState(1750);
        {
          auto childCtxHolder = ctx->EnterFocusedLinearQueryAndPrimitiveResultStatementPart();
          focusedLinearQueryAndPrimitiveResultStatementPart(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1751);
        {
          auto childCtxHolder = ctx->EnterFocusedPrimitiveResultStatement();
          focusedPrimitiveResultStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1752);
        {
          auto childCtxHolder = ctx->EnterFocusedNestedQuerySpecification();
          focusedNestedQuerySpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(1753);
        {
          auto childCtxHolder = ctx->EnterSelectStatement();
          selectStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* focusedLinearQueryStatementPart(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 196, GQLParser::RuleFocusedLinearQueryStatementPart);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1756);
      {
        auto childCtxHolder = ctx->EnterUseGraphClause();
        useGraphClause(get_raw_pointer(childCtxHolder));
      }
      setState(1757);
      {
        auto childCtxHolder = ctx->EnterSimpleLinearQueryStatement();
        simpleLinearQueryStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* focusedLinearQueryAndPrimitiveResultStatementPart(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 198, GQLParser::RuleFocusedLinearQueryAndPrimitiveResultStatementPart);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1759);
      {
        auto childCtxHolder = ctx->EnterUseGraphClause();
        useGraphClause(get_raw_pointer(childCtxHolder));
      }
      setState(1760);
      {
        auto childCtxHolder = ctx->EnterSimpleLinearQueryStatement();
        simpleLinearQueryStatement(get_raw_pointer(childCtxHolder));
      }
      setState(1761);
      {
        auto childCtxHolder = ctx->EnterPrimitiveResultStatement();
        primitiveResultStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* focusedPrimitiveResultStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 200, GQLParser::RuleFocusedPrimitiveResultStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1763);
      {
        auto childCtxHolder = ctx->EnterUseGraphClause();
        useGraphClause(get_raw_pointer(childCtxHolder));
      }
      setState(1764);
      {
        auto childCtxHolder = ctx->EnterPrimitiveResultStatement();
        primitiveResultStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* focusedNestedQuerySpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 202, GQLParser::RuleFocusedNestedQuerySpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1766);
      {
        auto childCtxHolder = ctx->EnterUseGraphClause();
        useGraphClause(get_raw_pointer(childCtxHolder));
      }
      setState(1767);
      {
        auto childCtxHolder = ctx->EnterNestedQuerySpecification();
        nestedQuerySpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* ambientLinearQueryStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 204, GQLParser::RuleAmbientLinearQueryStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1774);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CALL:
        case GQLParser::FILTER:
        case GQLParser::FINISH:
        case GQLParser::FOR:
        case GQLParser::LET:
        case GQLParser::LIMIT:
        case GQLParser::MATCH:
        case GQLParser::OFFSET:
        case GQLParser::OPTIONAL:
        case GQLParser::ORDER:
        case GQLParser::RETURN:
        case GQLParser::SKIP_RESERVED_WORD: {
          enterOuterAlt(_localctx, 1);
          setState(1770);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::CALL || ((((_la - 91) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 91)) & 4506348406440449) != 0) || ((((_la - 159) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 159)) & 68719476747) != 0)) {
            setState(1769);
            {
              auto childCtxHolder = ctx->EnterSimpleLinearQueryStatement();
              simpleLinearQueryStatement(get_raw_pointer(childCtxHolder));
            }
          }
          setState(1772);
          {
            auto childCtxHolder = ctx->EnterPrimitiveResultStatement();
            primitiveResultStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(1773);
          {
            auto childCtxHolder = ctx->EnterNestedQuerySpecification();
            nestedQuerySpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simpleLinearQueryStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 206, GQLParser::RuleSimpleLinearQueryStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1777); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1776);
        {
          auto childCtxHolder = ctx->EnterSimpleQueryStatement();
          simpleQueryStatement(get_raw_pointer(childCtxHolder));
        }
        setState(1779); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == GQLParser::CALL || ((((_la - 91) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 91)) & 4506348406440449) != 0) || ((((_la - 159) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 159)) & 68719476747) != 0));
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simpleQueryStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 208, GQLParser::RuleSimpleQueryStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1783);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1781);
        {
          auto childCtxHolder = ctx->EnterPrimitiveQueryStatement();
          primitiveQueryStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1782);
        {
          auto childCtxHolder = ctx->EnterCallQueryStatement();
          callQueryStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* primitiveQueryStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 210, GQLParser::RulePrimitiveQueryStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1790);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::MATCH:
        case GQLParser::OPTIONAL: {
          enterOuterAlt(_localctx, 1);
          setState(1785);
          {
            auto childCtxHolder = ctx->EnterMatchStatement();
            matchStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LET: {
          enterOuterAlt(_localctx, 2);
          setState(1786);
          {
            auto childCtxHolder = ctx->EnterLetStatement();
            letStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::FOR: {
          enterOuterAlt(_localctx, 3);
          setState(1787);
          {
            auto childCtxHolder = ctx->EnterForStatement();
            forStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::FILTER: {
          enterOuterAlt(_localctx, 4);
          setState(1788);
          {
            auto childCtxHolder = ctx->EnterFilterStatement();
            filterStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LIMIT:
        case GQLParser::OFFSET:
        case GQLParser::ORDER:
        case GQLParser::SKIP_RESERVED_WORD: {
          enterOuterAlt(_localctx, 5);
          setState(1789);
          {
            auto childCtxHolder = ctx->EnterOrderByAndPageStatement();
            orderByAndPageStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* matchStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 212, GQLParser::RuleMatchStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1794);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::MATCH: {
          enterOuterAlt(_localctx, 1);
          setState(1792);
          {
            auto childCtxHolder = ctx->EnterSimpleMatchStatement();
            simpleMatchStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::OPTIONAL: {
          enterOuterAlt(_localctx, 2);
          setState(1793);
          {
            auto childCtxHolder = ctx->EnterOptionalMatchStatement();
            optionalMatchStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simpleMatchStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 214, GQLParser::RuleSimpleMatchStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1796);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MATCH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MATCH);
      setState(1797);
      {
        auto childCtxHolder = ctx->EnterGraphPatternBindingTable();
        graphPatternBindingTable(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* optionalMatchStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 216, GQLParser::RuleOptionalMatchStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1799);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::OPTIONAL) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::OPTIONAL);
      setState(1800);
      {
        auto childCtxHolder = ctx->EnterOptionalOperand();
        optionalOperand(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* optionalOperand(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 218, GQLParser::RuleOptionalOperand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1811);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::MATCH: {
          enterOuterAlt(_localctx, 1);
          setState(1802);
          {
            auto childCtxHolder = ctx->EnterSimpleMatchStatement();
            simpleMatchStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(1803);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_BRACE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_BRACE);
          setState(1804);
          {
            auto childCtxHolder = ctx->EnterMatchStatementBlock();
            matchStatementBlock(get_raw_pointer(childCtxHolder));
          }
          setState(1805);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_BRACE);
          break;
        }

        case GQLParser::LEFT_PAREN: {
          enterOuterAlt(_localctx, 3);
          setState(1807);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(1808);
          {
            auto childCtxHolder = ctx->EnterMatchStatementBlock();
            matchStatementBlock(get_raw_pointer(childCtxHolder));
          }
          setState(1809);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* matchStatementBlock(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 220, GQLParser::RuleMatchStatementBlock);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1814); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1813);
        {
          auto childCtxHolder = ctx->EnterMatchStatement();
          matchStatement(get_raw_pointer(childCtxHolder));
        }
        setState(1816); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == GQLParser::MATCH

      || _la == GQLParser::OPTIONAL);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* callQueryStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 222, GQLParser::RuleCallQueryStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1818);
      {
        auto childCtxHolder = ctx->EnterCallProcedureStatement();
        callProcedureStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* filterStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 224, GQLParser::RuleFilterStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1820);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::FILTER) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::FILTER);
      setState(1823);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::WHERE: {
          setState(1821);
          {
            auto childCtxHolder = ctx->EnterWhereClause();
            whereClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BOOLEAN_LITERAL:
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::BYTE_STRING_LITERAL:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER:
        case GQLParser::ABS:
        case GQLParser::ACOS:
        case GQLParser::ALL_DIFFERENT:
        case GQLParser::ARRAY:
        case GQLParser::ASIN:
        case GQLParser::ATAN:
        case GQLParser::AVG:
        case GQLParser::BTRIM:
        case GQLParser::BYTE_LENGTH:
        case GQLParser::CARDINALITY:
        case GQLParser::CASE:
        case GQLParser::CAST:
        case GQLParser::CEIL:
        case GQLParser::CEILING:
        case GQLParser::CHAR_LENGTH:
        case GQLParser::CHARACTER_LENGTH:
        case GQLParser::COALESCE:
        case GQLParser::COLLECT_LIST:
        case GQLParser::COS:
        case GQLParser::COSH:
        case GQLParser::COT:
        case GQLParser::COUNT:
        case GQLParser::CURRENT_DATE:
        case GQLParser::CURRENT_TIME:
        case GQLParser::CURRENT_TIMESTAMP:
        case GQLParser::DATE:
        case GQLParser::DATETIME:
        case GQLParser::DEGREES:
        case GQLParser::DURATION:
        case GQLParser::DURATION_BETWEEN:
        case GQLParser::ELEMENT_ID:
        case GQLParser::EXISTS:
        case GQLParser::EXP:
        case GQLParser::FLOOR:
        case GQLParser::GROUP:
        case GQLParser::LEFT:
        case GQLParser::LET:
        case GQLParser::LIST:
        case GQLParser::LN:
        case GQLParser::LOCAL_DATETIME:
        case GQLParser::LOCAL_TIME:
        case GQLParser::LOCAL_TIMESTAMP:
        case GQLParser::LOG_KW:
        case GQLParser::LOG10:
        case GQLParser::LOWER:
        case GQLParser::LTRIM:
        case GQLParser::MAX:
        case GQLParser::MIN:
        case GQLParser::MOD:
        case GQLParser::NORMALIZE:
        case GQLParser::NOT:
        case GQLParser::NULL_KW:
        case GQLParser::NULLIF:
        case GQLParser::OCTET_LENGTH:
        case GQLParser::PATH:
        case GQLParser::PATH_LENGTH:
        case GQLParser::PERCENTILE_CONT:
        case GQLParser::PERCENTILE_DISC:
        case GQLParser::POWER:
        case GQLParser::PROPERTY_EXISTS:
        case GQLParser::RADIANS:
        case GQLParser::RECORD:
        case GQLParser::RIGHT:
        case GQLParser::RTRIM:
        case GQLParser::SAME:
        case GQLParser::SESSION_USER:
        case GQLParser::SIN:
        case GQLParser::SINH:
        case GQLParser::SIZE:
        case GQLParser::SQRT:
        case GQLParser::STDDEV_POP:
        case GQLParser::STDDEV_SAMP:
        case GQLParser::SUM:
        case GQLParser::TAN:
        case GQLParser::TANH:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::TRIM:
        case GQLParser::UPPER:
        case GQLParser::VALUE:
        case GQLParser::ZONED_DATETIME:
        case GQLParser::ZONED_TIME:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER:
        case GQLParser::GENERAL_PARAMETER_REFERENCE:
        case GQLParser::LEFT_BRACE:
        case GQLParser::LEFT_BRACKET:
        case GQLParser::LEFT_PAREN:
        case GQLParser::MINUS_SIGN:
        case GQLParser::PLUS_SIGN: {
          setState(1822);
          {
            auto childCtxHolder = ctx->EnterSearchCondition();
            searchCondition(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* letStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 226, GQLParser::RuleLetStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1825);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LET);
      setState(1826);
      {
        auto childCtxHolder = ctx->EnterLetVariableDefinitionList();
        letVariableDefinitionList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* letVariableDefinitionList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 228, GQLParser::RuleLetVariableDefinitionList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1828);
      {
        auto childCtxHolder = ctx->EnterLetVariableDefinition();
        letVariableDefinition(get_raw_pointer(childCtxHolder));
      }
      setState(1833);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(1829);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(1830);
        {
          auto childCtxHolder = ctx->EnterLetVariableDefinition();
          letVariableDefinition(get_raw_pointer(childCtxHolder));
        }
        setState(1835);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* letVariableDefinition(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 230, GQLParser::RuleLetVariableDefinition);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1841);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::VALUE: {
          enterOuterAlt(_localctx, 1);
          setState(1836);
          {
            auto childCtxHolder = ctx->EnterValueVariableDefinition();
            valueVariableDefinition(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 2);
          setState(1837);
          {
            auto childCtxHolder = ctx->EnterBindingVariable();
            bindingVariable(get_raw_pointer(childCtxHolder));
          }
          setState(1838);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::EQUALS_OPERATOR);
          setState(1839);
          {
            auto childCtxHolder = ctx->EnterValueExpression();
            valueExpression(0, get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* forStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 232, GQLParser::RuleForStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1843);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::FOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::FOR);
      setState(1844);
      {
        auto childCtxHolder = ctx->EnterForItem();
        forItem(get_raw_pointer(childCtxHolder));
      }
      setState(1846);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::WITH) {
        setState(1845);
        {
          auto childCtxHolder = ctx->EnterForOrdinalityOrOffset();
          forOrdinalityOrOffset(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* forItem(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 234, GQLParser::RuleForItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1848);
      {
        auto childCtxHolder = ctx->EnterForItemAlias();
        forItemAlias(get_raw_pointer(childCtxHolder));
      }
      setState(1849);
      {
        auto childCtxHolder = ctx->EnterForItemSource();
        forItemSource(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* forItemAlias(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 236, GQLParser::RuleForItemAlias);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1851);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
      setState(1852);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* forItemSource(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 238, GQLParser::RuleForItemSource);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1854);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* forOrdinalityOrOffset(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 240, GQLParser::RuleForOrdinalityOrOffset);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1856);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::WITH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::WITH);
      setState(1857);
      _la = _input->LA(1);
      if (!(_la == GQLParser::OFFSET || _la == GQLParser::ORDINALITY)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(1858);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* orderByAndPageStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 242, GQLParser::RuleOrderByAndPageStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1872);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ORDER: {
          enterOuterAlt(_localctx, 1);
          setState(1860);
          {
            auto childCtxHolder = ctx->EnterOrderByClause();
            orderByClause(get_raw_pointer(childCtxHolder));
          }
          setState(1862);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx)) {
          case 1: {
            setState(1861);
            {
              auto childCtxHolder = ctx->EnterOffsetClause();
              offsetClause(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          setState(1865);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx)) {
          case 1: {
            setState(1864);
            {
              auto childCtxHolder = ctx->EnterLimitClause();
              limitClause(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::OFFSET:
        case GQLParser::SKIP_RESERVED_WORD: {
          enterOuterAlt(_localctx, 2);
          setState(1867);
          {
            auto childCtxHolder = ctx->EnterOffsetClause();
            offsetClause(get_raw_pointer(childCtxHolder));
          }
          setState(1869);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
          case 1: {
            setState(1868);
            {
              auto childCtxHolder = ctx->EnterLimitClause();
              limitClause(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::LIMIT: {
          enterOuterAlt(_localctx, 3);
          setState(1871);
          {
            auto childCtxHolder = ctx->EnterLimitClause();
            limitClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* primitiveResultStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 244, GQLParser::RulePrimitiveResultStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1879);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::RETURN: {
          enterOuterAlt(_localctx, 1);
          setState(1874);
          {
            auto childCtxHolder = ctx->EnterReturnStatement();
            returnStatement(get_raw_pointer(childCtxHolder));
          }
          setState(1876);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
          case 1: {
            setState(1875);
            {
              auto childCtxHolder = ctx->EnterOrderByAndPageStatement();
              orderByAndPageStatement(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::FINISH: {
          enterOuterAlt(_localctx, 2);
          setState(1878);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::FINISH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::FINISH);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* returnStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 246, GQLParser::RuleReturnStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1881);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RETURN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RETURN);
      setState(1882);
      {
        auto childCtxHolder = ctx->EnterReturnStatementBody();
        returnStatementBody(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* returnStatementBody(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 248, GQLParser::RuleReturnStatementBody);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1896);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1885);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::ALL

        || _la == GQLParser::DISTINCT) {
          setState(1884);
          {
            auto childCtxHolder = ctx->EnterSetQuantifier();
            setQuantifier(get_raw_pointer(childCtxHolder));
          }
        }
        setState(1889);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case GQLParser::ASTERISK: {
            setState(1887);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::ASTERISK) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::ASTERISK);
            break;
          }

          case GQLParser::BOOLEAN_LITERAL:
          case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
          case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
          case GQLParser::BYTE_STRING_LITERAL:
          case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_INTEGER:
          case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
          case GQLParser::UNSIGNED_OCTAL_INTEGER:
          case GQLParser::UNSIGNED_BINARY_INTEGER:
          case GQLParser::ABS:
          case GQLParser::ACOS:
          case GQLParser::ALL_DIFFERENT:
          case GQLParser::ARRAY:
          case GQLParser::ASIN:
          case GQLParser::ATAN:
          case GQLParser::AVG:
          case GQLParser::BTRIM:
          case GQLParser::BYTE_LENGTH:
          case GQLParser::CARDINALITY:
          case GQLParser::CASE:
          case GQLParser::CAST:
          case GQLParser::CEIL:
          case GQLParser::CEILING:
          case GQLParser::CHAR_LENGTH:
          case GQLParser::CHARACTER_LENGTH:
          case GQLParser::COALESCE:
          case GQLParser::COLLECT_LIST:
          case GQLParser::COS:
          case GQLParser::COSH:
          case GQLParser::COT:
          case GQLParser::COUNT:
          case GQLParser::CURRENT_DATE:
          case GQLParser::CURRENT_TIME:
          case GQLParser::CURRENT_TIMESTAMP:
          case GQLParser::DATE:
          case GQLParser::DATETIME:
          case GQLParser::DEGREES:
          case GQLParser::DURATION:
          case GQLParser::DURATION_BETWEEN:
          case GQLParser::ELEMENT_ID:
          case GQLParser::EXISTS:
          case GQLParser::EXP:
          case GQLParser::FLOOR:
          case GQLParser::GROUP:
          case GQLParser::LEFT:
          case GQLParser::LET:
          case GQLParser::LIST:
          case GQLParser::LN:
          case GQLParser::LOCAL_DATETIME:
          case GQLParser::LOCAL_TIME:
          case GQLParser::LOCAL_TIMESTAMP:
          case GQLParser::LOG_KW:
          case GQLParser::LOG10:
          case GQLParser::LOWER:
          case GQLParser::LTRIM:
          case GQLParser::MAX:
          case GQLParser::MIN:
          case GQLParser::MOD:
          case GQLParser::NORMALIZE:
          case GQLParser::NOT:
          case GQLParser::NULL_KW:
          case GQLParser::NULLIF:
          case GQLParser::OCTET_LENGTH:
          case GQLParser::PATH:
          case GQLParser::PATH_LENGTH:
          case GQLParser::PERCENTILE_CONT:
          case GQLParser::PERCENTILE_DISC:
          case GQLParser::POWER:
          case GQLParser::PROPERTY_EXISTS:
          case GQLParser::RADIANS:
          case GQLParser::RECORD:
          case GQLParser::RIGHT:
          case GQLParser::RTRIM:
          case GQLParser::SAME:
          case GQLParser::SESSION_USER:
          case GQLParser::SIN:
          case GQLParser::SINH:
          case GQLParser::SIZE:
          case GQLParser::SQRT:
          case GQLParser::STDDEV_POP:
          case GQLParser::STDDEV_SAMP:
          case GQLParser::SUM:
          case GQLParser::TAN:
          case GQLParser::TANH:
          case GQLParser::TIME:
          case GQLParser::TIMESTAMP:
          case GQLParser::TRIM:
          case GQLParser::UPPER:
          case GQLParser::VALUE:
          case GQLParser::ZONED_DATETIME:
          case GQLParser::ZONED_TIME:
          case GQLParser::ACYCLIC:
          case GQLParser::BINDING:
          case GQLParser::BINDINGS:
          case GQLParser::CONNECTING:
          case GQLParser::DESTINATION:
          case GQLParser::DIFFERENT:
          case GQLParser::DIRECTED:
          case GQLParser::EDGE:
          case GQLParser::EDGES:
          case GQLParser::ELEMENT:
          case GQLParser::ELEMENTS:
          case GQLParser::FIRST:
          case GQLParser::GRAPH:
          case GQLParser::GROUPS:
          case GQLParser::KEEP:
          case GQLParser::LABEL:
          case GQLParser::LABELED:
          case GQLParser::LABELS:
          case GQLParser::LAST:
          case GQLParser::NFC:
          case GQLParser::NFD:
          case GQLParser::NFKC:
          case GQLParser::NFKD:
          case GQLParser::NO:
          case GQLParser::NODE:
          case GQLParser::NORMALIZED:
          case GQLParser::ONLY:
          case GQLParser::ORDINALITY:
          case GQLParser::PROPERTY:
          case GQLParser::READ:
          case GQLParser::RELATIONSHIP:
          case GQLParser::RELATIONSHIPS:
          case GQLParser::REPEATABLE:
          case GQLParser::SHORTEST:
          case GQLParser::SIMPLE:
          case GQLParser::SOURCE:
          case GQLParser::TABLE:
          case GQLParser::TEMP:
          case GQLParser::TO:
          case GQLParser::TRAIL:
          case GQLParser::TRANSACTION:
          case GQLParser::UNDIRECTED:
          case GQLParser::VERTEX:
          case GQLParser::WALK:
          case GQLParser::WITHOUT:
          case GQLParser::WRITE:
          case GQLParser::ZONE:
          case GQLParser::REGULAR_IDENTIFIER:
          case GQLParser::GENERAL_PARAMETER_REFERENCE:
          case GQLParser::LEFT_BRACE:
          case GQLParser::LEFT_BRACKET:
          case GQLParser::LEFT_PAREN:
          case GQLParser::MINUS_SIGN:
          case GQLParser::PLUS_SIGN: {
            setState(1888);
            {
              auto childCtxHolder = ctx->EnterReturnItemList();
              returnItemList(get_raw_pointer(childCtxHolder));
            }
            break;
          }

        default:
          throw antlr4::NoViableAltException(this);
        }
        setState(1892);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx)) {
        case 1: {
          setState(1891);
          {
            auto childCtxHolder = ctx->EnterGroupByClause();
            groupByClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1894);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NO) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NO);
        setState(1895);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::BINDINGS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::BINDINGS);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* returnItemList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 250, GQLParser::RuleReturnItemList);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(1898);
      {
        auto childCtxHolder = ctx->EnterReturnItem();
        returnItem(get_raw_pointer(childCtxHolder));
      }
      setState(1903);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1899);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COMMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COMMA);
          setState(1900);
          {
            auto childCtxHolder = ctx->EnterReturnItem();
            returnItem(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(1905);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* returnItem(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 252, GQLParser::RuleReturnItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1906);
      {
        auto childCtxHolder = ctx->EnterAggregatingValueExpression();
        aggregatingValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(1908);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {
      case 1: {
        setState(1907);
        {
          auto childCtxHolder = ctx->EnterReturnItemAlias();
          returnItemAlias(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* returnItemAlias(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 254, GQLParser::RuleReturnItemAlias);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1910);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::AS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::AS);
      setState(1911);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* selectStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 256, GQLParser::RuleSelectStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1913);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SELECT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SELECT);
      setState(1915);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ALL

      || _la == GQLParser::DISTINCT) {
        setState(1914);
        {
          auto childCtxHolder = ctx->EnterSetQuantifier();
          setQuantifier(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1919);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ASTERISK: {
          setState(1917);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ASTERISK) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ASTERISK);
          break;
        }

        case GQLParser::BOOLEAN_LITERAL:
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::BYTE_STRING_LITERAL:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER:
        case GQLParser::ABS:
        case GQLParser::ACOS:
        case GQLParser::ALL_DIFFERENT:
        case GQLParser::ARRAY:
        case GQLParser::ASIN:
        case GQLParser::ATAN:
        case GQLParser::AVG:
        case GQLParser::BTRIM:
        case GQLParser::BYTE_LENGTH:
        case GQLParser::CARDINALITY:
        case GQLParser::CASE:
        case GQLParser::CAST:
        case GQLParser::CEIL:
        case GQLParser::CEILING:
        case GQLParser::CHAR_LENGTH:
        case GQLParser::CHARACTER_LENGTH:
        case GQLParser::COALESCE:
        case GQLParser::COLLECT_LIST:
        case GQLParser::COS:
        case GQLParser::COSH:
        case GQLParser::COT:
        case GQLParser::COUNT:
        case GQLParser::CURRENT_DATE:
        case GQLParser::CURRENT_TIME:
        case GQLParser::CURRENT_TIMESTAMP:
        case GQLParser::DATE:
        case GQLParser::DATETIME:
        case GQLParser::DEGREES:
        case GQLParser::DURATION:
        case GQLParser::DURATION_BETWEEN:
        case GQLParser::ELEMENT_ID:
        case GQLParser::EXISTS:
        case GQLParser::EXP:
        case GQLParser::FLOOR:
        case GQLParser::GROUP:
        case GQLParser::LEFT:
        case GQLParser::LET:
        case GQLParser::LIST:
        case GQLParser::LN:
        case GQLParser::LOCAL_DATETIME:
        case GQLParser::LOCAL_TIME:
        case GQLParser::LOCAL_TIMESTAMP:
        case GQLParser::LOG_KW:
        case GQLParser::LOG10:
        case GQLParser::LOWER:
        case GQLParser::LTRIM:
        case GQLParser::MAX:
        case GQLParser::MIN:
        case GQLParser::MOD:
        case GQLParser::NORMALIZE:
        case GQLParser::NOT:
        case GQLParser::NULL_KW:
        case GQLParser::NULLIF:
        case GQLParser::OCTET_LENGTH:
        case GQLParser::PATH:
        case GQLParser::PATH_LENGTH:
        case GQLParser::PERCENTILE_CONT:
        case GQLParser::PERCENTILE_DISC:
        case GQLParser::POWER:
        case GQLParser::PROPERTY_EXISTS:
        case GQLParser::RADIANS:
        case GQLParser::RECORD:
        case GQLParser::RIGHT:
        case GQLParser::RTRIM:
        case GQLParser::SAME:
        case GQLParser::SESSION_USER:
        case GQLParser::SIN:
        case GQLParser::SINH:
        case GQLParser::SIZE:
        case GQLParser::SQRT:
        case GQLParser::STDDEV_POP:
        case GQLParser::STDDEV_SAMP:
        case GQLParser::SUM:
        case GQLParser::TAN:
        case GQLParser::TANH:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::TRIM:
        case GQLParser::UPPER:
        case GQLParser::VALUE:
        case GQLParser::ZONED_DATETIME:
        case GQLParser::ZONED_TIME:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER:
        case GQLParser::GENERAL_PARAMETER_REFERENCE:
        case GQLParser::LEFT_BRACE:
        case GQLParser::LEFT_BRACKET:
        case GQLParser::LEFT_PAREN:
        case GQLParser::MINUS_SIGN:
        case GQLParser::PLUS_SIGN: {
          setState(1918);
          {
            auto childCtxHolder = ctx->EnterSelectItemList();
            selectItemList(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
      setState(1940);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx)) {
      case 1: {
        setState(1921);
        {
          auto childCtxHolder = ctx->EnterSelectStatementBody();
          selectStatementBody(get_raw_pointer(childCtxHolder));
        }
        setState(1923);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 125, _ctx)) {
        case 1: {
          setState(1922);
          {
            auto childCtxHolder = ctx->EnterWhereClause();
            whereClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        setState(1926);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
        case 1: {
          setState(1925);
          {
            auto childCtxHolder = ctx->EnterGroupByClause();
            groupByClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        setState(1929);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx)) {
        case 1: {
          setState(1928);
          {
            auto childCtxHolder = ctx->EnterHavingClause();
            havingClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        setState(1932);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx)) {
        case 1: {
          setState(1931);
          {
            auto childCtxHolder = ctx->EnterOrderByClause();
            orderByClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        setState(1935);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx)) {
        case 1: {
          setState(1934);
          {
            auto childCtxHolder = ctx->EnterOffsetClause();
            offsetClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        setState(1938);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx)) {
        case 1: {
          setState(1937);
          {
            auto childCtxHolder = ctx->EnterLimitClause();
            limitClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* selectItemList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 258, GQLParser::RuleSelectItemList);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(1942);
      {
        auto childCtxHolder = ctx->EnterSelectItem();
        selectItem(get_raw_pointer(childCtxHolder));
      }
      setState(1947);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1943);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COMMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COMMA);
          setState(1944);
          {
            auto childCtxHolder = ctx->EnterSelectItem();
            selectItem(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(1949);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* selectItem(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 260, GQLParser::RuleSelectItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1950);
      {
        auto childCtxHolder = ctx->EnterAggregatingValueExpression();
        aggregatingValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(1952);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx)) {
      case 1: {
        setState(1951);
        {
          auto childCtxHolder = ctx->EnterSelectItemAlias();
          selectItemAlias(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* selectItemAlias(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 262, GQLParser::RuleSelectItemAlias);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1954);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::AS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::AS);
      setState(1955);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* havingClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 264, GQLParser::RuleHavingClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1957);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::HAVING) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::HAVING);
      setState(1958);
      {
        auto childCtxHolder = ctx->EnterSearchCondition();
        searchCondition(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* selectStatementBody(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 266, GQLParser::RuleSelectStatementBody);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1960);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::FROM) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::FROM);
      setState(1963);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx)) {
      case 1: {
        setState(1961);
        {
          auto childCtxHolder = ctx->EnterSelectGraphMatchList();
          selectGraphMatchList(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        setState(1962);
        {
          auto childCtxHolder = ctx->EnterSelectQuerySpecification();
          selectQuerySpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* selectGraphMatchList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 268, GQLParser::RuleSelectGraphMatchList);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(1965);
      {
        auto childCtxHolder = ctx->EnterSelectGraphMatch();
        selectGraphMatch(get_raw_pointer(childCtxHolder));
      }
      setState(1970);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 135, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1966);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COMMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COMMA);
          setState(1967);
          {
            auto childCtxHolder = ctx->EnterSelectGraphMatch();
            selectGraphMatch(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(1972);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 135, _ctx);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* selectGraphMatch(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 270, GQLParser::RuleSelectGraphMatch);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1973);
      {
        auto childCtxHolder = ctx->EnterGraphExpression();
        graphExpression(get_raw_pointer(childCtxHolder));
      }
      setState(1974);
      {
        auto childCtxHolder = ctx->EnterMatchStatement();
        matchStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* selectQuerySpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 272, GQLParser::RuleSelectQuerySpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1980);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1976);
        {
          auto childCtxHolder = ctx->EnterNestedQuerySpecification();
          nestedQuerySpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1977);
        {
          auto childCtxHolder = ctx->EnterGraphExpression();
          graphExpression(get_raw_pointer(childCtxHolder));
        }
        setState(1978);
        {
          auto childCtxHolder = ctx->EnterNestedQuerySpecification();
          nestedQuerySpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* callProcedureStatement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 274, GQLParser::RuleCallProcedureStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1983);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::OPTIONAL) {
        setState(1982);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::OPTIONAL) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::OPTIONAL);
      }
      setState(1985);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CALL) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CALL);
      setState(1986);
      {
        auto childCtxHolder = ctx->EnterProcedureCall();
        procedureCall(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* procedureCall(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 276, GQLParser::RuleProcedureCall);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1990);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LEFT_BRACE:
        case GQLParser::LEFT_PAREN: {
          enterOuterAlt(_localctx, 1);
          setState(1988);
          {
            auto childCtxHolder = ctx->EnterInlineProcedureCall();
            inlineProcedureCall(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::CURRENT_SCHEMA:
        case GQLParser::HOME_SCHEMA:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER:
        case GQLParser::SUBSTITUTED_PARAMETER_REFERENCE:
        case GQLParser::DOUBLE_PERIOD:
        case GQLParser::PERIOD:
        case GQLParser::SOLIDUS: {
          enterOuterAlt(_localctx, 2);
          setState(1989);
          {
            auto childCtxHolder = ctx->EnterNamedProcedureCall();
            namedProcedureCall(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* inlineProcedureCall(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 278, GQLParser::RuleInlineProcedureCall);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1993);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::LEFT_PAREN) {
        setState(1992);
        {
          auto childCtxHolder = ctx->EnterVariableScopeClause();
          variableScopeClause(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1995);
      {
        auto childCtxHolder = ctx->EnterNestedProcedureSpecification();
        nestedProcedureSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* variableScopeClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 280, GQLParser::RuleVariableScopeClause);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1997);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(1999);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0)) {
        setState(1998);
        {
          auto childCtxHolder = ctx->EnterBindingVariableReferenceList();
          bindingVariableReferenceList(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2001);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* bindingVariableReferenceList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 282, GQLParser::RuleBindingVariableReferenceList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2003);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(2008);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(2004);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(2005);
        {
          auto childCtxHolder = ctx->EnterBindingVariableReference();
          bindingVariableReference(get_raw_pointer(childCtxHolder));
        }
        setState(2010);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* namedProcedureCall(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 284, GQLParser::RuleNamedProcedureCall);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2011);
      {
        auto childCtxHolder = ctx->EnterProcedureReference();
        procedureReference(get_raw_pointer(childCtxHolder));
      }
      setState(2012);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(2014);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8762849302180528028) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 309341980913) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 129)) & -8011702113698201677) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & 26393111092643) != 0) || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 1686650837008383) != 0) || ((((_la - 369) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 369)) & 151) != 0)) {
        setState(2013);
        {
          auto childCtxHolder = ctx->EnterProcedureArgumentList();
          procedureArgumentList(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2016);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
      setState(2018);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::YIELD) {
        setState(2017);
        {
          auto childCtxHolder = ctx->EnterYieldClause();
          yieldClause(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* procedureArgumentList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 286, GQLParser::RuleProcedureArgumentList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2020);
      {
        auto childCtxHolder = ctx->EnterProcedureArgument();
        procedureArgument(get_raw_pointer(childCtxHolder));
      }
      setState(2025);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(2021);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(2022);
        {
          auto childCtxHolder = ctx->EnterProcedureArgument();
          procedureArgument(get_raw_pointer(childCtxHolder));
        }
        setState(2027);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* procedureArgument(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 288, GQLParser::RuleProcedureArgument);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2028);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* atSchemaClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 290, GQLParser::RuleAtSchemaClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2030);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::AT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::AT);
      setState(2031);
      {
        auto childCtxHolder = ctx->EnterSchemaReference();
        schemaReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* useGraphClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 292, GQLParser::RuleUseGraphClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2033);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::USE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::USE);
      setState(2034);
      {
        auto childCtxHolder = ctx->EnterGraphExpression();
        graphExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphPatternBindingTable(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 294, GQLParser::RuleGraphPatternBindingTable);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2036);
      {
        auto childCtxHolder = ctx->EnterGraphPattern();
        graphPattern(get_raw_pointer(childCtxHolder));
      }
      setState(2038);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx)) {
      case 1: {
        setState(2037);
        {
          auto childCtxHolder = ctx->EnterGraphPatternYieldClause();
          graphPatternYieldClause(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphPatternYieldClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 296, GQLParser::RuleGraphPatternYieldClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2040);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::YIELD) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::YIELD);
      setState(2041);
      {
        auto childCtxHolder = ctx->EnterGraphPatternYieldItemList();
        graphPatternYieldItemList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphPatternYieldItemList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 298, GQLParser::RuleGraphPatternYieldItemList);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      setState(2053);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 147, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2043);
        {
          auto childCtxHolder = ctx->EnterGraphPatternYieldItem();
          graphPatternYieldItem(get_raw_pointer(childCtxHolder));
        }
        setState(2048);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx);
        while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2044);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::COMMA) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::COMMA);
            setState(2045);
            {
              auto childCtxHolder = ctx->EnterGraphPatternYieldItem();
              graphPatternYieldItem(get_raw_pointer(childCtxHolder));
            } 
          }
          setState(2050);
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx);
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2051);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NO) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NO);
        setState(2052);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::BINDINGS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::BINDINGS);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphPatternYieldItem(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 300, GQLParser::RuleGraphPatternYieldItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2055);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphPattern(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 302, GQLParser::RuleGraphPattern);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2058);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx)) {
      case 1: {
        setState(2057);
        {
          auto childCtxHolder = ctx->EnterMatchMode();
          matchMode(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2060);
      {
        auto childCtxHolder = ctx->EnterPathPatternList();
        pathPatternList(get_raw_pointer(childCtxHolder));
      }
      setState(2062);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx)) {
      case 1: {
        setState(2061);
        {
          auto childCtxHolder = ctx->EnterKeepClause();
          keepClause(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2065);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx)) {
      case 1: {
        setState(2064);
        {
          auto childCtxHolder = ctx->EnterGraphPatternWhereClause();
          graphPatternWhereClause(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* matchMode(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 304, GQLParser::RuleMatchMode);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2069);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::REPEATABLE: {
          enterOuterAlt(_localctx, 1);
          setState(2067);
          {
            auto childCtxHolder = ctx->EnterRepeatableElementsMatchMode();
            repeatableElementsMatchMode(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DIFFERENT: {
          enterOuterAlt(_localctx, 2);
          setState(2068);
          {
            auto childCtxHolder = ctx->EnterDifferentEdgesMatchMode();
            differentEdgesMatchMode(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* repeatableElementsMatchMode(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 306, GQLParser::RuleRepeatableElementsMatchMode);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2071);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::REPEATABLE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::REPEATABLE);
      setState(2072);
      {
        auto childCtxHolder = ctx->EnterElementBindingsOrElements();
        elementBindingsOrElements(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* differentEdgesMatchMode(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 308, GQLParser::RuleDifferentEdgesMatchMode);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2074);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DIFFERENT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DIFFERENT);
      setState(2075);
      {
        auto childCtxHolder = ctx->EnterEdgeBindingsOrEdges();
        edgeBindingsOrEdges(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* elementBindingsOrElements(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 310, GQLParser::RuleElementBindingsOrElements);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2082);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ELEMENT: {
          enterOuterAlt(_localctx, 1);
          setState(2077);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ELEMENT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ELEMENT);
          setState(2079);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx)) {
          case 1: {
            setState(2078);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::BINDINGS) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::BINDINGS);
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::ELEMENTS: {
          enterOuterAlt(_localctx, 2);
          setState(2081);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ELEMENTS) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ELEMENTS);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeBindingsOrEdges(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 312, GQLParser::RuleEdgeBindingsOrEdges);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2089);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::EDGE:
        case GQLParser::RELATIONSHIP: {
          enterOuterAlt(_localctx, 1);
          setState(2084);
          {
            auto childCtxHolder = ctx->EnterEdgeSynonym();
            edgeSynonym(get_raw_pointer(childCtxHolder));
          }
          setState(2086);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
          case 1: {
            setState(2085);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::BINDINGS) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::BINDINGS);
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::EDGES:
        case GQLParser::RELATIONSHIPS: {
          enterOuterAlt(_localctx, 2);
          setState(2088);
          {
            auto childCtxHolder = ctx->EnterEdgesSynonym();
            edgesSynonym(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathPatternList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 314, GQLParser::RulePathPatternList);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(2091);
      {
        auto childCtxHolder = ctx->EnterPathPattern();
        pathPattern(get_raw_pointer(childCtxHolder));
      }
      setState(2096);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2092);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COMMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COMMA);
          setState(2093);
          {
            auto childCtxHolder = ctx->EnterPathPattern();
            pathPattern(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(2098);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathPattern(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 316, GQLParser::RulePathPattern);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2100);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx)) {
      case 1: {
        setState(2099);
        {
          auto childCtxHolder = ctx->EnterPathVariableDeclaration();
          pathVariableDeclaration(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2103);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ALL

      || _la == GQLParser::ANY || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 18167711662081) != 0)) {
        setState(2102);
        {
          auto childCtxHolder = ctx->EnterPathPatternPrefix();
          pathPatternPrefix(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2105);
      {
        auto childCtxHolder = ctx->EnterPathPatternExpression();
        pathPatternExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathVariableDeclaration(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 318, GQLParser::RulePathVariableDeclaration);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2107);
      {
        auto childCtxHolder = ctx->EnterPathVariable();
        pathVariable(get_raw_pointer(childCtxHolder));
      }
      setState(2108);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EQUALS_OPERATOR);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* keepClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 320, GQLParser::RuleKeepClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2110);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::KEEP) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::KEEP);
      setState(2111);
      {
        auto childCtxHolder = ctx->EnterPathPatternPrefix();
        pathPatternPrefix(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphPatternWhereClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 322, GQLParser::RuleGraphPatternWhereClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2113);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::WHERE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::WHERE);
      setState(2114);
      {
        auto childCtxHolder = ctx->EnterSearchCondition();
        searchCondition(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* insertGraphPattern(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 324, GQLParser::RuleInsertGraphPattern);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2116);
      {
        auto childCtxHolder = ctx->EnterInsertPathPatternList();
        insertPathPatternList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* insertPathPatternList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 326, GQLParser::RuleInsertPathPatternList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2118);
      {
        auto childCtxHolder = ctx->EnterInsertPathPattern();
        insertPathPattern(get_raw_pointer(childCtxHolder));
      }
      setState(2123);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(2119);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(2120);
        {
          auto childCtxHolder = ctx->EnterInsertPathPattern();
          insertPathPattern(get_raw_pointer(childCtxHolder));
        }
        setState(2125);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* insertPathPattern(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 328, GQLParser::RuleInsertPathPattern);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2126);
      {
        auto childCtxHolder = ctx->EnterInsertNodePattern();
        insertNodePattern(get_raw_pointer(childCtxHolder));
      }
      setState(2132);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 338) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 338)) & 131137) != 0)) {
        setState(2127);
        {
          auto childCtxHolder = ctx->EnterInsertEdgePattern();
          insertEdgePattern(get_raw_pointer(childCtxHolder));
        }
        setState(2128);
        {
          auto childCtxHolder = ctx->EnterInsertNodePattern();
          insertNodePattern(get_raw_pointer(childCtxHolder));
        }
        setState(2134);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* insertNodePattern(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 330, GQLParser::RuleInsertNodePattern);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2135);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(2137);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IS || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0) || _la == GQLParser::COLON

      || _la == GQLParser::LEFT_BRACE) {
        setState(2136);
        {
          auto childCtxHolder = ctx->EnterInsertElementPatternFiller();
          insertElementPatternFiller(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2139);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* insertEdgePattern(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 332, GQLParser::RuleInsertEdgePattern);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2144);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LEFT_ARROW_BRACKET: {
          enterOuterAlt(_localctx, 1);
          setState(2141);
          {
            auto childCtxHolder = ctx->EnterInsertEdgePointingLeft();
            insertEdgePointingLeft(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::MINUS_LEFT_BRACKET: {
          enterOuterAlt(_localctx, 2);
          setState(2142);
          {
            auto childCtxHolder = ctx->EnterInsertEdgePointingRight();
            insertEdgePointingRight(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::TILDE_LEFT_BRACKET: {
          enterOuterAlt(_localctx, 3);
          setState(2143);
          {
            auto childCtxHolder = ctx->EnterInsertEdgeUndirected();
            insertEdgeUndirected(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* insertEdgePointingLeft(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 334, GQLParser::RuleInsertEdgePointingLeft);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2146);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ARROW_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ARROW_BRACKET);
      setState(2148);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IS || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0) || _la == GQLParser::COLON

      || _la == GQLParser::LEFT_BRACE) {
        setState(2147);
        {
          auto childCtxHolder = ctx->EnterInsertElementPatternFiller();
          insertElementPatternFiller(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2150);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_MINUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_MINUS);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* insertEdgePointingRight(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 336, GQLParser::RuleInsertEdgePointingRight);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2152);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MINUS_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MINUS_LEFT_BRACKET);
      setState(2154);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IS || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0) || _la == GQLParser::COLON

      || _la == GQLParser::LEFT_BRACE) {
        setState(2153);
        {
          auto childCtxHolder = ctx->EnterInsertElementPatternFiller();
          insertElementPatternFiller(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2156);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BRACKET_RIGHT_ARROW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BRACKET_RIGHT_ARROW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* insertEdgeUndirected(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 338, GQLParser::RuleInsertEdgeUndirected);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2158);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE_LEFT_BRACKET);
      setState(2160);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IS || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0) || _la == GQLParser::COLON

      || _la == GQLParser::LEFT_BRACE) {
        setState(2159);
        {
          auto childCtxHolder = ctx->EnterInsertElementPatternFiller();
          insertElementPatternFiller(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2162);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_TILDE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* insertElementPatternFiller(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 340, GQLParser::RuleInsertElementPatternFiller);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2172);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 168, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2164);
        {
          auto childCtxHolder = ctx->EnterElementVariableDeclaration();
          elementVariableDeclaration(get_raw_pointer(childCtxHolder));
        }
        setState(2166);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::IS || _la == GQLParser::COLON

        || _la == GQLParser::LEFT_BRACE) {
          setState(2165);
          {
            auto childCtxHolder = ctx->EnterLabelAndPropertySetSpecification();
            labelAndPropertySetSpecification(get_raw_pointer(childCtxHolder));
          }
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2169);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 277) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 277)) & 560750930165759) != 0)) {
          setState(2168);
          {
            auto childCtxHolder = ctx->EnterElementVariableDeclaration();
            elementVariableDeclaration(get_raw_pointer(childCtxHolder));
          }
        }
        setState(2171);
        {
          auto childCtxHolder = ctx->EnterLabelAndPropertySetSpecification();
          labelAndPropertySetSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* labelAndPropertySetSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 342, GQLParser::RuleLabelAndPropertySetSpecification);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2185);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2174);
        {
          auto childCtxHolder = ctx->EnterIsOrColon();
          isOrColon(get_raw_pointer(childCtxHolder));
        }
        setState(2175);
        {
          auto childCtxHolder = ctx->EnterLabelSetSpecification();
          labelSetSpecification(get_raw_pointer(childCtxHolder));
        }
        setState(2177);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::LEFT_BRACE) {
          setState(2176);
          {
            auto childCtxHolder = ctx->EnterElementPropertySpecification();
            elementPropertySpecification(get_raw_pointer(childCtxHolder));
          }
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2182);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::IS || _la == GQLParser::COLON) {
          setState(2179);
          {
            auto childCtxHolder = ctx->EnterIsOrColon();
            isOrColon(get_raw_pointer(childCtxHolder));
          }
          setState(2180);
          {
            auto childCtxHolder = ctx->EnterLabelSetSpecification();
            labelSetSpecification(get_raw_pointer(childCtxHolder));
          }
        }
        setState(2184);
        {
          auto childCtxHolder = ctx->EnterElementPropertySpecification();
          elementPropertySpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathPatternPrefix(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 344, GQLParser::RulePathPatternPrefix);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2189);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ACYCLIC:
        case GQLParser::SIMPLE:
        case GQLParser::TRAIL:
        case GQLParser::WALK: {
          enterOuterAlt(_localctx, 1);
          setState(2187);
          {
            auto childCtxHolder = ctx->EnterPathModePrefix();
            pathModePrefix(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ALL:
        case GQLParser::ANY:
        case GQLParser::SHORTEST: {
          enterOuterAlt(_localctx, 2);
          setState(2188);
          {
            auto childCtxHolder = ctx->EnterPathSearchPrefix();
            pathSearchPrefix(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathModePrefix(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 346, GQLParser::RulePathModePrefix);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2191);
      {
        auto childCtxHolder = ctx->EnterPathMode();
        pathMode(get_raw_pointer(childCtxHolder));
      }
      setState(2193);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx)) {
      case 1: {
        setState(2192);
        {
          auto childCtxHolder = ctx->EnterPathOrPaths();
          pathOrPaths(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathMode(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 348, GQLParser::RulePathMode);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2195);
      _la = _input->LA(1);
      if (!(((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 18159121727489) != 0))) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathSearchPrefix(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 350, GQLParser::RulePathSearchPrefix);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2200);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2197);
        {
          auto childCtxHolder = ctx->EnterAllPathSearch();
          allPathSearch(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2198);
        {
          auto childCtxHolder = ctx->EnterAnyPathSearch();
          anyPathSearch(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2199);
        {
          auto childCtxHolder = ctx->EnterShortestPathSearch();
          shortestPathSearch(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* allPathSearch(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 352, GQLParser::RuleAllPathSearch);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2202);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ALL) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ALL);
      setState(2204);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx)) {
      case 1: {
        setState(2203);
        {
          auto childCtxHolder = ctx->EnterPathMode();
          pathMode(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2207);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 176, _ctx)) {
      case 1: {
        setState(2206);
        {
          auto childCtxHolder = ctx->EnterPathOrPaths();
          pathOrPaths(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathOrPaths(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 354, GQLParser::RulePathOrPaths);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2209);
      _la = _input->LA(1);
      if (!(_la == GQLParser::PATH

      || _la == GQLParser::PATHS)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* anyPathSearch(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 356, GQLParser::RuleAnyPathSearch);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2211);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ANY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ANY);
      setState(2213);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 177, _ctx)) {
      case 1: {
        setState(2212);
        {
          auto childCtxHolder = ctx->EnterNumberOfPaths();
          numberOfPaths(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2216);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 178, _ctx)) {
      case 1: {
        setState(2215);
        {
          auto childCtxHolder = ctx->EnterPathMode();
          pathMode(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2219);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx)) {
      case 1: {
        setState(2218);
        {
          auto childCtxHolder = ctx->EnterPathOrPaths();
          pathOrPaths(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* numberOfPaths(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 358, GQLParser::RuleNumberOfPaths);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2221);
      {
        auto childCtxHolder = ctx->EnterNonNegativeIntegerSpecification();
        nonNegativeIntegerSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* shortestPathSearch(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 360, GQLParser::RuleShortestPathSearch);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2227);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2223);
        {
          auto childCtxHolder = ctx->EnterAllShortestPathSearch();
          allShortestPathSearch(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2224);
        {
          auto childCtxHolder = ctx->EnterAnyShortestPathSearch();
          anyShortestPathSearch(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2225);
        {
          auto childCtxHolder = ctx->EnterCountedShortestPathSearch();
          countedShortestPathSearch(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(2226);
        {
          auto childCtxHolder = ctx->EnterCountedShortestGroupSearch();
          countedShortestGroupSearch(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* allShortestPathSearch(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 362, GQLParser::RuleAllShortestPathSearch);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2229);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ALL) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ALL);
      setState(2230);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SHORTEST) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SHORTEST);
      setState(2232);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 181, _ctx)) {
      case 1: {
        setState(2231);
        {
          auto childCtxHolder = ctx->EnterPathMode();
          pathMode(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2235);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {
      case 1: {
        setState(2234);
        {
          auto childCtxHolder = ctx->EnterPathOrPaths();
          pathOrPaths(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* anyShortestPathSearch(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 364, GQLParser::RuleAnyShortestPathSearch);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2237);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ANY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ANY);
      setState(2238);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SHORTEST) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SHORTEST);
      setState(2240);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 183, _ctx)) {
      case 1: {
        setState(2239);
        {
          auto childCtxHolder = ctx->EnterPathMode();
          pathMode(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2243);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx)) {
      case 1: {
        setState(2242);
        {
          auto childCtxHolder = ctx->EnterPathOrPaths();
          pathOrPaths(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* countedShortestPathSearch(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 366, GQLParser::RuleCountedShortestPathSearch);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2245);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SHORTEST) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SHORTEST);
      setState(2246);
      {
        auto childCtxHolder = ctx->EnterNumberOfPaths();
        numberOfPaths(get_raw_pointer(childCtxHolder));
      }
      setState(2248);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 185, _ctx)) {
      case 1: {
        setState(2247);
        {
          auto childCtxHolder = ctx->EnterPathMode();
          pathMode(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2251);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 186, _ctx)) {
      case 1: {
        setState(2250);
        {
          auto childCtxHolder = ctx->EnterPathOrPaths();
          pathOrPaths(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* countedShortestGroupSearch(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 368, GQLParser::RuleCountedShortestGroupSearch);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2253);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SHORTEST) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SHORTEST);
      setState(2255);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 983040) != 0) || _la == GQLParser::GENERAL_PARAMETER_REFERENCE) {
        setState(2254);
        {
          auto childCtxHolder = ctx->EnterNumberOfGroups();
          numberOfGroups(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2258);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 18159121727489) != 0)) {
        setState(2257);
        {
          auto childCtxHolder = ctx->EnterPathMode();
          pathMode(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2261);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PATH

      || _la == GQLParser::PATHS) {
        setState(2260);
        {
          auto childCtxHolder = ctx->EnterPathOrPaths();
          pathOrPaths(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2263);
      _la = _input->LA(1);
      if (!(_la == GQLParser::GROUP || _la == GQLParser::GROUPS)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* numberOfGroups(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 370, GQLParser::RuleNumberOfGroups);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2265);
      {
        auto childCtxHolder = ctx->EnterNonNegativeIntegerSpecification();
        nonNegativeIntegerSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathPatternExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 372, GQLParser::RulePathPatternExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      setState(2282);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 192, _ctx)) {
      case 1: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        auto ctxHolder = ctx->EnterPpePathTerm();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 1);
        setState(2267);
        {
          auto childCtxHolder = ctx->EnterPathTerm();
          pathTerm(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        auto ctxHolder = ctx->EnterPpeMultisetAlternation();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 2);
        setState(2268);
        {
          auto childCtxHolder = ctx->EnterPathTerm();
          pathTerm(get_raw_pointer(childCtxHolder));
        }
        setState(2271); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(2269);
                  if constexpr (has_OnToken<decltype(ctx)>::value) {
                    if (_input->LA(1) == GQLParser::MULTISET_ALTERNATION_OPERATOR) {
                      ctx->OnToken(_input->LT(1));
                    }
                  }
                  match(GQLParser::MULTISET_ALTERNATION_OPERATOR);
                  setState(2270);
                  {
                    auto childCtxHolder = ctx->EnterPathTerm();
                    pathTerm(get_raw_pointer(childCtxHolder));
                  }
                  break;
                }

          default:
            throw antlr4::NoViableAltException(this);
          }
          setState(2273); 
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 190, _ctx);
        } while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      case 3: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        auto ctxHolder = ctx->EnterPpePatternUnion();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 3);
        setState(2275);
        {
          auto childCtxHolder = ctx->EnterPathTerm();
          pathTerm(get_raw_pointer(childCtxHolder));
        }
        setState(2278); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(2276);
                  if constexpr (has_OnToken<decltype(ctx)>::value) {
                    if (_input->LA(1) == GQLParser::VERTICAL_BAR) {
                      ctx->OnToken(_input->LT(1));
                    }
                  }
                  match(GQLParser::VERTICAL_BAR);
                  setState(2277);
                  {
                    auto childCtxHolder = ctx->EnterPathTerm();
                    pathTerm(get_raw_pointer(childCtxHolder));
                  }
                  break;
                }

          default:
            throw antlr4::NoViableAltException(this);
          }
          setState(2280); 
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 191, _ctx);
        } while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathTerm(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 374, GQLParser::RulePathTerm);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(2285); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(2284);
                {
                  auto childCtxHolder = ctx->EnterPathFactor();
                  pathFactor(get_raw_pointer(childCtxHolder));
                }
                break;
              }

        default:
          throw antlr4::NoViableAltException(this);
        }
        setState(2287); 
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx);
      } while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathFactor(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 376, GQLParser::RulePathFactor);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2296);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx)) {
      case 1: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        auto ctxHolder = ctx->EnterPfPathPrimary();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 1);
        setState(2289);
        {
          auto childCtxHolder = ctx->EnterPathPrimary();
          pathPrimary(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        auto ctxHolder = ctx->EnterPfQuantifiedPathPrimary();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 2);
        setState(2290);
        {
          auto childCtxHolder = ctx->EnterPathPrimary();
          pathPrimary(get_raw_pointer(childCtxHolder));
        }
        setState(2291);
        {
          auto childCtxHolder = ctx->EnterGraphPatternQuantifier();
          graphPatternQuantifier(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        auto ctxHolder = ctx->EnterPfQuestionedPathPrimary();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 3);
        setState(2293);
        {
          auto childCtxHolder = ctx->EnterPathPrimary();
          pathPrimary(get_raw_pointer(childCtxHolder));
        }
        setState(2294);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::QUESTION_MARK) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::QUESTION_MARK);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathPrimary(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 378, GQLParser::RulePathPrimary);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2301);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
      case 1: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        auto ctxHolder = ctx->EnterPpElementPattern();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 1);
        setState(2298);
        {
          auto childCtxHolder = ctx->EnterElementPattern();
          elementPattern(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        auto ctxHolder = ctx->EnterPpParenthesizedPathPatternExpression();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 2);
        setState(2299);
        {
          auto childCtxHolder = ctx->EnterParenthesizedPathPatternExpression();
          parenthesizedPathPatternExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        auto ctxHolder = ctx->EnterPpSimplifiedPathPatternExpression();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 3);
        setState(2300);
        {
          auto childCtxHolder = ctx->EnterSimplifiedPathPatternExpression();
          simplifiedPathPatternExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* elementPattern(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 380, GQLParser::RuleElementPattern);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2305);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LEFT_PAREN: {
          enterOuterAlt(_localctx, 1);
          setState(2303);
          {
            auto childCtxHolder = ctx->EnterNodePattern();
            nodePattern(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LEFT_ARROW:
        case GQLParser::LEFT_ARROW_TILDE:
        case GQLParser::LEFT_ARROW_BRACKET:
        case GQLParser::LEFT_ARROW_TILDE_BRACKET:
        case GQLParser::LEFT_MINUS_RIGHT:
        case GQLParser::MINUS_LEFT_BRACKET:
        case GQLParser::RIGHT_ARROW:
        case GQLParser::TILDE_LEFT_BRACKET:
        case GQLParser::TILDE_RIGHT_ARROW:
        case GQLParser::MINUS_SIGN:
        case GQLParser::TILDE: {
          enterOuterAlt(_localctx, 2);
          setState(2304);
          {
            auto childCtxHolder = ctx->EnterEdgePattern();
            edgePattern(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nodePattern(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 382, GQLParser::RuleNodePattern);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2307);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(2308);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2309);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* elementPatternFiller(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 384, GQLParser::RuleElementPatternFiller);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2312);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0)) {
        setState(2311);
        {
          auto childCtxHolder = ctx->EnterElementVariableDeclaration();
          elementVariableDeclaration(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2315);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IS || _la == GQLParser::COLON) {
        setState(2314);
        {
          auto childCtxHolder = ctx->EnterIsLabelExpression();
          isLabelExpression(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2318);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::WHERE || _la == GQLParser::LEFT_BRACE) {
        setState(2317);
        {
          auto childCtxHolder = ctx->EnterElementPatternPredicate();
          elementPatternPredicate(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* elementVariableDeclaration(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 386, GQLParser::RuleElementVariableDeclaration);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2321);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx)) {
      case 1: {
        setState(2320);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::TEMP) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::TEMP);
        break;
      }

      default:
        break;
      }
      setState(2323);
      {
        auto childCtxHolder = ctx->EnterElementVariable();
        elementVariable(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* isLabelExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 388, GQLParser::RuleIsLabelExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2325);
      {
        auto childCtxHolder = ctx->EnterIsOrColon();
        isOrColon(get_raw_pointer(childCtxHolder));
      }
      setState(2326);
      {
        auto childCtxHolder = ctx->EnterLabelExpression();
        labelExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* isOrColon(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 390, GQLParser::RuleIsOrColon);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2328);
      _la = _input->LA(1);
      if (!(_la == GQLParser::IS || _la == GQLParser::COLON)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* elementPatternPredicate(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 392, GQLParser::RuleElementPatternPredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2332);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::WHERE: {
          enterOuterAlt(_localctx, 1);
          setState(2330);
          {
            auto childCtxHolder = ctx->EnterElementPatternWhereClause();
            elementPatternWhereClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(2331);
          {
            auto childCtxHolder = ctx->EnterElementPropertySpecification();
            elementPropertySpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* elementPatternWhereClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 394, GQLParser::RuleElementPatternWhereClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2334);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::WHERE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::WHERE);
      setState(2335);
      {
        auto childCtxHolder = ctx->EnterSearchCondition();
        searchCondition(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* elementPropertySpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 396, GQLParser::RuleElementPropertySpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2337);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(2338);
      {
        auto childCtxHolder = ctx->EnterPropertyKeyValuePairList();
        propertyKeyValuePairList(get_raw_pointer(childCtxHolder));
      }
      setState(2339);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* propertyKeyValuePairList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 398, GQLParser::RulePropertyKeyValuePairList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2341);
      {
        auto childCtxHolder = ctx->EnterPropertyKeyValuePair();
        propertyKeyValuePair(get_raw_pointer(childCtxHolder));
      }
      setState(2346);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(2342);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(2343);
        {
          auto childCtxHolder = ctx->EnterPropertyKeyValuePair();
          propertyKeyValuePair(get_raw_pointer(childCtxHolder));
        }
        setState(2348);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* propertyKeyValuePair(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 400, GQLParser::RulePropertyKeyValuePair);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2349);
      {
        auto childCtxHolder = ctx->EnterPropertyName();
        propertyName(get_raw_pointer(childCtxHolder));
      }
      setState(2350);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COLON) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COLON);
      setState(2351);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgePattern(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 402, GQLParser::RuleEdgePattern);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2355);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LEFT_ARROW_BRACKET:
        case GQLParser::LEFT_ARROW_TILDE_BRACKET:
        case GQLParser::MINUS_LEFT_BRACKET:
        case GQLParser::TILDE_LEFT_BRACKET: {
          enterOuterAlt(_localctx, 1);
          setState(2353);
          {
            auto childCtxHolder = ctx->EnterFullEdgePattern();
            fullEdgePattern(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LEFT_ARROW:
        case GQLParser::LEFT_ARROW_TILDE:
        case GQLParser::LEFT_MINUS_RIGHT:
        case GQLParser::RIGHT_ARROW:
        case GQLParser::TILDE_RIGHT_ARROW:
        case GQLParser::MINUS_SIGN:
        case GQLParser::TILDE: {
          enterOuterAlt(_localctx, 2);
          setState(2354);
          {
            auto childCtxHolder = ctx->EnterAbbreviatedEdgePattern();
            abbreviatedEdgePattern(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fullEdgePattern(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 404, GQLParser::RuleFullEdgePattern);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2364);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2357);
        {
          auto childCtxHolder = ctx->EnterFullEdgePointingLeft();
          fullEdgePointingLeft(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2358);
        {
          auto childCtxHolder = ctx->EnterFullEdgeUndirected();
          fullEdgeUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2359);
        {
          auto childCtxHolder = ctx->EnterFullEdgePointingRight();
          fullEdgePointingRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(2360);
        {
          auto childCtxHolder = ctx->EnterFullEdgeLeftOrUndirected();
          fullEdgeLeftOrUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(2361);
        {
          auto childCtxHolder = ctx->EnterFullEdgeUndirectedOrRight();
          fullEdgeUndirectedOrRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(2362);
        {
          auto childCtxHolder = ctx->EnterFullEdgeLeftOrRight();
          fullEdgeLeftOrRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(2363);
        {
          auto childCtxHolder = ctx->EnterFullEdgeAnyDirection();
          fullEdgeAnyDirection(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fullEdgePointingLeft(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 406, GQLParser::RuleFullEdgePointingLeft);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2366);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ARROW_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ARROW_BRACKET);
      setState(2367);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2368);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_MINUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_MINUS);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fullEdgeUndirected(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 408, GQLParser::RuleFullEdgeUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2370);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE_LEFT_BRACKET);
      setState(2371);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2372);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_TILDE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fullEdgePointingRight(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 410, GQLParser::RuleFullEdgePointingRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2374);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MINUS_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MINUS_LEFT_BRACKET);
      setState(2375);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2376);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BRACKET_RIGHT_ARROW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BRACKET_RIGHT_ARROW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fullEdgeLeftOrUndirected(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 412, GQLParser::RuleFullEdgeLeftOrUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2378);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ARROW_TILDE_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ARROW_TILDE_BRACKET);
      setState(2379);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2380);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_TILDE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fullEdgeUndirectedOrRight(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 414, GQLParser::RuleFullEdgeUndirectedOrRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2382);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE_LEFT_BRACKET);
      setState(2383);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2384);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BRACKET_TILDE_RIGHT_ARROW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BRACKET_TILDE_RIGHT_ARROW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fullEdgeLeftOrRight(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 416, GQLParser::RuleFullEdgeLeftOrRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2386);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ARROW_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ARROW_BRACKET);
      setState(2387);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2388);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BRACKET_RIGHT_ARROW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BRACKET_RIGHT_ARROW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fullEdgeAnyDirection(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 418, GQLParser::RuleFullEdgeAnyDirection);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2390);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MINUS_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MINUS_LEFT_BRACKET);
      setState(2391);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2392);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_MINUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_MINUS);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* abbreviatedEdgePattern(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 420, GQLParser::RuleAbbreviatedEdgePattern);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2394);
      _la = _input->LA(1);
      if (!(((((_la - 336) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 336)) & 281612416714771) != 0))) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* parenthesizedPathPatternExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 422, GQLParser::RuleParenthesizedPathPatternExpression);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2396);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(2398);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx)) {
      case 1: {
        setState(2397);
        {
          auto childCtxHolder = ctx->EnterSubpathVariableDeclaration();
          subpathVariableDeclaration(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2401);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 18159121727489) != 0)) {
        setState(2400);
        {
          auto childCtxHolder = ctx->EnterPathModePrefix();
          pathModePrefix(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2403);
      {
        auto childCtxHolder = ctx->EnterPathPatternExpression();
        pathPatternExpression(get_raw_pointer(childCtxHolder));
      }
      setState(2405);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::WHERE) {
        setState(2404);
        {
          auto childCtxHolder = ctx->EnterParenthesizedPathPatternWhereClause();
          parenthesizedPathPatternWhereClause(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2407);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* subpathVariableDeclaration(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 424, GQLParser::RuleSubpathVariableDeclaration);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2409);
      {
        auto childCtxHolder = ctx->EnterSubpathVariable();
        subpathVariable(get_raw_pointer(childCtxHolder));
      }
      setState(2410);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EQUALS_OPERATOR);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* parenthesizedPathPatternWhereClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 426, GQLParser::RuleParenthesizedPathPatternWhereClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2412);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::WHERE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::WHERE);
      setState(2413);
      {
        auto childCtxHolder = ctx->EnterSearchCondition();
        searchCondition(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }


  template<typename ContextT>
  antlr4::ParserRuleContext* labelExpression(ContextT* ctx) {
     return labelExpression(0, ctx);
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* labelExpression(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, parentState);
    antlr4::ParserRuleContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 428;
    enterRecursionRule(_localctx, 428, GQLParser::RuleLabelExpression, precedence);

      

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(2424);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::EXCLAMATION_MARK: {
          {
            auto savedLocalCtx = _localctx;
            _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
            _localctx->copyFrom(savedLocalCtx);
          }
          _ctx = _localctx;
          previousContext = _localctx;
          auto ctxHolder = ctx->EnterLabelExpressionNegation();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });

          setState(2416);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::EXCLAMATION_MARK) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::EXCLAMATION_MARK);
          setState(2417);
          {
            auto childCtxHolder = ctx->EnterLabelExpression();
            labelExpression(6, get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          {
            auto savedLocalCtx = _localctx;
            _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
            _localctx->copyFrom(savedLocalCtx);
          }
          _ctx = _localctx;
          previousContext = _localctx;
          auto ctxHolder = ctx->EnterLabelExpressionName();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          setState(2418);
          {
            auto childCtxHolder = ctx->EnterLabelName();
            labelName(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::PERCENT: {
          {
            auto savedLocalCtx = _localctx;
            _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
            _localctx->copyFrom(savedLocalCtx);
          }
          _ctx = _localctx;
          previousContext = _localctx;
          auto ctxHolder = ctx->EnterLabelExpressionWildcard();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          setState(2419);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::PERCENT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::PERCENT);
          break;
        }

        case GQLParser::LEFT_PAREN: {
          {
            auto savedLocalCtx = _localctx;
            _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
            _localctx->copyFrom(savedLocalCtx);
          }
          _ctx = _localctx;
          previousContext = _localctx;
          auto ctxHolder = ctx->EnterLabelExpressionParenthesized();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          setState(2420);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(2421);
          {
            auto childCtxHolder = ctx->EnterLabelExpression();
            labelExpression(0, get_raw_pointer(childCtxHolder));
          }
          setState(2422);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
      _ctx->stop = _input->LT(-1);
      setState(2434);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 210, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          setState(2432);
          _errHandler->sync(this);
          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 209, _ctx)) {
          case 1: {
            auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
            auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
            newContext->copyFrom(newParentContext);
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleLabelExpression);
            auto ctxHolder = ctx->PushLabelExpressionConjunction_LabelExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(2426);

            if (!(precpred(_ctx, 5))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 5)");
            setState(2427);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::AMPERSAND) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::AMPERSAND);
            setState(2428);
            {
              auto childCtxHolder = ctx->EnterLabelExpression();
              labelExpression(6, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 2: {
            auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
            auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
            newContext->copyFrom(newParentContext);
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleLabelExpression);
            auto ctxHolder = ctx->PushLabelExpressionDisjunction_LabelExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(2429);

            if (!(precpred(_ctx, 4))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 4)");
            setState(2430);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::VERTICAL_BAR) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::VERTICAL_BAR);
            setState(2431);
            {
              auto childCtxHolder = ctx->EnterLabelExpression();
              labelExpression(5, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          } 
        }
        setState(2436);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 210, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathVariableReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 430, GQLParser::RulePathVariableReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2437);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* elementVariableReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 432, GQLParser::RuleElementVariableReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2439);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphPatternQuantifier(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 434, GQLParser::RuleGraphPatternQuantifier);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2445);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 211, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2441);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::ASTERISK) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::ASTERISK);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2442);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PLUS_SIGN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PLUS_SIGN);
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2443);
        {
          auto childCtxHolder = ctx->EnterFixedQuantifier();
          fixedQuantifier(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(2444);
        {
          auto childCtxHolder = ctx->EnterGeneralQuantifier();
          generalQuantifier(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fixedQuantifier(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 436, GQLParser::RuleFixedQuantifier);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2447);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(2448);
      {
        auto childCtxHolder = ctx->EnterUnsignedInteger();
        unsignedInteger(get_raw_pointer(childCtxHolder));
      }
      setState(2449);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* generalQuantifier(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 438, GQLParser::RuleGeneralQuantifier);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2451);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(2453);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 983040) != 0)) {
        setState(2452);
        {
          auto childCtxHolder = ctx->EnterLowerBound();
          lowerBound(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2455);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(2457);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 983040) != 0)) {
        setState(2456);
        {
          auto childCtxHolder = ctx->EnterUpperBound();
          upperBound(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2459);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* lowerBound(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 440, GQLParser::RuleLowerBound);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2461);
      {
        auto childCtxHolder = ctx->EnterUnsignedInteger();
        unsignedInteger(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* upperBound(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 442, GQLParser::RuleUpperBound);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2463);
      {
        auto childCtxHolder = ctx->EnterUnsignedInteger();
        unsignedInteger(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedPathPatternExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 444, GQLParser::RuleSimplifiedPathPatternExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2472);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 214, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2465);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDefaultingLeft();
          simplifiedDefaultingLeft(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2466);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDefaultingUndirected();
          simplifiedDefaultingUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2467);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDefaultingRight();
          simplifiedDefaultingRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(2468);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDefaultingLeftOrUndirected();
          simplifiedDefaultingLeftOrUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(2469);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDefaultingUndirectedOrRight();
          simplifiedDefaultingUndirectedOrRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(2470);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDefaultingLeftOrRight();
          simplifiedDefaultingLeftOrRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(2471);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDefaultingAnyDirection();
          simplifiedDefaultingAnyDirection(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedDefaultingLeft(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 446, GQLParser::RuleSimplifiedDefaultingLeft);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2474);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_MINUS_SLASH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_MINUS_SLASH);
      setState(2475);
      {
        auto childCtxHolder = ctx->EnterSimplifiedContents();
        simplifiedContents(get_raw_pointer(childCtxHolder));
      }
      setState(2476);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SLASH_MINUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SLASH_MINUS);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedDefaultingUndirected(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 448, GQLParser::RuleSimplifiedDefaultingUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2478);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE_SLASH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE_SLASH);
      setState(2479);
      {
        auto childCtxHolder = ctx->EnterSimplifiedContents();
        simplifiedContents(get_raw_pointer(childCtxHolder));
      }
      setState(2480);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SLASH_TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SLASH_TILDE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedDefaultingRight(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 450, GQLParser::RuleSimplifiedDefaultingRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2482);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MINUS_SLASH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MINUS_SLASH);
      setState(2483);
      {
        auto childCtxHolder = ctx->EnterSimplifiedContents();
        simplifiedContents(get_raw_pointer(childCtxHolder));
      }
      setState(2484);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SLASH_MINUS_RIGHT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SLASH_MINUS_RIGHT);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedDefaultingLeftOrUndirected(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 452, GQLParser::RuleSimplifiedDefaultingLeftOrUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2486);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_TILDE_SLASH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_TILDE_SLASH);
      setState(2487);
      {
        auto childCtxHolder = ctx->EnterSimplifiedContents();
        simplifiedContents(get_raw_pointer(childCtxHolder));
      }
      setState(2488);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SLASH_TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SLASH_TILDE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedDefaultingUndirectedOrRight(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 454, GQLParser::RuleSimplifiedDefaultingUndirectedOrRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2490);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE_SLASH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE_SLASH);
      setState(2491);
      {
        auto childCtxHolder = ctx->EnterSimplifiedContents();
        simplifiedContents(get_raw_pointer(childCtxHolder));
      }
      setState(2492);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SLASH_TILDE_RIGHT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SLASH_TILDE_RIGHT);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedDefaultingLeftOrRight(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 456, GQLParser::RuleSimplifiedDefaultingLeftOrRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2494);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_MINUS_SLASH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_MINUS_SLASH);
      setState(2495);
      {
        auto childCtxHolder = ctx->EnterSimplifiedContents();
        simplifiedContents(get_raw_pointer(childCtxHolder));
      }
      setState(2496);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SLASH_MINUS_RIGHT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SLASH_MINUS_RIGHT);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedDefaultingAnyDirection(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 458, GQLParser::RuleSimplifiedDefaultingAnyDirection);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2498);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MINUS_SLASH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MINUS_SLASH);
      setState(2499);
      {
        auto childCtxHolder = ctx->EnterSimplifiedContents();
        simplifiedContents(get_raw_pointer(childCtxHolder));
      }
      setState(2500);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SLASH_MINUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SLASH_MINUS);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedContents(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 460, GQLParser::RuleSimplifiedContents);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2505);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2502);
        {
          auto childCtxHolder = ctx->EnterSimplifiedTerm();
          simplifiedTerm(0, get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2503);
        {
          auto childCtxHolder = ctx->EnterSimplifiedPathUnion();
          simplifiedPathUnion(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2504);
        {
          auto childCtxHolder = ctx->EnterSimplifiedMultisetAlternation();
          simplifiedMultisetAlternation(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedPathUnion(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 462, GQLParser::RuleSimplifiedPathUnion);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2507);
      {
        auto childCtxHolder = ctx->EnterSimplifiedTerm();
        simplifiedTerm(0, get_raw_pointer(childCtxHolder));
      }
      setState(2508);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::VERTICAL_BAR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::VERTICAL_BAR);
      setState(2509);
      {
        auto childCtxHolder = ctx->EnterSimplifiedTerm();
        simplifiedTerm(0, get_raw_pointer(childCtxHolder));
      }
      setState(2514);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::VERTICAL_BAR) {
        setState(2510);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::VERTICAL_BAR) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::VERTICAL_BAR);
        setState(2511);
        {
          auto childCtxHolder = ctx->EnterSimplifiedTerm();
          simplifiedTerm(0, get_raw_pointer(childCtxHolder));
        }
        setState(2516);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedMultisetAlternation(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 464, GQLParser::RuleSimplifiedMultisetAlternation);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2517);
      {
        auto childCtxHolder = ctx->EnterSimplifiedTerm();
        simplifiedTerm(0, get_raw_pointer(childCtxHolder));
      }
      setState(2518);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MULTISET_ALTERNATION_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MULTISET_ALTERNATION_OPERATOR);
      setState(2519);
      {
        auto childCtxHolder = ctx->EnterSimplifiedTerm();
        simplifiedTerm(0, get_raw_pointer(childCtxHolder));
      }
      setState(2524);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::MULTISET_ALTERNATION_OPERATOR) {
        setState(2520);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::MULTISET_ALTERNATION_OPERATOR) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::MULTISET_ALTERNATION_OPERATOR);
        setState(2521);
        {
          auto childCtxHolder = ctx->EnterSimplifiedTerm();
          simplifiedTerm(0, get_raw_pointer(childCtxHolder));
        }
        setState(2526);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }


  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedTerm(ContextT* ctx) {
     return simplifiedTerm(0, ctx);
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedTerm(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, parentState);
    antlr4::ParserRuleContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 466;
    enterRecursionRule(_localctx, 466, GQLParser::RuleSimplifiedTerm, precedence);

      

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      {
        auto savedLocalCtx = _localctx;
        _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
        _localctx->copyFrom(savedLocalCtx);
      }
      _ctx = _localctx;
      previousContext = _localctx;
      auto ctxHolder = ctx->EnterSimplifiedFactorLowLabel();
      auto ctx = get_raw_pointer(ctxHolder);
      auto onExit = antlrcpp::finally([ctx, _localctx] {
        (void)_localctx;
        if constexpr (has_ExitRule<decltype(ctx)>::value)
          ctx->ExitRule(_localctx);
        else
          (void)ctx;
      });

      setState(2528);
      {
        auto childCtxHolder = ctx->EnterSimplifiedFactorLow();
        simplifiedFactorLow(0, get_raw_pointer(childCtxHolder));
      }
      _ctx->stop = _input->LT(-1);
      setState(2534);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
          auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
          newContext->copyFrom(newParentContext);
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimplifiedTerm);
          auto ctxHolder = ctx->PushSimplifiedConcatenationLabel_SimplifiedTerm();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          setState(2530);

          if (!(precpred(_ctx, 1))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(2531);
          {
            auto childCtxHolder = ctx->EnterSimplifiedFactorLow();
            simplifiedFactorLow(0, get_raw_pointer(childCtxHolder));
          } 
        }
        setState(2536);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }


  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedFactorLow(ContextT* ctx) {
     return simplifiedFactorLow(0, ctx);
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedFactorLow(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, parentState);
    antlr4::ParserRuleContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 468;
    enterRecursionRule(_localctx, 468, GQLParser::RuleSimplifiedFactorLow, precedence);

      

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      {
        auto savedLocalCtx = _localctx;
        _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
        _localctx->copyFrom(savedLocalCtx);
      }
      _ctx = _localctx;
      previousContext = _localctx;
      auto ctxHolder = ctx->EnterSimplifiedFactorHighLabel();
      auto ctx = get_raw_pointer(ctxHolder);
      auto onExit = antlrcpp::finally([ctx, _localctx] {
        (void)_localctx;
        if constexpr (has_ExitRule<decltype(ctx)>::value)
          ctx->ExitRule(_localctx);
        else
          (void)ctx;
      });

      setState(2538);
      {
        auto childCtxHolder = ctx->EnterSimplifiedFactorHigh();
        simplifiedFactorHigh(get_raw_pointer(childCtxHolder));
      }
      _ctx->stop = _input->LT(-1);
      setState(2545);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
          auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
          newContext->copyFrom(newParentContext);
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimplifiedFactorLow);
          auto ctxHolder = ctx->PushSimplifiedConjunctionLabel_SimplifiedFactorLow();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          setState(2540);

          if (!(precpred(_ctx, 1))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(2541);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::AMPERSAND) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::AMPERSAND);
          setState(2542);
          {
            auto childCtxHolder = ctx->EnterSimplifiedFactorHigh();
            simplifiedFactorHigh(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(2547);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedFactorHigh(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 470, GQLParser::RuleSimplifiedFactorHigh);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2551);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 220, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2548);
        {
          auto childCtxHolder = ctx->EnterSimplifiedTertiary();
          simplifiedTertiary(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2549);
        {
          auto childCtxHolder = ctx->EnterSimplifiedQuantified();
          simplifiedQuantified(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2550);
        {
          auto childCtxHolder = ctx->EnterSimplifiedQuestioned();
          simplifiedQuestioned(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedQuantified(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 472, GQLParser::RuleSimplifiedQuantified);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2553);
      {
        auto childCtxHolder = ctx->EnterSimplifiedTertiary();
        simplifiedTertiary(get_raw_pointer(childCtxHolder));
      }
      setState(2554);
      {
        auto childCtxHolder = ctx->EnterGraphPatternQuantifier();
        graphPatternQuantifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedQuestioned(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 474, GQLParser::RuleSimplifiedQuestioned);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2556);
      {
        auto childCtxHolder = ctx->EnterSimplifiedTertiary();
        simplifiedTertiary(get_raw_pointer(childCtxHolder));
      }
      setState(2557);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::QUESTION_MARK) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::QUESTION_MARK);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedTertiary(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 476, GQLParser::RuleSimplifiedTertiary);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2561);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2559);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDirectionOverride();
          simplifiedDirectionOverride(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2560);
        {
          auto childCtxHolder = ctx->EnterSimplifiedSecondary();
          simplifiedSecondary(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedDirectionOverride(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 478, GQLParser::RuleSimplifiedDirectionOverride);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2570);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 222, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2563);
        {
          auto childCtxHolder = ctx->EnterSimplifiedOverrideLeft();
          simplifiedOverrideLeft(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2564);
        {
          auto childCtxHolder = ctx->EnterSimplifiedOverrideUndirected();
          simplifiedOverrideUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2565);
        {
          auto childCtxHolder = ctx->EnterSimplifiedOverrideRight();
          simplifiedOverrideRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(2566);
        {
          auto childCtxHolder = ctx->EnterSimplifiedOverrideLeftOrUndirected();
          simplifiedOverrideLeftOrUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(2567);
        {
          auto childCtxHolder = ctx->EnterSimplifiedOverrideUndirectedOrRight();
          simplifiedOverrideUndirectedOrRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(2568);
        {
          auto childCtxHolder = ctx->EnterSimplifiedOverrideLeftOrRight();
          simplifiedOverrideLeftOrRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(2569);
        {
          auto childCtxHolder = ctx->EnterSimplifiedOverrideAnyDirection();
          simplifiedOverrideAnyDirection(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedOverrideLeft(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 480, GQLParser::RuleSimplifiedOverrideLeft);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2572);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ANGLE_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ANGLE_BRACKET);
      setState(2573);
      {
        auto childCtxHolder = ctx->EnterSimplifiedSecondary();
        simplifiedSecondary(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedOverrideUndirected(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 482, GQLParser::RuleSimplifiedOverrideUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2575);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE);
      setState(2576);
      {
        auto childCtxHolder = ctx->EnterSimplifiedSecondary();
        simplifiedSecondary(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedOverrideRight(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 484, GQLParser::RuleSimplifiedOverrideRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2578);
      {
        auto childCtxHolder = ctx->EnterSimplifiedSecondary();
        simplifiedSecondary(get_raw_pointer(childCtxHolder));
      }
      setState(2579);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_ANGLE_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_ANGLE_BRACKET);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedOverrideLeftOrUndirected(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 486, GQLParser::RuleSimplifiedOverrideLeftOrUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2581);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ARROW_TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ARROW_TILDE);
      setState(2582);
      {
        auto childCtxHolder = ctx->EnterSimplifiedSecondary();
        simplifiedSecondary(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedOverrideUndirectedOrRight(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 488, GQLParser::RuleSimplifiedOverrideUndirectedOrRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2584);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE);
      setState(2585);
      {
        auto childCtxHolder = ctx->EnterSimplifiedSecondary();
        simplifiedSecondary(get_raw_pointer(childCtxHolder));
      }
      setState(2586);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_ANGLE_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_ANGLE_BRACKET);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedOverrideLeftOrRight(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 490, GQLParser::RuleSimplifiedOverrideLeftOrRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2588);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ANGLE_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ANGLE_BRACKET);
      setState(2589);
      {
        auto childCtxHolder = ctx->EnterSimplifiedSecondary();
        simplifiedSecondary(get_raw_pointer(childCtxHolder));
      }
      setState(2590);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_ANGLE_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_ANGLE_BRACKET);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedOverrideAnyDirection(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 492, GQLParser::RuleSimplifiedOverrideAnyDirection);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2592);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MINUS_SIGN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MINUS_SIGN);
      setState(2593);
      {
        auto childCtxHolder = ctx->EnterSimplifiedSecondary();
        simplifiedSecondary(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedSecondary(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 494, GQLParser::RuleSimplifiedSecondary);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2597);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER:
        case GQLParser::LEFT_PAREN: {
          enterOuterAlt(_localctx, 1);
          setState(2595);
          {
            auto childCtxHolder = ctx->EnterSimplifiedPrimary();
            simplifiedPrimary(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::EXCLAMATION_MARK: {
          enterOuterAlt(_localctx, 2);
          setState(2596);
          {
            auto childCtxHolder = ctx->EnterSimplifiedNegation();
            simplifiedNegation(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedNegation(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 496, GQLParser::RuleSimplifiedNegation);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2599);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EXCLAMATION_MARK) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EXCLAMATION_MARK);
      setState(2600);
      {
        auto childCtxHolder = ctx->EnterSimplifiedPrimary();
        simplifiedPrimary(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simplifiedPrimary(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 498, GQLParser::RuleSimplifiedPrimary);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2607);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 1);
          setState(2602);
          {
            auto childCtxHolder = ctx->EnterLabelName();
            labelName(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LEFT_PAREN: {
          enterOuterAlt(_localctx, 2);
          setState(2603);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(2604);
          {
            auto childCtxHolder = ctx->EnterSimplifiedContents();
            simplifiedContents(get_raw_pointer(childCtxHolder));
          }
          setState(2605);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* whereClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 500, GQLParser::RuleWhereClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2609);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::WHERE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::WHERE);
      setState(2610);
      {
        auto childCtxHolder = ctx->EnterSearchCondition();
        searchCondition(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* yieldClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 502, GQLParser::RuleYieldClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2612);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::YIELD) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::YIELD);
      setState(2613);
      {
        auto childCtxHolder = ctx->EnterYieldItemList();
        yieldItemList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* yieldItemList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 504, GQLParser::RuleYieldItemList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2615);
      {
        auto childCtxHolder = ctx->EnterYieldItem();
        yieldItem(get_raw_pointer(childCtxHolder));
      }
      setState(2620);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(2616);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(2617);
        {
          auto childCtxHolder = ctx->EnterYieldItem();
          yieldItem(get_raw_pointer(childCtxHolder));
        }
        setState(2622);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* yieldItem(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 506, GQLParser::RuleYieldItem);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2623);
      {
        auto childCtxHolder = ctx->EnterYieldItemName();
        yieldItemName(get_raw_pointer(childCtxHolder));
      }
      setState(2625);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::AS) {
        setState(2624);
        {
          auto childCtxHolder = ctx->EnterYieldItemAlias();
          yieldItemAlias(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* yieldItemName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 508, GQLParser::RuleYieldItemName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2627);
      {
        auto childCtxHolder = ctx->EnterFieldName();
        fieldName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* yieldItemAlias(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 510, GQLParser::RuleYieldItemAlias);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2629);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::AS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::AS);
      setState(2630);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* groupByClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 512, GQLParser::RuleGroupByClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2632);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GROUP) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GROUP);
      setState(2633);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BY);
      setState(2634);
      {
        auto childCtxHolder = ctx->EnterGroupingElementList();
        groupingElementList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* groupingElementList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 514, GQLParser::RuleGroupingElementList);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      setState(2645);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 1);
          setState(2636);
          {
            auto childCtxHolder = ctx->EnterGroupingElement();
            groupingElement(get_raw_pointer(childCtxHolder));
          }
          setState(2641);
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx);
          while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(2637);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::COMMA) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::COMMA);
              setState(2638);
              {
                auto childCtxHolder = ctx->EnterGroupingElement();
                groupingElement(get_raw_pointer(childCtxHolder));
              } 
            }
            setState(2643);
            _errHandler->sync(this);
            alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx);
          }
          break;
        }

        case GQLParser::LEFT_PAREN: {
          enterOuterAlt(_localctx, 2);
          setState(2644);
          {
            auto childCtxHolder = ctx->EnterEmptyGroupingSet();
            emptyGroupingSet(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* groupingElement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 516, GQLParser::RuleGroupingElement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2647);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* emptyGroupingSet(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 518, GQLParser::RuleEmptyGroupingSet);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2649);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(2650);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* orderByClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 520, GQLParser::RuleOrderByClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2652);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ORDER) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ORDER);
      setState(2653);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BY);
      setState(2654);
      {
        auto childCtxHolder = ctx->EnterSortSpecificationList();
        sortSpecificationList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sortSpecificationList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 522, GQLParser::RuleSortSpecificationList);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(2656);
      {
        auto childCtxHolder = ctx->EnterSortSpecification();
        sortSpecification(get_raw_pointer(childCtxHolder));
      }
      setState(2661);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 229, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2657);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COMMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COMMA);
          setState(2658);
          {
            auto childCtxHolder = ctx->EnterSortSpecification();
            sortSpecification(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(2663);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 229, _ctx);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sortSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 524, GQLParser::RuleSortSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2664);
      {
        auto childCtxHolder = ctx->EnterSortKey();
        sortKey(get_raw_pointer(childCtxHolder));
      }
      setState(2666);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx)) {
      case 1: {
        setState(2665);
        {
          auto childCtxHolder = ctx->EnterOrderingSpecification();
          orderingSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2669);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx)) {
      case 1: {
        setState(2668);
        {
          auto childCtxHolder = ctx->EnterNullOrdering();
          nullOrdering(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sortKey(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 526, GQLParser::RuleSortKey);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2671);
      {
        auto childCtxHolder = ctx->EnterAggregatingValueExpression();
        aggregatingValueExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* orderingSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 528, GQLParser::RuleOrderingSpecification);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2673);
      _la = _input->LA(1);
      if (!(((((_la - 28) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 28)) & 1688849860263939) != 0))) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nullOrdering(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 530, GQLParser::RuleNullOrdering);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2679);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2675);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NULLS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NULLS);
        setState(2676);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::FIRST) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::FIRST);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2677);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NULLS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NULLS);
        setState(2678);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LAST) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LAST);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* limitClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 532, GQLParser::RuleLimitClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2681);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LIMIT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LIMIT);
      setState(2682);
      {
        auto childCtxHolder = ctx->EnterNonNegativeIntegerSpecification();
        nonNegativeIntegerSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* offsetClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 534, GQLParser::RuleOffsetClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2684);
      {
        auto childCtxHolder = ctx->EnterOffsetSynonym();
        offsetSynonym(get_raw_pointer(childCtxHolder));
      }
      setState(2685);
      {
        auto childCtxHolder = ctx->EnterNonNegativeIntegerSpecification();
        nonNegativeIntegerSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* offsetSynonym(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 536, GQLParser::RuleOffsetSynonym);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2687);
      _la = _input->LA(1);
      if (!(_la == GQLParser::OFFSET

      || _la == GQLParser::SKIP_RESERVED_WORD)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* schemaReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 538, GQLParser::RuleSchemaReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2692);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::SOLIDUS: {
          enterOuterAlt(_localctx, 1);
          setState(2689);
          {
            auto childCtxHolder = ctx->EnterAbsoluteCatalogSchemaReference();
            absoluteCatalogSchemaReference(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CURRENT_SCHEMA:
        case GQLParser::HOME_SCHEMA:
        case GQLParser::DOUBLE_PERIOD:
        case GQLParser::PERIOD: {
          enterOuterAlt(_localctx, 2);
          setState(2690);
          {
            auto childCtxHolder = ctx->EnterRelativeCatalogSchemaReference();
            relativeCatalogSchemaReference(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::SUBSTITUTED_PARAMETER_REFERENCE: {
          enterOuterAlt(_localctx, 3);
          setState(2691);
          {
            auto childCtxHolder = ctx->EnterReferenceParameterSpecification();
            referenceParameterSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* absoluteCatalogSchemaReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 540, GQLParser::RuleAbsoluteCatalogSchemaReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2698);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 234, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2694);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::SOLIDUS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::SOLIDUS);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2695);
        {
          auto childCtxHolder = ctx->EnterAbsoluteDirectoryPath();
          absoluteDirectoryPath(get_raw_pointer(childCtxHolder));
        }
        setState(2696);
        {
          auto childCtxHolder = ctx->EnterSchemaName();
          schemaName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* catalogSchemaParentAndName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 542, GQLParser::RuleCatalogSchemaParentAndName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2700);
      {
        auto childCtxHolder = ctx->EnterAbsoluteDirectoryPath();
        absoluteDirectoryPath(get_raw_pointer(childCtxHolder));
      }
      setState(2701);
      {
        auto childCtxHolder = ctx->EnterSchemaName();
        schemaName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* relativeCatalogSchemaReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 544, GQLParser::RuleRelativeCatalogSchemaReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2707);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CURRENT_SCHEMA:
        case GQLParser::HOME_SCHEMA:
        case GQLParser::PERIOD: {
          enterOuterAlt(_localctx, 1);
          setState(2703);
          {
            auto childCtxHolder = ctx->EnterPredefinedSchemaReference();
            predefinedSchemaReference(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DOUBLE_PERIOD: {
          enterOuterAlt(_localctx, 2);
          setState(2704);
          {
            auto childCtxHolder = ctx->EnterRelativeDirectoryPath();
            relativeDirectoryPath(get_raw_pointer(childCtxHolder));
          }
          setState(2705);
          {
            auto childCtxHolder = ctx->EnterSchemaName();
            schemaName(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* predefinedSchemaReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 546, GQLParser::RulePredefinedSchemaReference);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2709);
      _la = _input->LA(1);
      if (!(_la == GQLParser::CURRENT_SCHEMA

      || _la == GQLParser::HOME_SCHEMA || _la == GQLParser::PERIOD)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* absoluteDirectoryPath(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 548, GQLParser::RuleAbsoluteDirectoryPath);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2711);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SOLIDUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SOLIDUS);
      setState(2713);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 236, _ctx)) {
      case 1: {
        setState(2712);
        {
          auto childCtxHolder = ctx->EnterSimpleDirectoryPath();
          simpleDirectoryPath(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* relativeDirectoryPath(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 550, GQLParser::RuleRelativeDirectoryPath);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(2715);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DOUBLE_PERIOD) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DOUBLE_PERIOD);
      setState(2720);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2716);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::SOLIDUS) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::SOLIDUS);
          setState(2717);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::DOUBLE_PERIOD) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::DOUBLE_PERIOD); 
        }
        setState(2722);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx);
      }
      setState(2723);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SOLIDUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SOLIDUS);
      setState(2725);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx)) {
      case 1: {
        setState(2724);
        {
          auto childCtxHolder = ctx->EnterSimpleDirectoryPath();
          simpleDirectoryPath(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simpleDirectoryPath(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 552, GQLParser::RuleSimpleDirectoryPath);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(2730); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(2727);
                {
                  auto childCtxHolder = ctx->EnterDirectoryName();
                  directoryName(get_raw_pointer(childCtxHolder));
                }
                setState(2728);
                if constexpr (has_OnToken<decltype(ctx)>::value) {
                  if (_input->LA(1) == GQLParser::SOLIDUS) {
                    ctx->OnToken(_input->LT(1));
                  }
                }
                match(GQLParser::SOLIDUS);
                break;
              }

        default:
          throw antlr4::NoViableAltException(this);
        }
        setState(2732); 
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 239, _ctx);
      } while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 554, GQLParser::RuleGraphReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2740);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 240, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2734);
        {
          auto childCtxHolder = ctx->EnterCatalogObjectParentReference();
          catalogObjectParentReference(get_raw_pointer(childCtxHolder));
        }
        setState(2735);
        {
          auto childCtxHolder = ctx->EnterGraphName();
          graphName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2737);
        {
          auto childCtxHolder = ctx->EnterDelimitedGraphName();
          delimitedGraphName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2738);
        {
          auto childCtxHolder = ctx->EnterHomeGraph();
          homeGraph(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(2739);
        {
          auto childCtxHolder = ctx->EnterReferenceParameterSpecification();
          referenceParameterSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* catalogGraphParentAndName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 556, GQLParser::RuleCatalogGraphParentAndName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2743);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx)) {
      case 1: {
        setState(2742);
        {
          auto childCtxHolder = ctx->EnterCatalogObjectParentReference();
          catalogObjectParentReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2745);
      {
        auto childCtxHolder = ctx->EnterGraphName();
        graphName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* homeGraph(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 558, GQLParser::RuleHomeGraph);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2747);
      _la = _input->LA(1);
      if (!(_la == GQLParser::HOME_GRAPH

      || _la == GQLParser::HOME_PROPERTY_GRAPH)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphTypeReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 560, GQLParser::RuleGraphTypeReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2751);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2749);
        {
          auto childCtxHolder = ctx->EnterCatalogGraphTypeParentAndName();
          catalogGraphTypeParentAndName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2750);
        {
          auto childCtxHolder = ctx->EnterReferenceParameterSpecification();
          referenceParameterSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* catalogGraphTypeParentAndName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 562, GQLParser::RuleCatalogGraphTypeParentAndName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2754);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx)) {
      case 1: {
        setState(2753);
        {
          auto childCtxHolder = ctx->EnterCatalogObjectParentReference();
          catalogObjectParentReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2756);
      {
        auto childCtxHolder = ctx->EnterGraphTypeName();
        graphTypeName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* bindingTableReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 564, GQLParser::RuleBindingTableReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2763);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2758);
        {
          auto childCtxHolder = ctx->EnterCatalogObjectParentReference();
          catalogObjectParentReference(get_raw_pointer(childCtxHolder));
        }
        setState(2759);
        {
          auto childCtxHolder = ctx->EnterBindingTableName();
          bindingTableName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2761);
        {
          auto childCtxHolder = ctx->EnterDelimitedBindingTableName();
          delimitedBindingTableName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2762);
        {
          auto childCtxHolder = ctx->EnterReferenceParameterSpecification();
          referenceParameterSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* procedureReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 566, GQLParser::RuleProcedureReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2767);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 245, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2765);
        {
          auto childCtxHolder = ctx->EnterCatalogProcedureParentAndName();
          catalogProcedureParentAndName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2766);
        {
          auto childCtxHolder = ctx->EnterReferenceParameterSpecification();
          referenceParameterSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* catalogProcedureParentAndName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 568, GQLParser::RuleCatalogProcedureParentAndName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2770);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 246, _ctx)) {
      case 1: {
        setState(2769);
        {
          auto childCtxHolder = ctx->EnterCatalogObjectParentReference();
          catalogObjectParentReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2772);
      {
        auto childCtxHolder = ctx->EnterProcedureName();
        procedureName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* catalogObjectParentReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 570, GQLParser::RuleCatalogObjectParentReference);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      setState(2793);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CURRENT_SCHEMA:
        case GQLParser::HOME_SCHEMA:
        case GQLParser::SUBSTITUTED_PARAMETER_REFERENCE:
        case GQLParser::DOUBLE_PERIOD:
        case GQLParser::PERIOD:
        case GQLParser::SOLIDUS: {
          enterOuterAlt(_localctx, 1);
          setState(2774);
          {
            auto childCtxHolder = ctx->EnterSchemaReference();
            schemaReference(get_raw_pointer(childCtxHolder));
          }
          setState(2776);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::SOLIDUS) {
            setState(2775);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::SOLIDUS) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::SOLIDUS);
          }
          setState(2783);
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx);
          while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(2778);
              {
                auto childCtxHolder = ctx->EnterObjectName();
                objectName(get_raw_pointer(childCtxHolder));
              }
              setState(2779);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::PERIOD) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::PERIOD); 
            }
            setState(2785);
            _errHandler->sync(this);
            alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx);
          }
          break;
        }

        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 2);
          setState(2789); 
          _errHandler->sync(this);
          alt = 1;
          do {
            switch (alt) {
              case 1: {
                    setState(2786);
                    {
                      auto childCtxHolder = ctx->EnterObjectName();
                      objectName(get_raw_pointer(childCtxHolder));
                    }
                    setState(2787);
                    if constexpr (has_OnToken<decltype(ctx)>::value) {
                      if (_input->LA(1) == GQLParser::PERIOD) {
                        ctx->OnToken(_input->LT(1));
                      }
                    }
                    match(GQLParser::PERIOD);
                    break;
                  }

            default:
              throw antlr4::NoViableAltException(this);
            }
            setState(2791); 
            _errHandler->sync(this);
            alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx);
          } while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* referenceParameterSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 572, GQLParser::RuleReferenceParameterSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2795);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SUBSTITUTED_PARAMETER_REFERENCE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SUBSTITUTED_PARAMETER_REFERENCE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nestedGraphTypeSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 574, GQLParser::RuleNestedGraphTypeSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2797);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(2798);
      {
        auto childCtxHolder = ctx->EnterGraphTypeSpecificationBody();
        graphTypeSpecificationBody(get_raw_pointer(childCtxHolder));
      }
      setState(2799);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphTypeSpecificationBody(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 576, GQLParser::RuleGraphTypeSpecificationBody);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2801);
      {
        auto childCtxHolder = ctx->EnterElementTypeList();
        elementTypeList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* elementTypeList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 578, GQLParser::RuleElementTypeList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2803);
      {
        auto childCtxHolder = ctx->EnterElementTypeSpecification();
        elementTypeSpecification(get_raw_pointer(childCtxHolder));
      }
      setState(2808);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(2804);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(2805);
        {
          auto childCtxHolder = ctx->EnterElementTypeSpecification();
          elementTypeSpecification(get_raw_pointer(childCtxHolder));
        }
        setState(2810);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* elementTypeSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 580, GQLParser::RuleElementTypeSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2813);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2811);
        {
          auto childCtxHolder = ctx->EnterNodeTypeSpecification();
          nodeTypeSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2812);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeSpecification();
          edgeTypeSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nodeTypeSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 582, GQLParser::RuleNodeTypeSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2817);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2815);
        {
          auto childCtxHolder = ctx->EnterNodeTypePattern();
          nodeTypePattern(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2816);
        {
          auto childCtxHolder = ctx->EnterNodeTypePhrase();
          nodeTypePhrase(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nodeTypePattern(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 584, GQLParser::RuleNodeTypePattern);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2825);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::NODE

      || _la == GQLParser::VERTEX) {
        setState(2819);
        {
          auto childCtxHolder = ctx->EnterNodeSynonym();
          nodeSynonym(get_raw_pointer(childCtxHolder));
        }
        setState(2821);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::TYPE) {
          setState(2820);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TYPE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TYPE);
        }
        setState(2823);
        {
          auto childCtxHolder = ctx->EnterNodeTypeName();
          nodeTypeName(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2827);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(2829);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx)) {
      case 1: {
        setState(2828);
        {
          auto childCtxHolder = ctx->EnterLocalNodeTypeAlias();
          localNodeTypeAlias(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2832);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IMPLIES || _la == GQLParser::IS || _la == GQLParser::LABEL

      || _la == GQLParser::LABELS || _la == GQLParser::COLON

      || _la == GQLParser::LEFT_BRACE) {
        setState(2831);
        {
          auto childCtxHolder = ctx->EnterNodeTypeFiller();
          nodeTypeFiller(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2834);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nodeTypePhrase(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 586, GQLParser::RuleNodeTypePhrase);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2836);
      {
        auto childCtxHolder = ctx->EnterNodeSynonym();
        nodeSynonym(get_raw_pointer(childCtxHolder));
      }
      setState(2838);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::TYPE) {
        setState(2837);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::TYPE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::TYPE);
      }
      setState(2840);
      {
        auto childCtxHolder = ctx->EnterNodeTypePhraseFiller();
        nodeTypePhraseFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2843);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 259, _ctx)) {
      case 1: {
        setState(2841);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::AS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::AS);
        setState(2842);
        {
          auto childCtxHolder = ctx->EnterLocalNodeTypeAlias();
          localNodeTypeAlias(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nodeTypePhraseFiller(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 588, GQLParser::RuleNodeTypePhraseFiller);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2850);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2845);
        {
          auto childCtxHolder = ctx->EnterNodeTypeName();
          nodeTypeName(get_raw_pointer(childCtxHolder));
        }
        setState(2847);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 260, _ctx)) {
        case 1: {
          setState(2846);
          {
            auto childCtxHolder = ctx->EnterNodeTypeFiller();
            nodeTypeFiller(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2849);
        {
          auto childCtxHolder = ctx->EnterNodeTypeFiller();
          nodeTypeFiller(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nodeTypeFiller(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 590, GQLParser::RuleNodeTypeFiller);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2857);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 263, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2852);
        {
          auto childCtxHolder = ctx->EnterNodeTypeKeyLabelSet();
          nodeTypeKeyLabelSet(get_raw_pointer(childCtxHolder));
        }
        setState(2854);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 262, _ctx)) {
        case 1: {
          setState(2853);
          {
            auto childCtxHolder = ctx->EnterNodeTypeImpliedContent();
            nodeTypeImpliedContent(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2856);
        {
          auto childCtxHolder = ctx->EnterNodeTypeImpliedContent();
          nodeTypeImpliedContent(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* localNodeTypeAlias(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 592, GQLParser::RuleLocalNodeTypeAlias);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2859);
      {
        auto childCtxHolder = ctx->EnterRegularIdentifier();
        regularIdentifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nodeTypeImpliedContent(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 594, GQLParser::RuleNodeTypeImpliedContent);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2866);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 264, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2861);
        {
          auto childCtxHolder = ctx->EnterNodeTypeLabelSet();
          nodeTypeLabelSet(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2862);
        {
          auto childCtxHolder = ctx->EnterNodeTypePropertyTypes();
          nodeTypePropertyTypes(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2863);
        {
          auto childCtxHolder = ctx->EnterNodeTypeLabelSet();
          nodeTypeLabelSet(get_raw_pointer(childCtxHolder));
        }
        setState(2864);
        {
          auto childCtxHolder = ctx->EnterNodeTypePropertyTypes();
          nodeTypePropertyTypes(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nodeTypeKeyLabelSet(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 596, GQLParser::RuleNodeTypeKeyLabelSet);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2869);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IS || _la == GQLParser::LABEL

      || _la == GQLParser::LABELS || _la == GQLParser::COLON) {
        setState(2868);
        {
          auto childCtxHolder = ctx->EnterLabelSetPhrase();
          labelSetPhrase(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2871);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IMPLIES) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IMPLIES);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nodeTypeLabelSet(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 598, GQLParser::RuleNodeTypeLabelSet);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2873);
      {
        auto childCtxHolder = ctx->EnterLabelSetPhrase();
        labelSetPhrase(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nodeTypePropertyTypes(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 600, GQLParser::RuleNodeTypePropertyTypes);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2875);
      {
        auto childCtxHolder = ctx->EnterPropertyTypesSpecification();
        propertyTypesSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeTypeSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 602, GQLParser::RuleEdgeTypeSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2879);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 266, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2877);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePattern();
          edgeTypePattern(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2878);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePhrase();
          edgeTypePhrase(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeTypePattern(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 604, GQLParser::RuleEdgeTypePattern);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2890);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 283) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 283)) & 68736253955) != 0)) {
        setState(2882);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::DIRECTED

        || _la == GQLParser::UNDIRECTED) {
          setState(2881);
          {
            auto childCtxHolder = ctx->EnterEdgeKind();
            edgeKind(get_raw_pointer(childCtxHolder));
          }
        }
        setState(2884);
        {
          auto childCtxHolder = ctx->EnterEdgeSynonym();
          edgeSynonym(get_raw_pointer(childCtxHolder));
        }
        setState(2886);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::TYPE) {
          setState(2885);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TYPE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TYPE);
        }
        setState(2888);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeName();
          edgeTypeName(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2894);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 270, _ctx)) {
      case 1: {
        setState(2892);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePatternDirected();
          edgeTypePatternDirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        setState(2893);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePatternUndirected();
          edgeTypePatternUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeTypePhrase(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 606, GQLParser::RuleEdgeTypePhrase);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2896);
      {
        auto childCtxHolder = ctx->EnterEdgeKind();
        edgeKind(get_raw_pointer(childCtxHolder));
      }
      setState(2897);
      {
        auto childCtxHolder = ctx->EnterEdgeSynonym();
        edgeSynonym(get_raw_pointer(childCtxHolder));
      }
      setState(2899);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::TYPE) {
        setState(2898);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::TYPE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::TYPE);
      }
      setState(2901);
      {
        auto childCtxHolder = ctx->EnterEdgeTypePhraseFiller();
        edgeTypePhraseFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2902);
      {
        auto childCtxHolder = ctx->EnterEndpointPairPhrase();
        endpointPairPhrase(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeTypePhraseFiller(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 608, GQLParser::RuleEdgeTypePhraseFiller);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2909);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 273, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2904);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeName();
          edgeTypeName(get_raw_pointer(childCtxHolder));
        }
        setState(2906);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::IMPLIES || _la == GQLParser::IS || _la == GQLParser::LABEL

        || _la == GQLParser::LABELS || _la == GQLParser::COLON

        || _la == GQLParser::LEFT_BRACE) {
          setState(2905);
          {
            auto childCtxHolder = ctx->EnterEdgeTypeFiller();
            edgeTypeFiller(get_raw_pointer(childCtxHolder));
          }
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2908);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeFiller();
          edgeTypeFiller(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeTypeFiller(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 610, GQLParser::RuleEdgeTypeFiller);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2916);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 275, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2911);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeKeyLabelSet();
          edgeTypeKeyLabelSet(get_raw_pointer(childCtxHolder));
        }
        setState(2913);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::IS || _la == GQLParser::LABEL

        || _la == GQLParser::LABELS || _la == GQLParser::COLON

        || _la == GQLParser::LEFT_BRACE) {
          setState(2912);
          {
            auto childCtxHolder = ctx->EnterEdgeTypeImpliedContent();
            edgeTypeImpliedContent(get_raw_pointer(childCtxHolder));
          }
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2915);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeImpliedContent();
          edgeTypeImpliedContent(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeTypeImpliedContent(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 612, GQLParser::RuleEdgeTypeImpliedContent);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2923);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 276, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2918);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeLabelSet();
          edgeTypeLabelSet(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2919);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePropertyTypes();
          edgeTypePropertyTypes(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2920);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeLabelSet();
          edgeTypeLabelSet(get_raw_pointer(childCtxHolder));
        }
        setState(2921);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePropertyTypes();
          edgeTypePropertyTypes(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeTypeKeyLabelSet(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 614, GQLParser::RuleEdgeTypeKeyLabelSet);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2926);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IS || _la == GQLParser::LABEL

      || _la == GQLParser::LABELS || _la == GQLParser::COLON) {
        setState(2925);
        {
          auto childCtxHolder = ctx->EnterLabelSetPhrase();
          labelSetPhrase(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2928);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IMPLIES) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IMPLIES);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeTypeLabelSet(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 616, GQLParser::RuleEdgeTypeLabelSet);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2930);
      {
        auto childCtxHolder = ctx->EnterLabelSetPhrase();
        labelSetPhrase(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeTypePropertyTypes(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 618, GQLParser::RuleEdgeTypePropertyTypes);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2932);
      {
        auto childCtxHolder = ctx->EnterPropertyTypesSpecification();
        propertyTypesSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeTypePatternDirected(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 620, GQLParser::RuleEdgeTypePatternDirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2936);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 278, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2934);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePatternPointingRight();
          edgeTypePatternPointingRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2935);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePatternPointingLeft();
          edgeTypePatternPointingLeft(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeTypePatternPointingRight(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 622, GQLParser::RuleEdgeTypePatternPointingRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2938);
      {
        auto childCtxHolder = ctx->EnterSourceNodeTypeReference();
        sourceNodeTypeReference(get_raw_pointer(childCtxHolder));
      }
      setState(2939);
      {
        auto childCtxHolder = ctx->EnterArcTypePointingRight();
        arcTypePointingRight(get_raw_pointer(childCtxHolder));
      }
      setState(2940);
      {
        auto childCtxHolder = ctx->EnterDestinationNodeTypeReference();
        destinationNodeTypeReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeTypePatternPointingLeft(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 624, GQLParser::RuleEdgeTypePatternPointingLeft);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2942);
      {
        auto childCtxHolder = ctx->EnterDestinationNodeTypeReference();
        destinationNodeTypeReference(get_raw_pointer(childCtxHolder));
      }
      setState(2943);
      {
        auto childCtxHolder = ctx->EnterArcTypePointingLeft();
        arcTypePointingLeft(get_raw_pointer(childCtxHolder));
      }
      setState(2944);
      {
        auto childCtxHolder = ctx->EnterSourceNodeTypeReference();
        sourceNodeTypeReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeTypePatternUndirected(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 626, GQLParser::RuleEdgeTypePatternUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2946);
      {
        auto childCtxHolder = ctx->EnterSourceNodeTypeReference();
        sourceNodeTypeReference(get_raw_pointer(childCtxHolder));
      }
      setState(2947);
      {
        auto childCtxHolder = ctx->EnterArcTypeUndirected();
        arcTypeUndirected(get_raw_pointer(childCtxHolder));
      }
      setState(2948);
      {
        auto childCtxHolder = ctx->EnterDestinationNodeTypeReference();
        destinationNodeTypeReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* arcTypePointingRight(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 628, GQLParser::RuleArcTypePointingRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2950);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MINUS_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MINUS_LEFT_BRACKET);
      setState(2951);
      {
        auto childCtxHolder = ctx->EnterEdgeTypeFiller();
        edgeTypeFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2952);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BRACKET_RIGHT_ARROW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BRACKET_RIGHT_ARROW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* arcTypePointingLeft(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 630, GQLParser::RuleArcTypePointingLeft);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2954);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ARROW_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ARROW_BRACKET);
      setState(2955);
      {
        auto childCtxHolder = ctx->EnterEdgeTypeFiller();
        edgeTypeFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2956);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_MINUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_MINUS);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* arcTypeUndirected(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 632, GQLParser::RuleArcTypeUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2958);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE_LEFT_BRACKET);
      setState(2959);
      {
        auto childCtxHolder = ctx->EnterEdgeTypeFiller();
        edgeTypeFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2960);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_TILDE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sourceNodeTypeReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 634, GQLParser::RuleSourceNodeTypeReference);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2971);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 280, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2962);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(2963);
        {
          auto childCtxHolder = ctx->EnterSourceNodeTypeAlias();
          sourceNodeTypeAlias(get_raw_pointer(childCtxHolder));
        }
        setState(2964);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2966);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(2968);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::IMPLIES || _la == GQLParser::IS || _la == GQLParser::LABEL

        || _la == GQLParser::LABELS || _la == GQLParser::COLON

        || _la == GQLParser::LEFT_BRACE) {
          setState(2967);
          {
            auto childCtxHolder = ctx->EnterNodeTypeFiller();
            nodeTypeFiller(get_raw_pointer(childCtxHolder));
          }
        }
        setState(2970);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* destinationNodeTypeReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 636, GQLParser::RuleDestinationNodeTypeReference);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2982);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 282, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2973);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(2974);
        {
          auto childCtxHolder = ctx->EnterDestinationNodeTypeAlias();
          destinationNodeTypeAlias(get_raw_pointer(childCtxHolder));
        }
        setState(2975);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2977);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(2979);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::IMPLIES || _la == GQLParser::IS || _la == GQLParser::LABEL

        || _la == GQLParser::LABELS || _la == GQLParser::COLON

        || _la == GQLParser::LEFT_BRACE) {
          setState(2978);
          {
            auto childCtxHolder = ctx->EnterNodeTypeFiller();
            nodeTypeFiller(get_raw_pointer(childCtxHolder));
          }
        }
        setState(2981);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeKind(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 638, GQLParser::RuleEdgeKind);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2984);
      _la = _input->LA(1);
      if (!(_la == GQLParser::DIRECTED

      || _la == GQLParser::UNDIRECTED)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* endpointPairPhrase(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 640, GQLParser::RuleEndpointPairPhrase);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2986);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CONNECTING) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CONNECTING);
      setState(2987);
      {
        auto childCtxHolder = ctx->EnterEndpointPair();
        endpointPair(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* endpointPair(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 642, GQLParser::RuleEndpointPair);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2991);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 283, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2989);
        {
          auto childCtxHolder = ctx->EnterEndpointPairDirected();
          endpointPairDirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2990);
        {
          auto childCtxHolder = ctx->EnterEndpointPairUndirected();
          endpointPairUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* endpointPairDirected(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 644, GQLParser::RuleEndpointPairDirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2995);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 284, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2993);
        {
          auto childCtxHolder = ctx->EnterEndpointPairPointingRight();
          endpointPairPointingRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2994);
        {
          auto childCtxHolder = ctx->EnterEndpointPairPointingLeft();
          endpointPairPointingLeft(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* endpointPairPointingRight(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 646, GQLParser::RuleEndpointPairPointingRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2997);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(2998);
      {
        auto childCtxHolder = ctx->EnterSourceNodeTypeAlias();
        sourceNodeTypeAlias(get_raw_pointer(childCtxHolder));
      }
      setState(2999);
      {
        auto childCtxHolder = ctx->EnterConnectorPointingRight();
        connectorPointingRight(get_raw_pointer(childCtxHolder));
      }
      setState(3000);
      {
        auto childCtxHolder = ctx->EnterDestinationNodeTypeAlias();
        destinationNodeTypeAlias(get_raw_pointer(childCtxHolder));
      }
      setState(3001);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* endpointPairPointingLeft(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 648, GQLParser::RuleEndpointPairPointingLeft);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3003);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3004);
      {
        auto childCtxHolder = ctx->EnterDestinationNodeTypeAlias();
        destinationNodeTypeAlias(get_raw_pointer(childCtxHolder));
      }
      setState(3005);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ARROW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ARROW);
      setState(3006);
      {
        auto childCtxHolder = ctx->EnterSourceNodeTypeAlias();
        sourceNodeTypeAlias(get_raw_pointer(childCtxHolder));
      }
      setState(3007);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* endpointPairUndirected(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 650, GQLParser::RuleEndpointPairUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3009);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3010);
      {
        auto childCtxHolder = ctx->EnterSourceNodeTypeAlias();
        sourceNodeTypeAlias(get_raw_pointer(childCtxHolder));
      }
      setState(3011);
      {
        auto childCtxHolder = ctx->EnterConnectorUndirected();
        connectorUndirected(get_raw_pointer(childCtxHolder));
      }
      setState(3012);
      {
        auto childCtxHolder = ctx->EnterDestinationNodeTypeAlias();
        destinationNodeTypeAlias(get_raw_pointer(childCtxHolder));
      }
      setState(3013);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* connectorPointingRight(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 652, GQLParser::RuleConnectorPointingRight);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3015);
      _la = _input->LA(1);
      if (!(_la == GQLParser::TO

      || _la == GQLParser::RIGHT_ARROW)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* connectorUndirected(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 654, GQLParser::RuleConnectorUndirected);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3017);
      _la = _input->LA(1);
      if (!(_la == GQLParser::TO || _la == GQLParser::TILDE)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sourceNodeTypeAlias(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 656, GQLParser::RuleSourceNodeTypeAlias);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3019);
      {
        auto childCtxHolder = ctx->EnterRegularIdentifier();
        regularIdentifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* destinationNodeTypeAlias(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 658, GQLParser::RuleDestinationNodeTypeAlias);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3021);
      {
        auto childCtxHolder = ctx->EnterRegularIdentifier();
        regularIdentifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* labelSetPhrase(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 660, GQLParser::RuleLabelSetPhrase);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3030);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LABEL: {
          enterOuterAlt(_localctx, 1);
          setState(3023);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LABEL) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LABEL);
          setState(3024);
          {
            auto childCtxHolder = ctx->EnterLabelName();
            labelName(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LABELS: {
          enterOuterAlt(_localctx, 2);
          setState(3025);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LABELS) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LABELS);
          setState(3026);
          {
            auto childCtxHolder = ctx->EnterLabelSetSpecification();
            labelSetSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::IS:
        case GQLParser::COLON: {
          enterOuterAlt(_localctx, 3);
          setState(3027);
          {
            auto childCtxHolder = ctx->EnterIsOrColon();
            isOrColon(get_raw_pointer(childCtxHolder));
          }
          setState(3028);
          {
            auto childCtxHolder = ctx->EnterLabelSetSpecification();
            labelSetSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* labelSetSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 662, GQLParser::RuleLabelSetSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(3032);
      {
        auto childCtxHolder = ctx->EnterLabelName();
        labelName(get_raw_pointer(childCtxHolder));
      }
      setState(3037);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 286, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3033);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::AMPERSAND) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::AMPERSAND);
          setState(3034);
          {
            auto childCtxHolder = ctx->EnterLabelName();
            labelName(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(3039);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 286, _ctx);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* propertyTypesSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 664, GQLParser::RulePropertyTypesSpecification);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3040);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(3042);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE

      || _la == GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0)) {
        setState(3041);
        {
          auto childCtxHolder = ctx->EnterPropertyTypeList();
          propertyTypeList(get_raw_pointer(childCtxHolder));
        }
      }
      setState(3044);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* propertyTypeList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 666, GQLParser::RulePropertyTypeList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3046);
      {
        auto childCtxHolder = ctx->EnterPropertyType();
        propertyType(get_raw_pointer(childCtxHolder));
      }
      setState(3051);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(3047);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(3048);
        {
          auto childCtxHolder = ctx->EnterPropertyType();
          propertyType(get_raw_pointer(childCtxHolder));
        }
        setState(3053);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* propertyType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 668, GQLParser::RulePropertyType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3054);
      {
        auto childCtxHolder = ctx->EnterPropertyName();
        propertyName(get_raw_pointer(childCtxHolder));
      }
      setState(3056);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
        setState(3055);
        {
          auto childCtxHolder = ctx->EnterTyped();
          typed(get_raw_pointer(childCtxHolder));
        }
      }
      setState(3058);
      {
        auto childCtxHolder = ctx->EnterPropertyValueType();
        propertyValueType(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* propertyValueType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 670, GQLParser::RulePropertyValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3060);
      {
        auto childCtxHolder = ctx->EnterValueType();
        valueType(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* bindingTableType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 672, GQLParser::RuleBindingTableType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3063);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::BINDING) {
        setState(3062);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::BINDING) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::BINDING);
      }
      setState(3065);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TABLE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TABLE);
      setState(3066);
      {
        auto childCtxHolder = ctx->EnterFieldTypesSpecification();
        fieldTypesSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }


  template<typename ContextT>
  antlr4::ParserRuleContext* valueType(ContextT* ctx) {
     return valueType(0, ctx);
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* valueType(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, parentState);
    antlr4::ParserRuleContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 674;
    enterRecursionRule(_localctx, 674, GQLParser::RuleValueType, precedence);

      size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(3125);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
      case 1: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterPredefinedTypeLabel();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });

        setState(3069);
        {
          auto childCtxHolder = ctx->EnterPredefinedType();
          predefinedType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterPathValueTypeLabel();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3070);
        {
          auto childCtxHolder = ctx->EnterPathValueType();
          pathValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterListValueTypeAlt1();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3071);
        {
          auto childCtxHolder = ctx->EnterListValueTypeName();
          listValueTypeName(get_raw_pointer(childCtxHolder));
        }
        setState(3072);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_ANGLE_BRACKET) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_ANGLE_BRACKET);
        setState(3073);
        {
          auto childCtxHolder = ctx->EnterValueType();
          valueType(0, get_raw_pointer(childCtxHolder));
        }
        setState(3074);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_ANGLE_BRACKET) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_ANGLE_BRACKET);
        setState(3079);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 291, _ctx)) {
        case 1: {
          setState(3075);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_BRACKET) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_BRACKET);
          setState(3076);
          {
            auto childCtxHolder = ctx->EnterMaxLength();
            maxLength(get_raw_pointer(childCtxHolder));
          }
          setState(3077);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_BRACKET) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_BRACKET);
          break;
        }

        default:
          break;
        }
        setState(3082);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 292, _ctx)) {
        case 1: {
          setState(3081);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 4: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterListValueTypeAlt3();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3084);
        {
          auto childCtxHolder = ctx->EnterListValueTypeName();
          listValueTypeName(get_raw_pointer(childCtxHolder));
        }
        setState(3089);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 293, _ctx)) {
        case 1: {
          setState(3085);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_BRACKET) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_BRACKET);
          setState(3086);
          {
            auto childCtxHolder = ctx->EnterMaxLength();
            maxLength(get_raw_pointer(childCtxHolder));
          }
          setState(3087);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_BRACKET) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_BRACKET);
          break;
        }

        default:
          break;
        }
        setState(3092);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 294, _ctx)) {
        case 1: {
          setState(3091);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 5: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterRecordTypeLabel();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3094);
        {
          auto childCtxHolder = ctx->EnterRecordType();
          recordType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterOpenDynamicUnionTypeLabel();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3095);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::ANY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::ANY);
        setState(3097);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 295, _ctx)) {
        case 1: {
          setState(3096);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::VALUE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::VALUE);
          break;
        }

        default:
          break;
        }
        setState(3100);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx)) {
        case 1: {
          setState(3099);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 7: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterDynamicPropertyValueTypeLabel();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3103);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::ANY) {
          setState(3102);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ANY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ANY);
        }
        setState(3105);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
        setState(3106);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::VALUE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::VALUE);
        setState(3108);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx)) {
        case 1: {
          setState(3107);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 8: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterClosedDynamicUnionTypeAtl1();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3110);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::ANY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::ANY);
        setState(3112);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::VALUE) {
          setState(3111);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::VALUE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::VALUE);
        }
        setState(3114);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_ANGLE_BRACKET) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_ANGLE_BRACKET);
        setState(3115);
        {
          auto childCtxHolder = ctx->EnterValueType();
          valueType(0, get_raw_pointer(childCtxHolder));
        }
        setState(3120);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == GQLParser::VERTICAL_BAR) {
          setState(3116);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::VERTICAL_BAR) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::VERTICAL_BAR);
          setState(3117);
          {
            auto childCtxHolder = ctx->EnterValueType();
            valueType(0, get_raw_pointer(childCtxHolder));
          }
          setState(3122);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(3123);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_ANGLE_BRACKET) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_ANGLE_BRACKET);
        break;
      }

      default:
        break;
      }
      _ctx->stop = _input->LT(-1);
      setState(3143);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 305, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          setState(3141);
          _errHandler->sync(this);
          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 304, _ctx)) {
          case 1: {
            auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
            auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
            newContext->copyFrom(newParentContext);
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueType);
            auto ctxHolder = ctx->PushClosedDynamicUnionTypeAtl2_ValueType();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3127);

            if (!(precpred(_ctx, 1))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 1)");
            setState(3128);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::VERTICAL_BAR) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::VERTICAL_BAR);
            setState(3129);
            {
              auto childCtxHolder = ctx->EnterValueType();
              valueType(2, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 2: {
            auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
            auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
            newContext->copyFrom(newParentContext);
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueType);
            auto ctxHolder = ctx->PushListValueTypeAlt2_ValueType();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3130);

            if (!(precpred(_ctx, 7))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 7)");
            setState(3131);
            {
              auto childCtxHolder = ctx->EnterListValueTypeName();
              listValueTypeName(get_raw_pointer(childCtxHolder));
            }
            setState(3136);
            _errHandler->sync(this);

            switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 302, _ctx)) {
            case 1: {
              setState(3132);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::LEFT_BRACKET) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::LEFT_BRACKET);
              setState(3133);
              {
                auto childCtxHolder = ctx->EnterMaxLength();
                maxLength(get_raw_pointer(childCtxHolder));
              }
              setState(3134);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::RIGHT_BRACKET) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::RIGHT_BRACKET);
              break;
            }

            default:
              break;
            }
            setState(3139);
            _errHandler->sync(this);

            switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx)) {
            case 1: {
              setState(3138);
              {
                auto childCtxHolder = ctx->EnterNotNull();
                notNull(get_raw_pointer(childCtxHolder));
              }
              break;
            }

            default:
              break;
            }
            break;
          }

          default:
            break;
          } 
        }
        setState(3145);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 305, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* typed(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 676, GQLParser::RuleTyped);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3146);
      _la = _input->LA(1);
      if (!(_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* predefinedType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 678, GQLParser::RulePredefinedType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3155);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BOOL:
        case GQLParser::BOOLEAN: {
          enterOuterAlt(_localctx, 1);
          setState(3148);
          {
            auto childCtxHolder = ctx->EnterBooleanType();
            booleanType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CHAR:
        case GQLParser::STRING:
        case GQLParser::VARCHAR: {
          enterOuterAlt(_localctx, 2);
          setState(3149);
          {
            auto childCtxHolder = ctx->EnterCharacterStringType();
            characterStringType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BINARY:
        case GQLParser::BYTES:
        case GQLParser::VARBINARY: {
          enterOuterAlt(_localctx, 3);
          setState(3150);
          {
            auto childCtxHolder = ctx->EnterByteStringType();
            byteStringType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BIG:
        case GQLParser::BIGINT:
        case GQLParser::DEC:
        case GQLParser::DECIMAL:
        case GQLParser::DOUBLE:
        case GQLParser::FLOAT:
        case GQLParser::FLOAT16:
        case GQLParser::FLOAT32:
        case GQLParser::FLOAT64:
        case GQLParser::FLOAT128:
        case GQLParser::FLOAT256:
        case GQLParser::INT:
        case GQLParser::INTEGER:
        case GQLParser::INT8:
        case GQLParser::INTEGER8:
        case GQLParser::INT16:
        case GQLParser::INTEGER16:
        case GQLParser::INT32:
        case GQLParser::INTEGER32:
        case GQLParser::INT64:
        case GQLParser::INTEGER64:
        case GQLParser::INT128:
        case GQLParser::INTEGER128:
        case GQLParser::INT256:
        case GQLParser::INTEGER256:
        case GQLParser::REAL:
        case GQLParser::SIGNED:
        case GQLParser::SMALL:
        case GQLParser::SMALLINT:
        case GQLParser::UBIGINT:
        case GQLParser::UINT:
        case GQLParser::UINT8:
        case GQLParser::UINT16:
        case GQLParser::UINT32:
        case GQLParser::UINT64:
        case GQLParser::UINT128:
        case GQLParser::UINT256:
        case GQLParser::UNSIGNED:
        case GQLParser::USMALLINT: {
          enterOuterAlt(_localctx, 4);
          setState(3151);
          {
            auto childCtxHolder = ctx->EnterNumericType();
            numericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DATE:
        case GQLParser::DURATION:
        case GQLParser::LOCAL:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::ZONED: {
          enterOuterAlt(_localctx, 5);
          setState(3152);
          {
            auto childCtxHolder = ctx->EnterTemporalType();
            temporalType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ANY:
        case GQLParser::BINDING:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::GRAPH:
        case GQLParser::NODE:
        case GQLParser::PROPERTY:
        case GQLParser::RELATIONSHIP:
        case GQLParser::TABLE:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::LEFT_PAREN: {
          enterOuterAlt(_localctx, 6);
          setState(3153);
          {
            auto childCtxHolder = ctx->EnterReferenceValueType();
            referenceValueType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::NOTHING:
        case GQLParser::NULL_KW: {
          enterOuterAlt(_localctx, 7);
          setState(3154);
          {
            auto childCtxHolder = ctx->EnterImmaterialValueType();
            immaterialValueType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* booleanType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 680, GQLParser::RuleBooleanType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3157);
      _la = _input->LA(1);
      if (!(_la == GQLParser::BOOL

      || _la == GQLParser::BOOLEAN)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(3159);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 307, _ctx)) {
      case 1: {
        setState(3158);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* characterStringType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 682, GQLParser::RuleCharacterStringType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3196);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::STRING: {
          enterOuterAlt(_localctx, 1);
          setState(3161);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::STRING) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::STRING);
          setState(3171);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
          case 1: {
            setState(3162);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3166);
            _errHandler->sync(this);

            switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 308, _ctx)) {
            case 1: {
              setState(3163);
              {
                auto childCtxHolder = ctx->EnterMinLength();
                minLength(get_raw_pointer(childCtxHolder));
              }
              setState(3164);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::COMMA) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::COMMA);
              break;
            }

            default:
              break;
            }
            setState(3168);
            {
              auto childCtxHolder = ctx->EnterMaxLength();
              maxLength(get_raw_pointer(childCtxHolder));
            }
            setState(3169);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3174);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx)) {
          case 1: {
            setState(3173);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::CHAR: {
          enterOuterAlt(_localctx, 2);
          setState(3176);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::CHAR) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::CHAR);
          setState(3181);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 311, _ctx)) {
          case 1: {
            setState(3177);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3178);
            {
              auto childCtxHolder = ctx->EnterFixedLength();
              fixedLength(get_raw_pointer(childCtxHolder));
            }
            setState(3179);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3184);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 312, _ctx)) {
          case 1: {
            setState(3183);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::VARCHAR: {
          enterOuterAlt(_localctx, 3);
          setState(3186);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::VARCHAR) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::VARCHAR);
          setState(3191);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 313, _ctx)) {
          case 1: {
            setState(3187);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3188);
            {
              auto childCtxHolder = ctx->EnterMaxLength();
              maxLength(get_raw_pointer(childCtxHolder));
            }
            setState(3189);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3194);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 314, _ctx)) {
          case 1: {
            setState(3193);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* byteStringType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 684, GQLParser::RuleByteStringType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3233);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BYTES: {
          enterOuterAlt(_localctx, 1);
          setState(3198);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::BYTES) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::BYTES);
          setState(3208);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 317, _ctx)) {
          case 1: {
            setState(3199);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3203);
            _errHandler->sync(this);

            switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 316, _ctx)) {
            case 1: {
              setState(3200);
              {
                auto childCtxHolder = ctx->EnterMinLength();
                minLength(get_raw_pointer(childCtxHolder));
              }
              setState(3201);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::COMMA) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::COMMA);
              break;
            }

            default:
              break;
            }
            setState(3205);
            {
              auto childCtxHolder = ctx->EnterMaxLength();
              maxLength(get_raw_pointer(childCtxHolder));
            }
            setState(3206);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3211);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 318, _ctx)) {
          case 1: {
            setState(3210);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::BINARY: {
          enterOuterAlt(_localctx, 2);
          setState(3213);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::BINARY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::BINARY);
          setState(3218);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 319, _ctx)) {
          case 1: {
            setState(3214);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3215);
            {
              auto childCtxHolder = ctx->EnterFixedLength();
              fixedLength(get_raw_pointer(childCtxHolder));
            }
            setState(3216);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3221);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 320, _ctx)) {
          case 1: {
            setState(3220);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::VARBINARY: {
          enterOuterAlt(_localctx, 3);
          setState(3223);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::VARBINARY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::VARBINARY);
          setState(3228);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 321, _ctx)) {
          case 1: {
            setState(3224);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3225);
            {
              auto childCtxHolder = ctx->EnterMaxLength();
              maxLength(get_raw_pointer(childCtxHolder));
            }
            setState(3226);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3231);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx)) {
          case 1: {
            setState(3230);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* minLength(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 686, GQLParser::RuleMinLength);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3235);
      {
        auto childCtxHolder = ctx->EnterUnsignedInteger();
        unsignedInteger(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* maxLength(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 688, GQLParser::RuleMaxLength);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3237);
      {
        auto childCtxHolder = ctx->EnterUnsignedInteger();
        unsignedInteger(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fixedLength(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 690, GQLParser::RuleFixedLength);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3239);
      {
        auto childCtxHolder = ctx->EnterUnsignedInteger();
        unsignedInteger(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* numericType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 692, GQLParser::RuleNumericType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3243);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BIG:
        case GQLParser::BIGINT:
        case GQLParser::DEC:
        case GQLParser::DECIMAL:
        case GQLParser::INT:
        case GQLParser::INTEGER:
        case GQLParser::INT8:
        case GQLParser::INTEGER8:
        case GQLParser::INT16:
        case GQLParser::INTEGER16:
        case GQLParser::INT32:
        case GQLParser::INTEGER32:
        case GQLParser::INT64:
        case GQLParser::INTEGER64:
        case GQLParser::INT128:
        case GQLParser::INTEGER128:
        case GQLParser::INT256:
        case GQLParser::INTEGER256:
        case GQLParser::SIGNED:
        case GQLParser::SMALL:
        case GQLParser::SMALLINT:
        case GQLParser::UBIGINT:
        case GQLParser::UINT:
        case GQLParser::UINT8:
        case GQLParser::UINT16:
        case GQLParser::UINT32:
        case GQLParser::UINT64:
        case GQLParser::UINT128:
        case GQLParser::UINT256:
        case GQLParser::UNSIGNED:
        case GQLParser::USMALLINT: {
          enterOuterAlt(_localctx, 1);
          setState(3241);
          {
            auto childCtxHolder = ctx->EnterExactNumericType();
            exactNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DOUBLE:
        case GQLParser::FLOAT:
        case GQLParser::FLOAT16:
        case GQLParser::FLOAT32:
        case GQLParser::FLOAT64:
        case GQLParser::FLOAT128:
        case GQLParser::FLOAT256:
        case GQLParser::REAL: {
          enterOuterAlt(_localctx, 2);
          setState(3242);
          {
            auto childCtxHolder = ctx->EnterApproximateNumericType();
            approximateNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* exactNumericType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 694, GQLParser::RuleExactNumericType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3247);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BIG:
        case GQLParser::BIGINT:
        case GQLParser::INT:
        case GQLParser::INTEGER:
        case GQLParser::INT8:
        case GQLParser::INTEGER8:
        case GQLParser::INT16:
        case GQLParser::INTEGER16:
        case GQLParser::INT32:
        case GQLParser::INTEGER32:
        case GQLParser::INT64:
        case GQLParser::INTEGER64:
        case GQLParser::INT128:
        case GQLParser::INTEGER128:
        case GQLParser::INT256:
        case GQLParser::INTEGER256:
        case GQLParser::SIGNED:
        case GQLParser::SMALL:
        case GQLParser::SMALLINT:
        case GQLParser::UBIGINT:
        case GQLParser::UINT:
        case GQLParser::UINT8:
        case GQLParser::UINT16:
        case GQLParser::UINT32:
        case GQLParser::UINT64:
        case GQLParser::UINT128:
        case GQLParser::UINT256:
        case GQLParser::UNSIGNED:
        case GQLParser::USMALLINT: {
          enterOuterAlt(_localctx, 1);
          setState(3245);
          {
            auto childCtxHolder = ctx->EnterBinaryExactNumericType();
            binaryExactNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DEC:
        case GQLParser::DECIMAL: {
          enterOuterAlt(_localctx, 2);
          setState(3246);
          {
            auto childCtxHolder = ctx->EnterDecimalExactNumericType();
            decimalExactNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* binaryExactNumericType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 696, GQLParser::RuleBinaryExactNumericType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3251);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BIG:
        case GQLParser::BIGINT:
        case GQLParser::INT:
        case GQLParser::INTEGER:
        case GQLParser::INT8:
        case GQLParser::INTEGER8:
        case GQLParser::INT16:
        case GQLParser::INTEGER16:
        case GQLParser::INT32:
        case GQLParser::INTEGER32:
        case GQLParser::INT64:
        case GQLParser::INTEGER64:
        case GQLParser::INT128:
        case GQLParser::INTEGER128:
        case GQLParser::INT256:
        case GQLParser::INTEGER256:
        case GQLParser::SIGNED:
        case GQLParser::SMALL:
        case GQLParser::SMALLINT: {
          enterOuterAlt(_localctx, 1);
          setState(3249);
          {
            auto childCtxHolder = ctx->EnterSignedBinaryExactNumericType();
            signedBinaryExactNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::UBIGINT:
        case GQLParser::UINT:
        case GQLParser::UINT8:
        case GQLParser::UINT16:
        case GQLParser::UINT32:
        case GQLParser::UINT64:
        case GQLParser::UINT128:
        case GQLParser::UINT256:
        case GQLParser::UNSIGNED:
        case GQLParser::USMALLINT: {
          enterOuterAlt(_localctx, 2);
          setState(3250);
          {
            auto childCtxHolder = ctx->EnterUnsignedBinaryExactNumericType();
            unsignedBinaryExactNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* signedBinaryExactNumericType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 698, GQLParser::RuleSignedBinaryExactNumericType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3299);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::INT8: {
          enterOuterAlt(_localctx, 1);
          setState(3253);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INT8) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INT8);
          setState(3255);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 327, _ctx)) {
          case 1: {
            setState(3254);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INT16: {
          enterOuterAlt(_localctx, 2);
          setState(3257);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INT16) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INT16);
          setState(3259);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 328, _ctx)) {
          case 1: {
            setState(3258);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INT32: {
          enterOuterAlt(_localctx, 3);
          setState(3261);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INT32) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INT32);
          setState(3263);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 329, _ctx)) {
          case 1: {
            setState(3262);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INT64: {
          enterOuterAlt(_localctx, 4);
          setState(3265);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INT64) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INT64);
          setState(3267);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 330, _ctx)) {
          case 1: {
            setState(3266);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INT128: {
          enterOuterAlt(_localctx, 5);
          setState(3269);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INT128) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INT128);
          setState(3271);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 331, _ctx)) {
          case 1: {
            setState(3270);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INT256: {
          enterOuterAlt(_localctx, 6);
          setState(3273);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INT256) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INT256);
          setState(3275);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 332, _ctx)) {
          case 1: {
            setState(3274);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::SMALLINT: {
          enterOuterAlt(_localctx, 7);
          setState(3277);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::SMALLINT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::SMALLINT);
          setState(3279);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 333, _ctx)) {
          case 1: {
            setState(3278);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INT: {
          enterOuterAlt(_localctx, 8);
          setState(3281);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INT);
          setState(3286);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 334, _ctx)) {
          case 1: {
            setState(3282);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3283);
            {
              auto childCtxHolder = ctx->EnterPrecision();
              precision(get_raw_pointer(childCtxHolder));
            }
            setState(3284);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3289);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 335, _ctx)) {
          case 1: {
            setState(3288);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::BIGINT: {
          enterOuterAlt(_localctx, 9);
          setState(3291);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::BIGINT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::BIGINT);
          setState(3293);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 336, _ctx)) {
          case 1: {
            setState(3292);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::BIG:
        case GQLParser::INTEGER:
        case GQLParser::INTEGER8:
        case GQLParser::INTEGER16:
        case GQLParser::INTEGER32:
        case GQLParser::INTEGER64:
        case GQLParser::INTEGER128:
        case GQLParser::INTEGER256:
        case GQLParser::SIGNED:
        case GQLParser::SMALL: {
          enterOuterAlt(_localctx, 10);
          setState(3296);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::SIGNED) {
            setState(3295);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::SIGNED) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::SIGNED);
          }
          setState(3298);
          {
            auto childCtxHolder = ctx->EnterVerboseBinaryExactNumericType();
            verboseBinaryExactNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* unsignedBinaryExactNumericType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 700, GQLParser::RuleUnsignedBinaryExactNumericType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3345);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::UINT8: {
          enterOuterAlt(_localctx, 1);
          setState(3301);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UINT8) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UINT8);
          setState(3303);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx)) {
          case 1: {
            setState(3302);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UINT16: {
          enterOuterAlt(_localctx, 2);
          setState(3305);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UINT16) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UINT16);
          setState(3307);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx)) {
          case 1: {
            setState(3306);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UINT32: {
          enterOuterAlt(_localctx, 3);
          setState(3309);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UINT32) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UINT32);
          setState(3311);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx)) {
          case 1: {
            setState(3310);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UINT64: {
          enterOuterAlt(_localctx, 4);
          setState(3313);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UINT64) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UINT64);
          setState(3315);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 342, _ctx)) {
          case 1: {
            setState(3314);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UINT128: {
          enterOuterAlt(_localctx, 5);
          setState(3317);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UINT128) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UINT128);
          setState(3319);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx)) {
          case 1: {
            setState(3318);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UINT256: {
          enterOuterAlt(_localctx, 6);
          setState(3321);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UINT256) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UINT256);
          setState(3323);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx)) {
          case 1: {
            setState(3322);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::USMALLINT: {
          enterOuterAlt(_localctx, 7);
          setState(3325);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::USMALLINT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::USMALLINT);
          setState(3327);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 345, _ctx)) {
          case 1: {
            setState(3326);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UINT: {
          enterOuterAlt(_localctx, 8);
          setState(3329);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UINT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UINT);
          setState(3334);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 346, _ctx)) {
          case 1: {
            setState(3330);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3331);
            {
              auto childCtxHolder = ctx->EnterPrecision();
              precision(get_raw_pointer(childCtxHolder));
            }
            setState(3332);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3337);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 347, _ctx)) {
          case 1: {
            setState(3336);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UBIGINT: {
          enterOuterAlt(_localctx, 9);
          setState(3339);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UBIGINT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UBIGINT);
          setState(3341);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 348, _ctx)) {
          case 1: {
            setState(3340);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UNSIGNED: {
          enterOuterAlt(_localctx, 10);
          setState(3343);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UNSIGNED) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UNSIGNED);
          setState(3344);
          {
            auto childCtxHolder = ctx->EnterVerboseBinaryExactNumericType();
            verboseBinaryExactNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* verboseBinaryExactNumericType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 702, GQLParser::RuleVerboseBinaryExactNumericType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3391);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::INTEGER8: {
          enterOuterAlt(_localctx, 1);
          setState(3347);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER8) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER8);
          setState(3349);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 350, _ctx)) {
          case 1: {
            setState(3348);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INTEGER16: {
          enterOuterAlt(_localctx, 2);
          setState(3351);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER16) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER16);
          setState(3353);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 351, _ctx)) {
          case 1: {
            setState(3352);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INTEGER32: {
          enterOuterAlt(_localctx, 3);
          setState(3355);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER32) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER32);
          setState(3357);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 352, _ctx)) {
          case 1: {
            setState(3356);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INTEGER64: {
          enterOuterAlt(_localctx, 4);
          setState(3359);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER64) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER64);
          setState(3361);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 353, _ctx)) {
          case 1: {
            setState(3360);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INTEGER128: {
          enterOuterAlt(_localctx, 5);
          setState(3363);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER128) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER128);
          setState(3365);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 354, _ctx)) {
          case 1: {
            setState(3364);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INTEGER256: {
          enterOuterAlt(_localctx, 6);
          setState(3367);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER256) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER256);
          setState(3369);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 355, _ctx)) {
          case 1: {
            setState(3368);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::SMALL: {
          enterOuterAlt(_localctx, 7);
          setState(3371);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::SMALL) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::SMALL);
          setState(3372);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER);
          setState(3374);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 356, _ctx)) {
          case 1: {
            setState(3373);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INTEGER: {
          enterOuterAlt(_localctx, 8);
          setState(3376);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER);
          setState(3381);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 357, _ctx)) {
          case 1: {
            setState(3377);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3378);
            {
              auto childCtxHolder = ctx->EnterPrecision();
              precision(get_raw_pointer(childCtxHolder));
            }
            setState(3379);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3384);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 358, _ctx)) {
          case 1: {
            setState(3383);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::BIG: {
          enterOuterAlt(_localctx, 9);
          setState(3386);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::BIG) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::BIG);
          setState(3387);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER);
          setState(3389);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 359, _ctx)) {
          case 1: {
            setState(3388);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* decimalExactNumericType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 704, GQLParser::RuleDecimalExactNumericType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3393);
      _la = _input->LA(1);
      if (!(_la == GQLParser::DEC

      || _la == GQLParser::DECIMAL)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(3404);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 363, _ctx)) {
      case 1: {
        setState(3394);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(3395);
        {
          auto childCtxHolder = ctx->EnterPrecision();
          precision(get_raw_pointer(childCtxHolder));
        }
        setState(3398);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::COMMA) {
          setState(3396);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COMMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COMMA);
          setState(3397);
          {
            auto childCtxHolder = ctx->EnterScale();
            scale(get_raw_pointer(childCtxHolder));
          }
        }
        setState(3400);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        setState(3402);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 362, _ctx)) {
        case 1: {
          setState(3401);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* precision(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 706, GQLParser::RulePrecision);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3406);
      {
        auto childCtxHolder = ctx->EnterUnsignedDecimalInteger();
        unsignedDecimalInteger(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* scale(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 708, GQLParser::RuleScale);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3408);
      {
        auto childCtxHolder = ctx->EnterUnsignedDecimalInteger();
        unsignedDecimalInteger(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* approximateNumericType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 710, GQLParser::RuleApproximateNumericType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3455);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::FLOAT16: {
          enterOuterAlt(_localctx, 1);
          setState(3410);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::FLOAT16) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::FLOAT16);
          setState(3412);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 364, _ctx)) {
          case 1: {
            setState(3411);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::FLOAT32: {
          enterOuterAlt(_localctx, 2);
          setState(3414);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::FLOAT32) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::FLOAT32);
          setState(3416);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 365, _ctx)) {
          case 1: {
            setState(3415);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::FLOAT64: {
          enterOuterAlt(_localctx, 3);
          setState(3418);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::FLOAT64) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::FLOAT64);
          setState(3420);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 366, _ctx)) {
          case 1: {
            setState(3419);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::FLOAT128: {
          enterOuterAlt(_localctx, 4);
          setState(3422);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::FLOAT128) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::FLOAT128);
          setState(3424);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 367, _ctx)) {
          case 1: {
            setState(3423);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::FLOAT256: {
          enterOuterAlt(_localctx, 5);
          setState(3426);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::FLOAT256) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::FLOAT256);
          setState(3428);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 368, _ctx)) {
          case 1: {
            setState(3427);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::FLOAT: {
          enterOuterAlt(_localctx, 6);
          setState(3430);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::FLOAT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::FLOAT);
          setState(3439);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 370, _ctx)) {
          case 1: {
            setState(3431);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3432);
            {
              auto childCtxHolder = ctx->EnterPrecision();
              precision(get_raw_pointer(childCtxHolder));
            }
            setState(3435);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == GQLParser::COMMA) {
              setState(3433);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::COMMA) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::COMMA);
              setState(3434);
              {
                auto childCtxHolder = ctx->EnterScale();
                scale(get_raw_pointer(childCtxHolder));
              }
            }
            setState(3437);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3442);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 371, _ctx)) {
          case 1: {
            setState(3441);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::REAL: {
          enterOuterAlt(_localctx, 7);
          setState(3444);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::REAL) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::REAL);
          setState(3446);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 372, _ctx)) {
          case 1: {
            setState(3445);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::DOUBLE: {
          enterOuterAlt(_localctx, 8);
          setState(3448);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::DOUBLE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::DOUBLE);
          setState(3450);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 373, _ctx)) {
          case 1: {
            setState(3449);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PRECISION) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PRECISION);
            break;
          }

          default:
            break;
          }
          setState(3453);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 374, _ctx)) {
          case 1: {
            setState(3452);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* temporalType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 712, GQLParser::RuleTemporalType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3459);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::DATE:
        case GQLParser::LOCAL:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::ZONED: {
          enterOuterAlt(_localctx, 1);
          setState(3457);
          {
            auto childCtxHolder = ctx->EnterTemporalInstantType();
            temporalInstantType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DURATION: {
          enterOuterAlt(_localctx, 2);
          setState(3458);
          {
            auto childCtxHolder = ctx->EnterTemporalDurationType();
            temporalDurationType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* temporalInstantType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 714, GQLParser::RuleTemporalInstantType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3466);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 377, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3461);
        {
          auto childCtxHolder = ctx->EnterDatetimeType();
          datetimeType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3462);
        {
          auto childCtxHolder = ctx->EnterLocaldatetimeType();
          localdatetimeType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3463);
        {
          auto childCtxHolder = ctx->EnterDateType();
          dateType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(3464);
        {
          auto childCtxHolder = ctx->EnterTimeType();
          timeType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(3465);
        {
          auto childCtxHolder = ctx->EnterLocaltimeType();
          localtimeType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* datetimeType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 716, GQLParser::RuleDatetimeType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3480);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ZONED: {
          enterOuterAlt(_localctx, 1);
          setState(3468);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONED) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONED);
          setState(3469);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::DATETIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::DATETIME);
          setState(3471);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 378, _ctx)) {
          case 1: {
            setState(3470);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::TIMESTAMP: {
          enterOuterAlt(_localctx, 2);
          setState(3473);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIMESTAMP) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIMESTAMP);
          setState(3474);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::WITH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::WITH);
          setState(3475);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(3476);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONE);
          setState(3478);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 379, _ctx)) {
          case 1: {
            setState(3477);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* localdatetimeType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 718, GQLParser::RuleLocaldatetimeType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3496);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LOCAL: {
          enterOuterAlt(_localctx, 1);
          setState(3482);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LOCAL) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LOCAL);
          setState(3483);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::DATETIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::DATETIME);
          setState(3485);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 381, _ctx)) {
          case 1: {
            setState(3484);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::TIMESTAMP: {
          enterOuterAlt(_localctx, 2);
          setState(3487);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIMESTAMP) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIMESTAMP);
          setState(3491);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 382, _ctx)) {
          case 1: {
            setState(3488);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::WITHOUT) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::WITHOUT);
            setState(3489);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::TIME) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::TIME);
            setState(3490);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::ZONE) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::ZONE);
            break;
          }

          default:
            break;
          }
          setState(3494);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 383, _ctx)) {
          case 1: {
            setState(3493);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* dateType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 720, GQLParser::RuleDateType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3498);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DATE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DATE);
      setState(3500);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 385, _ctx)) {
      case 1: {
        setState(3499);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* timeType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 722, GQLParser::RuleTimeType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3514);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ZONED: {
          enterOuterAlt(_localctx, 1);
          setState(3502);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONED) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONED);
          setState(3503);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(3505);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 386, _ctx)) {
          case 1: {
            setState(3504);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::TIME: {
          enterOuterAlt(_localctx, 2);
          setState(3507);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(3508);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::WITH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::WITH);
          setState(3509);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(3510);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONE);
          setState(3512);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 387, _ctx)) {
          case 1: {
            setState(3511);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* localtimeType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 724, GQLParser::RuleLocaltimeType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3528);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LOCAL: {
          enterOuterAlt(_localctx, 1);
          setState(3516);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LOCAL) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LOCAL);
          setState(3517);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(3519);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 389, _ctx)) {
          case 1: {
            setState(3518);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::TIME: {
          enterOuterAlt(_localctx, 2);
          setState(3521);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(3522);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::WITHOUT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::WITHOUT);
          setState(3523);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(3524);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONE);
          setState(3526);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 390, _ctx)) {
          case 1: {
            setState(3525);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* temporalDurationType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 726, GQLParser::RuleTemporalDurationType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3530);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DURATION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DURATION);
      setState(3531);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3532);
      {
        auto childCtxHolder = ctx->EnterTemporalDurationQualifier();
        temporalDurationQualifier(get_raw_pointer(childCtxHolder));
      }
      setState(3533);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
      setState(3535);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 392, _ctx)) {
      case 1: {
        setState(3534);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* temporalDurationQualifier(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 728, GQLParser::RuleTemporalDurationQualifier);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3543);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::YEAR: {
          enterOuterAlt(_localctx, 1);
          setState(3537);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::YEAR) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::YEAR);
          setState(3538);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TO) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TO);
          setState(3539);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::MONTH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::MONTH);
          break;
        }

        case GQLParser::DAY: {
          enterOuterAlt(_localctx, 2);
          setState(3540);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::DAY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::DAY);
          setState(3541);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TO) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TO);
          setState(3542);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::SECOND) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::SECOND);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* referenceValueType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 730, GQLParser::RuleReferenceValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3549);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 394, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3545);
        {
          auto childCtxHolder = ctx->EnterGraphReferenceValueType();
          graphReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3546);
        {
          auto childCtxHolder = ctx->EnterBindingTableReferenceValueType();
          bindingTableReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3547);
        {
          auto childCtxHolder = ctx->EnterNodeReferenceValueType();
          nodeReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(3548);
        {
          auto childCtxHolder = ctx->EnterEdgeReferenceValueType();
          edgeReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* immaterialValueType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 732, GQLParser::RuleImmaterialValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3553);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 395, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3551);
        {
          auto childCtxHolder = ctx->EnterNullType();
          nullType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3552);
        {
          auto childCtxHolder = ctx->EnterEmptyType();
          emptyType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nullType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 734, GQLParser::RuleNullType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3555);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NULL_KW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NULL_KW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* emptyType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 736, GQLParser::RuleEmptyType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3560);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::NULL_KW: {
          enterOuterAlt(_localctx, 1);
          setState(3557);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::NULL_KW) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::NULL_KW);
          setState(3558);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::NOTHING: {
          enterOuterAlt(_localctx, 2);
          setState(3559);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::NOTHING) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::NOTHING);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphReferenceValueType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 738, GQLParser::RuleGraphReferenceValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3564);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ANY: {
          enterOuterAlt(_localctx, 1);
          setState(3562);
          {
            auto childCtxHolder = ctx->EnterOpenGraphReferenceValueType();
            openGraphReferenceValueType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::GRAPH:
        case GQLParser::PROPERTY: {
          enterOuterAlt(_localctx, 2);
          setState(3563);
          {
            auto childCtxHolder = ctx->EnterClosedGraphReferenceValueType();
            closedGraphReferenceValueType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* closedGraphReferenceValueType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 740, GQLParser::RuleClosedGraphReferenceValueType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3567);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PROPERTY) {
        setState(3566);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
      }
      setState(3569);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GRAPH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GRAPH);
      setState(3570);
      {
        auto childCtxHolder = ctx->EnterNestedGraphTypeSpecification();
        nestedGraphTypeSpecification(get_raw_pointer(childCtxHolder));
      }
      setState(3572);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 399, _ctx)) {
      case 1: {
        setState(3571);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* openGraphReferenceValueType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 742, GQLParser::RuleOpenGraphReferenceValueType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3574);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ANY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ANY);
      setState(3576);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PROPERTY) {
        setState(3575);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
      }
      setState(3578);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GRAPH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GRAPH);
      setState(3580);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 401, _ctx)) {
      case 1: {
        setState(3579);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* bindingTableReferenceValueType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 744, GQLParser::RuleBindingTableReferenceValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3582);
      {
        auto childCtxHolder = ctx->EnterBindingTableType();
        bindingTableType(get_raw_pointer(childCtxHolder));
      }
      setState(3584);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 402, _ctx)) {
      case 1: {
        setState(3583);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nodeReferenceValueType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 746, GQLParser::RuleNodeReferenceValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3588);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 403, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3586);
        {
          auto childCtxHolder = ctx->EnterOpenNodeReferenceValueType();
          openNodeReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3587);
        {
          auto childCtxHolder = ctx->EnterClosedNodeReferenceValueType();
          closedNodeReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* closedNodeReferenceValueType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 748, GQLParser::RuleClosedNodeReferenceValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3590);
      {
        auto childCtxHolder = ctx->EnterNodeTypeSpecification();
        nodeTypeSpecification(get_raw_pointer(childCtxHolder));
      }
      setState(3592);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 404, _ctx)) {
      case 1: {
        setState(3591);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* openNodeReferenceValueType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 750, GQLParser::RuleOpenNodeReferenceValueType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3595);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ANY) {
        setState(3594);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::ANY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::ANY);
      }
      setState(3597);
      {
        auto childCtxHolder = ctx->EnterNodeSynonym();
        nodeSynonym(get_raw_pointer(childCtxHolder));
      }
      setState(3599);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx)) {
      case 1: {
        setState(3598);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeReferenceValueType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 752, GQLParser::RuleEdgeReferenceValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3603);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 407, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3601);
        {
          auto childCtxHolder = ctx->EnterOpenEdgeReferenceValueType();
          openEdgeReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3602);
        {
          auto childCtxHolder = ctx->EnterClosedEdgeReferenceValueType();
          closedEdgeReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* closedEdgeReferenceValueType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 754, GQLParser::RuleClosedEdgeReferenceValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3605);
      {
        auto childCtxHolder = ctx->EnterEdgeTypeSpecification();
        edgeTypeSpecification(get_raw_pointer(childCtxHolder));
      }
      setState(3607);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 408, _ctx)) {
      case 1: {
        setState(3606);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* openEdgeReferenceValueType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 756, GQLParser::RuleOpenEdgeReferenceValueType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3610);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ANY) {
        setState(3609);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::ANY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::ANY);
      }
      setState(3612);
      {
        auto childCtxHolder = ctx->EnterEdgeSynonym();
        edgeSynonym(get_raw_pointer(childCtxHolder));
      }
      setState(3614);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 410, _ctx)) {
      case 1: {
        setState(3613);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathValueType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 758, GQLParser::RulePathValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3616);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::PATH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::PATH);
      setState(3618);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 411, _ctx)) {
      case 1: {
        setState(3617);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* listValueTypeName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 760, GQLParser::RuleListValueTypeName);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3621);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::GROUP) {
        setState(3620);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::GROUP) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::GROUP);
      }
      setState(3623);
      {
        auto childCtxHolder = ctx->EnterListValueTypeNameSynonym();
        listValueTypeNameSynonym(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* listValueTypeNameSynonym(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 762, GQLParser::RuleListValueTypeNameSynonym);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3625);
      _la = _input->LA(1);
      if (!(_la == GQLParser::ARRAY || _la == GQLParser::LIST)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* recordType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 764, GQLParser::RuleRecordType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3641);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 417, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3628);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::ANY) {
          setState(3627);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ANY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ANY);
        }
        setState(3630);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RECORD) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RECORD);
        setState(3632);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 414, _ctx)) {
        case 1: {
          setState(3631);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3635);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::RECORD) {
          setState(3634);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RECORD) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RECORD);
        }
        setState(3637);
        {
          auto childCtxHolder = ctx->EnterFieldTypesSpecification();
          fieldTypesSpecification(get_raw_pointer(childCtxHolder));
        }
        setState(3639);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 416, _ctx)) {
        case 1: {
          setState(3638);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fieldTypesSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 766, GQLParser::RuleFieldTypesSpecification);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3643);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(3645);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE

      || _la == GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0)) {
        setState(3644);
        {
          auto childCtxHolder = ctx->EnterFieldTypeList();
          fieldTypeList(get_raw_pointer(childCtxHolder));
        }
      }
      setState(3647);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fieldTypeList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 768, GQLParser::RuleFieldTypeList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3649);
      {
        auto childCtxHolder = ctx->EnterFieldType();
        fieldType(get_raw_pointer(childCtxHolder));
      }
      setState(3654);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(3650);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(3651);
        {
          auto childCtxHolder = ctx->EnterFieldType();
          fieldType(get_raw_pointer(childCtxHolder));
        }
        setState(3656);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* notNull(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 770, GQLParser::RuleNotNull);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3657);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NOT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NOT);
      setState(3658);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NULL_KW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NULL_KW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fieldType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 772, GQLParser::RuleFieldType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3660);
      {
        auto childCtxHolder = ctx->EnterFieldName();
        fieldName(get_raw_pointer(childCtxHolder));
      }
      setState(3662);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
        setState(3661);
        {
          auto childCtxHolder = ctx->EnterTyped();
          typed(get_raw_pointer(childCtxHolder));
        }
      }
      setState(3664);
      {
        auto childCtxHolder = ctx->EnterValueType();
        valueType(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* searchCondition(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 774, GQLParser::RuleSearchCondition);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3666);
      {
        auto childCtxHolder = ctx->EnterBooleanValueExpression();
        booleanValueExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* predicate(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 776, GQLParser::RulePredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3677);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 421, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3668);
        {
          auto childCtxHolder = ctx->EnterExistsPredicate();
          existsPredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3669);
        {
          auto childCtxHolder = ctx->EnterNullPredicate();
          nullPredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3670);
        {
          auto childCtxHolder = ctx->EnterValueTypePredicate();
          valueTypePredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(3671);
        {
          auto childCtxHolder = ctx->EnterDirectedPredicate();
          directedPredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(3672);
        {
          auto childCtxHolder = ctx->EnterLabeledPredicate();
          labeledPredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(3673);
        {
          auto childCtxHolder = ctx->EnterSourceDestinationPredicate();
          sourceDestinationPredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(3674);
        {
          auto childCtxHolder = ctx->EnterAll_differentPredicate();
          all_differentPredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(3675);
        {
          auto childCtxHolder = ctx->EnterSamePredicate();
          samePredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(3676);
        {
          auto childCtxHolder = ctx->EnterProperty_existsPredicate();
          property_existsPredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* compOp(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 778, GQLParser::RuleCompOp);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3679);
      _la = _input->LA(1);
      if (!(((((_la - 335) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 335)) & 142807664897) != 0))) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* existsPredicate(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 780, GQLParser::RuleExistsPredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3681);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EXISTS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EXISTS);
      setState(3699);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 422, _ctx)) {
      case 1: {
        setState(3682);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_BRACE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_BRACE);
        setState(3683);
        {
          auto childCtxHolder = ctx->EnterGraphPattern();
          graphPattern(get_raw_pointer(childCtxHolder));
        }
        setState(3684);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_BRACE);
        break;
      }

      case 2: {
        setState(3686);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(3687);
        {
          auto childCtxHolder = ctx->EnterGraphPattern();
          graphPattern(get_raw_pointer(childCtxHolder));
        }
        setState(3688);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      case 3: {
        setState(3690);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_BRACE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_BRACE);
        setState(3691);
        {
          auto childCtxHolder = ctx->EnterMatchStatementBlock();
          matchStatementBlock(get_raw_pointer(childCtxHolder));
        }
        setState(3692);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_BRACE);
        break;
      }

      case 4: {
        setState(3694);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(3695);
        {
          auto childCtxHolder = ctx->EnterMatchStatementBlock();
          matchStatementBlock(get_raw_pointer(childCtxHolder));
        }
        setState(3696);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      case 5: {
        setState(3698);
        {
          auto childCtxHolder = ctx->EnterNestedQuerySpecification();
          nestedQuerySpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nullPredicate(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 782, GQLParser::RuleNullPredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3701);
      {
        auto childCtxHolder = ctx->EnterValueExpressionPrimary();
        valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
      }
      setState(3702);
      {
        auto childCtxHolder = ctx->EnterNullPredicatePart2();
        nullPredicatePart2(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nullPredicatePart2(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 784, GQLParser::RuleNullPredicatePart2);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3704);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IS);
      setState(3706);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::NOT) {
        setState(3705);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
      }
      setState(3708);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NULL_KW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NULL_KW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* valueTypePredicate(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 786, GQLParser::RuleValueTypePredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3710);
      {
        auto childCtxHolder = ctx->EnterValueExpressionPrimary();
        valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
      }
      setState(3711);
      {
        auto childCtxHolder = ctx->EnterValueTypePredicatePart2();
        valueTypePredicatePart2(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* valueTypePredicatePart2(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 788, GQLParser::RuleValueTypePredicatePart2);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3713);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IS);
      setState(3715);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::NOT) {
        setState(3714);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
      }
      setState(3717);
      {
        auto childCtxHolder = ctx->EnterTyped();
        typed(get_raw_pointer(childCtxHolder));
      }
      setState(3718);
      {
        auto childCtxHolder = ctx->EnterValueType();
        valueType(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* normalizedPredicatePart2(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 790, GQLParser::RuleNormalizedPredicatePart2);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3720);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IS);
      setState(3722);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::NOT) {
        setState(3721);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
      }
      setState(3725);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 296) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 296)) & 15) != 0)) {
        setState(3724);
        {
          auto childCtxHolder = ctx->EnterNormalForm();
          normalForm(get_raw_pointer(childCtxHolder));
        }
      }
      setState(3727);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NORMALIZED) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NORMALIZED);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* directedPredicate(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 792, GQLParser::RuleDirectedPredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3729);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(3730);
      {
        auto childCtxHolder = ctx->EnterDirectedPredicatePart2();
        directedPredicatePart2(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* directedPredicatePart2(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 794, GQLParser::RuleDirectedPredicatePart2);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3732);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IS);
      setState(3734);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::NOT) {
        setState(3733);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
      }
      setState(3736);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DIRECTED) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DIRECTED);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* labeledPredicate(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 796, GQLParser::RuleLabeledPredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3738);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(3739);
      {
        auto childCtxHolder = ctx->EnterLabeledPredicatePart2();
        labeledPredicatePart2(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* labeledPredicatePart2(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 798, GQLParser::RuleLabeledPredicatePart2);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3741);
      {
        auto childCtxHolder = ctx->EnterIsLabeledOrColon();
        isLabeledOrColon(get_raw_pointer(childCtxHolder));
      }
      setState(3742);
      {
        auto childCtxHolder = ctx->EnterLabelExpression();
        labelExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* isLabeledOrColon(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 800, GQLParser::RuleIsLabeledOrColon);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3750);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::IS: {
          enterOuterAlt(_localctx, 1);
          setState(3744);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::IS) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::IS);
          setState(3746);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::NOT) {
            setState(3745);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::NOT) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::NOT);
          }
          setState(3748);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LABELED) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LABELED);
          break;
        }

        case GQLParser::COLON: {
          enterOuterAlt(_localctx, 2);
          setState(3749);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COLON) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COLON);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sourceDestinationPredicate(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 802, GQLParser::RuleSourceDestinationPredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3758);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 430, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3752);
        {
          auto childCtxHolder = ctx->EnterNodeReference();
          nodeReference(get_raw_pointer(childCtxHolder));
        }
        setState(3753);
        {
          auto childCtxHolder = ctx->EnterSourcePredicatePart2();
          sourcePredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3755);
        {
          auto childCtxHolder = ctx->EnterNodeReference();
          nodeReference(get_raw_pointer(childCtxHolder));
        }
        setState(3756);
        {
          auto childCtxHolder = ctx->EnterDestinationPredicatePart2();
          destinationPredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nodeReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 804, GQLParser::RuleNodeReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3760);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* sourcePredicatePart2(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 806, GQLParser::RuleSourcePredicatePart2);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3762);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IS);
      setState(3764);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::NOT) {
        setState(3763);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
      }
      setState(3766);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SOURCE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SOURCE);
      setState(3767);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::OF) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::OF);
      setState(3768);
      {
        auto childCtxHolder = ctx->EnterEdgeReference();
        edgeReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* destinationPredicatePart2(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 808, GQLParser::RuleDestinationPredicatePart2);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3770);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IS);
      setState(3772);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::NOT) {
        setState(3771);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
      }
      setState(3774);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DESTINATION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DESTINATION);
      setState(3775);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::OF) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::OF);
      setState(3776);
      {
        auto childCtxHolder = ctx->EnterEdgeReference();
        edgeReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 810, GQLParser::RuleEdgeReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3778);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* all_differentPredicate(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 812, GQLParser::RuleAll_differentPredicate);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3780);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ALL_DIFFERENT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ALL_DIFFERENT);
      setState(3781);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3782);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(3783);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(3784);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(3789);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(3785);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(3786);
        {
          auto childCtxHolder = ctx->EnterElementVariableReference();
          elementVariableReference(get_raw_pointer(childCtxHolder));
        }
        setState(3791);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3792);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* samePredicate(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 814, GQLParser::RuleSamePredicate);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3794);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SAME) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SAME);
      setState(3795);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3796);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(3797);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(3798);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(3803);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(3799);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(3800);
        {
          auto childCtxHolder = ctx->EnterElementVariableReference();
          elementVariableReference(get_raw_pointer(childCtxHolder));
        }
        setState(3805);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3806);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* property_existsPredicate(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 816, GQLParser::RuleProperty_existsPredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3808);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::PROPERTY_EXISTS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::PROPERTY_EXISTS);
      setState(3809);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3810);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(3811);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(3812);
      {
        auto childCtxHolder = ctx->EnterPropertyName();
        propertyName(get_raw_pointer(childCtxHolder));
      }
      setState(3813);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }


  template<typename ContextT>
  antlr4::ParserRuleContext* valueExpression(ContextT* ctx) {
     return valueExpression(0, ctx);
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* valueExpression(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, parentState);
    antlr4::ParserRuleContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 818;
    enterRecursionRule(_localctx, 818, GQLParser::RuleValueExpression, precedence);

      size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(3833);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 437, _ctx)) {
      case 1: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterSignedExprAlt();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });

        setState(3816);
        _la = _input->LA(1);
        if (!(_la == GQLParser::MINUS_SIGN

        || _la == GQLParser::PLUS_SIGN)) {
          _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          antlr4::Token * token = consume();
          ctx->OnToken(token);
        }
        setState(3817);
        {
          auto childCtxHolder = ctx->EnterValueExpression();
          valueExpression(15, get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterPredicateExprAlt();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3818);
        {
          auto childCtxHolder = ctx->EnterPredicate();
          predicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterNotExprAlt();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3819);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
        setState(3820);
        {
          auto childCtxHolder = ctx->EnterValueExpression();
          valueExpression(7, get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterPropertyGraphExprAlt();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3822);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::PROPERTY) {
          setState(3821);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::PROPERTY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::PROPERTY);
        }
        setState(3824);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::GRAPH) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::GRAPH);
        setState(3825);
        {
          auto childCtxHolder = ctx->EnterGraphExpression();
          graphExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterBindingTableExprAlt();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3827);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::BINDING) {
          setState(3826);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::BINDING) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::BINDING);
        }
        setState(3829);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::TABLE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::TABLE);
        setState(3830);
        {
          auto childCtxHolder = ctx->EnterBindingTableExpression();
          bindingTableExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterValueFunctionExprAlt();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3831);
        {
          auto childCtxHolder = ctx->EnterValueFunction();
          valueFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 7: {
        {
          auto savedLocalCtx = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
          _localctx->copyFrom(savedLocalCtx);
        }
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterPrimaryExprAlt();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3832);
        {
          auto childCtxHolder = ctx->EnterValueExpressionPrimary();
          valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      _ctx->stop = _input->LT(-1);
      setState(3864);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 440, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          setState(3862);
          _errHandler->sync(this);
          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 439, _ctx)) {
          case 1: {
            auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
            auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
            newContext->copyFrom(newParentContext);
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushMultDivExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3835);

            if (!(precpred(_ctx, 14))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 14)");
            setState(3836);
            _la = _input->LA(1);
            if (!(_la == GQLParser::ASTERISK

            || _la == GQLParser::SOLIDUS)) {
              _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              antlr4::Token * token = consume();
              ctx->OnToken(token);
            }
            setState(3837);
            {
              auto childCtxHolder = ctx->EnterValueExpression();
              valueExpression(15, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 2: {
            auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
            auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
            newContext->copyFrom(newParentContext);
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushAddSubtractExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3838);

            if (!(precpred(_ctx, 13))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 13)");
            setState(3839);
            _la = _input->LA(1);
            if (!(_la == GQLParser::MINUS_SIGN

            || _la == GQLParser::PLUS_SIGN)) {
              _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              antlr4::Token * token = consume();
              ctx->OnToken(token);
            }
            setState(3840);
            {
              auto childCtxHolder = ctx->EnterValueExpression();
              valueExpression(14, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 3: {
            auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
            auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
            newContext->copyFrom(newParentContext);
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushConcatenationExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3841);

            if (!(precpred(_ctx, 12))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 12)");
            setState(3842);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::CONCATENATION_OPERATOR) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::CONCATENATION_OPERATOR);
            setState(3843);
            {
              auto childCtxHolder = ctx->EnterValueExpression();
              valueExpression(13, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 4: {
            auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
            auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
            newContext->copyFrom(newParentContext);
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushComparisonExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3844);

            if (!(precpred(_ctx, 11))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 11)");
            setState(3845);
            {
              auto childCtxHolder = ctx->EnterCompOp();
              compOp(get_raw_pointer(childCtxHolder));
            }
            setState(3846);
            {
              auto childCtxHolder = ctx->EnterValueExpression();
              valueExpression(12, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 5: {
            auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
            auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
            newContext->copyFrom(newParentContext);
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushConjunctiveExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3848);

            if (!(precpred(_ctx, 6))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 6)");
            setState(3849);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::AND) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::AND);
            setState(3850);
            {
              auto childCtxHolder = ctx->EnterValueExpression();
              valueExpression(7, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 6: {
            auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
            auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
            newContext->copyFrom(newParentContext);
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushDisjunctiveExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3851);

            if (!(precpred(_ctx, 5))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 5)");
            setState(3852);
            _la = _input->LA(1);
            if (!(_la == GQLParser::OR || _la == GQLParser::XOR)) {
              _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              antlr4::Token * token = consume();
              ctx->OnToken(token);
            }
            setState(3853);
            {
              auto childCtxHolder = ctx->EnterValueExpression();
              valueExpression(6, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 7: {
            auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
            auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
            newContext->copyFrom(newParentContext);
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushNormalizedPredicateExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3854);

            if (!(precpred(_ctx, 9))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 9)");
            setState(3855);
            {
              auto childCtxHolder = ctx->EnterNormalizedPredicatePart2();
              normalizedPredicatePart2(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 8: {
            auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
            auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
            newContext->copyFrom(newParentContext);
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushIsNotExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3856);

            if (!(precpred(_ctx, 8))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 8)");
            setState(3857);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::IS) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::IS);
            setState(3859);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == GQLParser::NOT) {
              setState(3858);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::NOT) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::NOT);
            }
            setState(3861);
            {
              auto childCtxHolder = ctx->EnterTruthValue();
              truthValue(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          } 
        }
        setState(3866);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 440, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* valueFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 820, GQLParser::RuleValueFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3873);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 441, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3867);
        {
          auto childCtxHolder = ctx->EnterNumericValueFunction();
          numericValueFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3868);
        {
          auto childCtxHolder = ctx->EnterDatetimeSubtraction();
          datetimeSubtraction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3869);
        {
          auto childCtxHolder = ctx->EnterDatetimeValueFunction();
          datetimeValueFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(3870);
        {
          auto childCtxHolder = ctx->EnterDurationValueFunction();
          durationValueFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(3871);
        {
          auto childCtxHolder = ctx->EnterCharacterOrByteStringFunction();
          characterOrByteStringFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(3872);
        {
          auto childCtxHolder = ctx->EnterListValueFunction();
          listValueFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* booleanValueExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 822, GQLParser::RuleBooleanValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3875);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* characterOrByteStringFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 824, GQLParser::RuleCharacterOrByteStringFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3882);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LEFT:
        case GQLParser::RIGHT: {
          enterOuterAlt(_localctx, 1);
          setState(3877);
          {
            auto childCtxHolder = ctx->EnterSubCharacterOrByteString();
            subCharacterOrByteString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::TRIM: {
          enterOuterAlt(_localctx, 2);
          setState(3878);
          {
            auto childCtxHolder = ctx->EnterTrimSingleCharacterOrByteString();
            trimSingleCharacterOrByteString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LOWER:
        case GQLParser::UPPER: {
          enterOuterAlt(_localctx, 3);
          setState(3879);
          {
            auto childCtxHolder = ctx->EnterFoldCharacterString();
            foldCharacterString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BTRIM:
        case GQLParser::LTRIM:
        case GQLParser::RTRIM: {
          enterOuterAlt(_localctx, 4);
          setState(3880);
          {
            auto childCtxHolder = ctx->EnterTrimMultiCharacterCharacterString();
            trimMultiCharacterCharacterString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::NORMALIZE: {
          enterOuterAlt(_localctx, 5);
          setState(3881);
          {
            auto childCtxHolder = ctx->EnterNormalizeCharacterString();
            normalizeCharacterString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* subCharacterOrByteString(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 826, GQLParser::RuleSubCharacterOrByteString);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3884);
      _la = _input->LA(1);
      if (!(_la == GQLParser::LEFT

      || _la == GQLParser::RIGHT)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(3885);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3886);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(3887);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(3888);
      {
        auto childCtxHolder = ctx->EnterStringLength();
        stringLength(get_raw_pointer(childCtxHolder));
      }
      setState(3889);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* trimSingleCharacterOrByteString(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 828, GQLParser::RuleTrimSingleCharacterOrByteString);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3891);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TRIM) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TRIM);
      setState(3892);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3893);
      {
        auto childCtxHolder = ctx->EnterTrimOperands();
        trimOperands(get_raw_pointer(childCtxHolder));
      }
      setState(3894);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* foldCharacterString(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 830, GQLParser::RuleFoldCharacterString);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3896);
      _la = _input->LA(1);
      if (!(_la == GQLParser::LOWER || _la == GQLParser::UPPER)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(3897);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3898);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(3899);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* trimMultiCharacterCharacterString(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 832, GQLParser::RuleTrimMultiCharacterCharacterString);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3901);
      _la = _input->LA(1);
      if (!(_la == GQLParser::BTRIM || _la == GQLParser::LTRIM

      || _la == GQLParser::RTRIM)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(3902);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3903);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(3906);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::COMMA) {
        setState(3904);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(3905);
        {
          auto childCtxHolder = ctx->EnterValueExpression();
          valueExpression(0, get_raw_pointer(childCtxHolder));
        }
      }
      setState(3908);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* normalizeCharacterString(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 834, GQLParser::RuleNormalizeCharacterString);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3910);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NORMALIZE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NORMALIZE);
      setState(3911);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3912);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(3915);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::COMMA) {
        setState(3913);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(3914);
        {
          auto childCtxHolder = ctx->EnterNormalForm();
          normalForm(get_raw_pointer(childCtxHolder));
        }
      }
      setState(3917);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nodeReferenceValueExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 836, GQLParser::RuleNodeReferenceValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3919);
      {
        auto childCtxHolder = ctx->EnterValueExpressionPrimary();
        valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeReferenceValueExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 838, GQLParser::RuleEdgeReferenceValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3921);
      {
        auto childCtxHolder = ctx->EnterValueExpressionPrimary();
        valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* aggregatingValueExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 840, GQLParser::RuleAggregatingValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3923);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }


  template<typename ContextT>
  antlr4::ParserRuleContext* valueExpressionPrimary(ContextT* ctx) {
     return valueExpressionPrimary(0, ctx);
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* valueExpressionPrimary(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, parentState);
    antlr4::ParserRuleContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 842;
    enterRecursionRule(_localctx, 842, GQLParser::RuleValueExpressionPrimary, precedence);

      

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(3936);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LEFT_PAREN: {
          setState(3926);
          {
            auto childCtxHolder = ctx->EnterParenthesizedValueExpression();
            parenthesizedValueExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::AVG:
        case GQLParser::COLLECT_LIST:
        case GQLParser::COUNT:
        case GQLParser::MAX:
        case GQLParser::MIN:
        case GQLParser::PERCENTILE_CONT:
        case GQLParser::PERCENTILE_DISC:
        case GQLParser::STDDEV_POP:
        case GQLParser::STDDEV_SAMP:
        case GQLParser::SUM: {
          setState(3927);
          {
            auto childCtxHolder = ctx->EnterAggregateFunction();
            aggregateFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BOOLEAN_LITERAL:
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::BYTE_STRING_LITERAL:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER:
        case GQLParser::ARRAY:
        case GQLParser::DATE:
        case GQLParser::DATETIME:
        case GQLParser::DURATION:
        case GQLParser::GROUP:
        case GQLParser::LIST:
        case GQLParser::NULL_KW:
        case GQLParser::RECORD:
        case GQLParser::SESSION_USER:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::GENERAL_PARAMETER_REFERENCE:
        case GQLParser::LEFT_BRACE:
        case GQLParser::LEFT_BRACKET: {
          setState(3928);
          {
            auto childCtxHolder = ctx->EnterUnsignedValueSpecification();
            unsignedValueSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::PATH: {
          setState(3929);
          {
            auto childCtxHolder = ctx->EnterPathValueConstructor();
            pathValueConstructor(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::VALUE: {
          setState(3930);
          {
            auto childCtxHolder = ctx->EnterValueQueryExpression();
            valueQueryExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CASE:
        case GQLParser::COALESCE:
        case GQLParser::NULLIF: {
          setState(3931);
          {
            auto childCtxHolder = ctx->EnterCaseExpression();
            caseExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CAST: {
          setState(3932);
          {
            auto childCtxHolder = ctx->EnterCastSpecification();
            castSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ELEMENT_ID: {
          setState(3933);
          {
            auto childCtxHolder = ctx->EnterElement_idFunction();
            element_idFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LET: {
          setState(3934);
          {
            auto childCtxHolder = ctx->EnterLetValueExpression();
            letValueExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          setState(3935);
          {
            auto childCtxHolder = ctx->EnterBindingVariableReference();
            bindingVariableReference(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
      _ctx->stop = _input->LT(-1);
      setState(3943);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 446, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          _localctx = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleValueExpressionPrimary);
          ctx->PushValueExpressionPrimary();
          setState(3938);

          if (!(precpred(_ctx, 7))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(3939);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::PERIOD) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::PERIOD);
          setState(3940);
          {
            auto childCtxHolder = ctx->EnterPropertyName();
            propertyName(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(3945);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 446, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* parenthesizedValueExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 844, GQLParser::RuleParenthesizedValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3946);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3947);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(3948);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nonParenthesizedValueExpressionPrimary(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 846, GQLParser::RuleNonParenthesizedValueExpressionPrimary);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3952);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 447, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3950);
        {
          auto childCtxHolder = ctx->EnterNonParenthesizedValueExpressionPrimarySpecialCase();
          nonParenthesizedValueExpressionPrimarySpecialCase(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3951);
        {
          auto childCtxHolder = ctx->EnterBindingVariableReference();
          bindingVariableReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nonParenthesizedValueExpressionPrimarySpecialCase(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 848, GQLParser::RuleNonParenthesizedValueExpressionPrimarySpecialCase);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3966);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 448, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3954);
        {
          auto childCtxHolder = ctx->EnterAggregateFunction();
          aggregateFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3955);
        {
          auto childCtxHolder = ctx->EnterUnsignedValueSpecification();
          unsignedValueSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3956);
        {
          auto childCtxHolder = ctx->EnterPathValueConstructor();
          pathValueConstructor(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(3957);
        {
          auto childCtxHolder = ctx->EnterValueExpressionPrimary();
          valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
        }
        setState(3958);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PERIOD) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PERIOD);
        setState(3959);
        {
          auto childCtxHolder = ctx->EnterPropertyName();
          propertyName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(3961);
        {
          auto childCtxHolder = ctx->EnterValueQueryExpression();
          valueQueryExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(3962);
        {
          auto childCtxHolder = ctx->EnterCaseExpression();
          caseExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(3963);
        {
          auto childCtxHolder = ctx->EnterCastSpecification();
          castSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(3964);
        {
          auto childCtxHolder = ctx->EnterElement_idFunction();
          element_idFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(3965);
        {
          auto childCtxHolder = ctx->EnterLetValueExpression();
          letValueExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* unsignedValueSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 850, GQLParser::RuleUnsignedValueSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3970);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BOOLEAN_LITERAL:
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::BYTE_STRING_LITERAL:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER:
        case GQLParser::ARRAY:
        case GQLParser::DATE:
        case GQLParser::DATETIME:
        case GQLParser::DURATION:
        case GQLParser::GROUP:
        case GQLParser::LIST:
        case GQLParser::NULL_KW:
        case GQLParser::RECORD:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::LEFT_BRACE:
        case GQLParser::LEFT_BRACKET: {
          enterOuterAlt(_localctx, 1);
          setState(3968);
          {
            auto childCtxHolder = ctx->EnterUnsignedLiteral();
            unsignedLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::SESSION_USER:
        case GQLParser::GENERAL_PARAMETER_REFERENCE: {
          enterOuterAlt(_localctx, 2);
          setState(3969);
          {
            auto childCtxHolder = ctx->EnterGeneralValueSpecification();
            generalValueSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nonNegativeIntegerSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 852, GQLParser::RuleNonNegativeIntegerSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3974);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER: {
          enterOuterAlt(_localctx, 1);
          setState(3972);
          {
            auto childCtxHolder = ctx->EnterUnsignedInteger();
            unsignedInteger(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::GENERAL_PARAMETER_REFERENCE: {
          enterOuterAlt(_localctx, 2);
          setState(3973);
          {
            auto childCtxHolder = ctx->EnterDynamicParameterSpecification();
            dynamicParameterSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* generalValueSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 854, GQLParser::RuleGeneralValueSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3978);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::GENERAL_PARAMETER_REFERENCE: {
          enterOuterAlt(_localctx, 1);
          setState(3976);
          {
            auto childCtxHolder = ctx->EnterDynamicParameterSpecification();
            dynamicParameterSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::SESSION_USER: {
          enterOuterAlt(_localctx, 2);
          setState(3977);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::SESSION_USER) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::SESSION_USER);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* dynamicParameterSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 856, GQLParser::RuleDynamicParameterSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3980);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GENERAL_PARAMETER_REFERENCE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GENERAL_PARAMETER_REFERENCE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* letValueExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 858, GQLParser::RuleLetValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3982);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LET);
      setState(3983);
      {
        auto childCtxHolder = ctx->EnterLetVariableDefinitionList();
        letVariableDefinitionList(get_raw_pointer(childCtxHolder));
      }
      setState(3984);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IN);
      setState(3985);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(3986);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::END) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::END);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* valueQueryExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 860, GQLParser::RuleValueQueryExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3988);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::VALUE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::VALUE);
      setState(3989);
      {
        auto childCtxHolder = ctx->EnterNestedQuerySpecification();
        nestedQuerySpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* caseExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 862, GQLParser::RuleCaseExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3993);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::COALESCE:
        case GQLParser::NULLIF: {
          enterOuterAlt(_localctx, 1);
          setState(3991);
          {
            auto childCtxHolder = ctx->EnterCaseAbbreviation();
            caseAbbreviation(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CASE: {
          enterOuterAlt(_localctx, 2);
          setState(3992);
          {
            auto childCtxHolder = ctx->EnterCaseSpecification();
            caseSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* caseAbbreviation(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 864, GQLParser::RuleCaseAbbreviation);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4013);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::NULLIF: {
          {
            auto savedLocalCtx = _localctx;
            _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
            _localctx->copyFrom(savedLocalCtx);
          }
          auto ctxHolder = ctx->EnterNullIfExprAlt();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          enterOuterAlt(_localctx, 1);
          setState(3995);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::NULLIF) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::NULLIF);
          setState(3996);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(3997);
          {
            auto childCtxHolder = ctx->EnterValueExpression();
            valueExpression(0, get_raw_pointer(childCtxHolder));
          }
          setState(3998);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COMMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COMMA);
          setState(3999);
          {
            auto childCtxHolder = ctx->EnterValueExpression();
            valueExpression(0, get_raw_pointer(childCtxHolder));
          }
          setState(4000);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

        case GQLParser::COALESCE: {
          {
            auto savedLocalCtx = _localctx;
            _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
            _localctx->copyFrom(savedLocalCtx);
          }
          auto ctxHolder = ctx->EnterCoalesceExprAlt();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          enterOuterAlt(_localctx, 2);
          setState(4002);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COALESCE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COALESCE);
          setState(4003);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(4004);
          {
            auto childCtxHolder = ctx->EnterValueExpression();
            valueExpression(0, get_raw_pointer(childCtxHolder));
          }
          setState(4007); 
          _errHandler->sync(this);
          _la = _input->LA(1);
          do {
            setState(4005);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::COMMA) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::COMMA);
            setState(4006);
            {
              auto childCtxHolder = ctx->EnterValueExpression();
              valueExpression(0, get_raw_pointer(childCtxHolder));
            }
            setState(4009); 
            _errHandler->sync(this);
            _la = _input->LA(1);
          } while (_la == GQLParser::COMMA);
          setState(4011);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* caseSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 866, GQLParser::RuleCaseSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4017);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 455, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4015);
        {
          auto childCtxHolder = ctx->EnterSimpleCase();
          simpleCase(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4016);
        {
          auto childCtxHolder = ctx->EnterSearchedCase();
          searchedCase(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simpleCase(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 868, GQLParser::RuleSimpleCase);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4019);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CASE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CASE);
      setState(4020);
      {
        auto childCtxHolder = ctx->EnterCaseOperand();
        caseOperand(get_raw_pointer(childCtxHolder));
      }
      setState(4022); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(4021);
        {
          auto childCtxHolder = ctx->EnterSimpleWhenClause();
          simpleWhenClause(get_raw_pointer(childCtxHolder));
        }
        setState(4024); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == GQLParser::WHEN);
      setState(4027);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ELSE) {
        setState(4026);
        {
          auto childCtxHolder = ctx->EnterElseClause();
          elseClause(get_raw_pointer(childCtxHolder));
        }
      }
      setState(4029);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::END) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::END);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* searchedCase(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 870, GQLParser::RuleSearchedCase);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4031);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CASE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CASE);
      setState(4033); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(4032);
        {
          auto childCtxHolder = ctx->EnterSearchedWhenClause();
          searchedWhenClause(get_raw_pointer(childCtxHolder));
        }
        setState(4035); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == GQLParser::WHEN);
      setState(4038);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ELSE) {
        setState(4037);
        {
          auto childCtxHolder = ctx->EnterElseClause();
          elseClause(get_raw_pointer(childCtxHolder));
        }
      }
      setState(4040);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::END) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::END);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* simpleWhenClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 872, GQLParser::RuleSimpleWhenClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4042);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::WHEN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::WHEN);
      setState(4043);
      {
        auto childCtxHolder = ctx->EnterWhenOperandList();
        whenOperandList(get_raw_pointer(childCtxHolder));
      }
      setState(4044);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::THEN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::THEN);
      setState(4045);
      {
        auto childCtxHolder = ctx->EnterResult();
        result(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* searchedWhenClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 874, GQLParser::RuleSearchedWhenClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4047);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::WHEN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::WHEN);
      setState(4048);
      {
        auto childCtxHolder = ctx->EnterSearchCondition();
        searchCondition(get_raw_pointer(childCtxHolder));
      }
      setState(4049);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::THEN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::THEN);
      setState(4050);
      {
        auto childCtxHolder = ctx->EnterResult();
        result(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* elseClause(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 876, GQLParser::RuleElseClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4052);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ELSE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ELSE);
      setState(4053);
      {
        auto childCtxHolder = ctx->EnterResult();
        result(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* caseOperand(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 878, GQLParser::RuleCaseOperand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4057);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 460, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4055);
        {
          auto childCtxHolder = ctx->EnterNonParenthesizedValueExpressionPrimary();
          nonParenthesizedValueExpressionPrimary(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4056);
        {
          auto childCtxHolder = ctx->EnterElementVariableReference();
          elementVariableReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* whenOperandList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 880, GQLParser::RuleWhenOperandList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4059);
      {
        auto childCtxHolder = ctx->EnterWhenOperand();
        whenOperand(get_raw_pointer(childCtxHolder));
      }
      setState(4064);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(4060);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(4061);
        {
          auto childCtxHolder = ctx->EnterWhenOperand();
          whenOperand(get_raw_pointer(childCtxHolder));
        }
        setState(4066);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* whenOperand(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 882, GQLParser::RuleWhenOperand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4078);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 462, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4067);
        {
          auto childCtxHolder = ctx->EnterNonParenthesizedValueExpressionPrimary();
          nonParenthesizedValueExpressionPrimary(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4068);
        {
          auto childCtxHolder = ctx->EnterCompOp();
          compOp(get_raw_pointer(childCtxHolder));
        }
        setState(4069);
        {
          auto childCtxHolder = ctx->EnterValueExpression();
          valueExpression(0, get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(4071);
        {
          auto childCtxHolder = ctx->EnterNullPredicatePart2();
          nullPredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(4072);
        {
          auto childCtxHolder = ctx->EnterValueTypePredicatePart2();
          valueTypePredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(4073);
        {
          auto childCtxHolder = ctx->EnterNormalizedPredicatePart2();
          normalizedPredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(4074);
        {
          auto childCtxHolder = ctx->EnterDirectedPredicatePart2();
          directedPredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(4075);
        {
          auto childCtxHolder = ctx->EnterLabeledPredicatePart2();
          labeledPredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(4076);
        {
          auto childCtxHolder = ctx->EnterSourcePredicatePart2();
          sourcePredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(4077);
        {
          auto childCtxHolder = ctx->EnterDestinationPredicatePart2();
          destinationPredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* result(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 884, GQLParser::RuleResult);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4082);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 463, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4080);
        {
          auto childCtxHolder = ctx->EnterResultExpression();
          resultExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4081);
        {
          auto childCtxHolder = ctx->EnterNullLiteral();
          nullLiteral(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* resultExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 886, GQLParser::RuleResultExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4084);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* castSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 888, GQLParser::RuleCastSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4086);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CAST) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CAST);
      setState(4087);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4088);
      {
        auto childCtxHolder = ctx->EnterCastOperand();
        castOperand(get_raw_pointer(childCtxHolder));
      }
      setState(4089);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::AS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::AS);
      setState(4090);
      {
        auto childCtxHolder = ctx->EnterCastTarget();
        castTarget(get_raw_pointer(childCtxHolder));
      }
      setState(4091);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* castOperand(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 890, GQLParser::RuleCastOperand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4095);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 464, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4093);
        {
          auto childCtxHolder = ctx->EnterValueExpression();
          valueExpression(0, get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4094);
        {
          auto childCtxHolder = ctx->EnterNullLiteral();
          nullLiteral(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* castTarget(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 892, GQLParser::RuleCastTarget);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4097);
      {
        auto childCtxHolder = ctx->EnterValueType();
        valueType(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* aggregateFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 894, GQLParser::RuleAggregateFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4105);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 465, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4099);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COUNT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COUNT);
        setState(4100);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(4101);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::ASTERISK) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::ASTERISK);
        setState(4102);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4103);
        {
          auto childCtxHolder = ctx->EnterGeneralSetFunction();
          generalSetFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(4104);
        {
          auto childCtxHolder = ctx->EnterBinarySetFunction();
          binarySetFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* generalSetFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 896, GQLParser::RuleGeneralSetFunction);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4107);
      {
        auto childCtxHolder = ctx->EnterGeneralSetFunctionType();
        generalSetFunctionType(get_raw_pointer(childCtxHolder));
      }
      setState(4108);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4110);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ALL

      || _la == GQLParser::DISTINCT) {
        setState(4109);
        {
          auto childCtxHolder = ctx->EnterSetQuantifier();
          setQuantifier(get_raw_pointer(childCtxHolder));
        }
      }
      setState(4112);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4113);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* binarySetFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 898, GQLParser::RuleBinarySetFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4115);
      {
        auto childCtxHolder = ctx->EnterBinarySetFunctionType();
        binarySetFunctionType(get_raw_pointer(childCtxHolder));
      }
      setState(4116);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4117);
      {
        auto childCtxHolder = ctx->EnterDependentValueExpression();
        dependentValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4118);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4119);
      {
        auto childCtxHolder = ctx->EnterIndependentValueExpression();
        independentValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4120);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* generalSetFunctionType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 900, GQLParser::RuleGeneralSetFunctionType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4122);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 4683743621055250432) != 0) || ((((_la - 144) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 144)) & 792633534417207299) != 0))) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* setQuantifier(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 902, GQLParser::RuleSetQuantifier);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4124);
      _la = _input->LA(1);
      if (!(_la == GQLParser::ALL

      || _la == GQLParser::DISTINCT)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* binarySetFunctionType(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 904, GQLParser::RuleBinarySetFunctionType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4126);
      _la = _input->LA(1);
      if (!(_la == GQLParser::PERCENTILE_CONT

      || _la == GQLParser::PERCENTILE_DISC)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* dependentValueExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 906, GQLParser::RuleDependentValueExpression);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4129);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ALL

      || _la == GQLParser::DISTINCT) {
        setState(4128);
        {
          auto childCtxHolder = ctx->EnterSetQuantifier();
          setQuantifier(get_raw_pointer(childCtxHolder));
        }
      }
      setState(4131);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* independentValueExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 908, GQLParser::RuleIndependentValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4133);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* element_idFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 910, GQLParser::RuleElement_idFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4135);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ELEMENT_ID) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ELEMENT_ID);
      setState(4136);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4137);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(4138);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* bindingVariableReference(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 912, GQLParser::RuleBindingVariableReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4140);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathValueExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 914, GQLParser::RulePathValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4142);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathValueConstructor(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 916, GQLParser::RulePathValueConstructor);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4144);
      {
        auto childCtxHolder = ctx->EnterPathValueConstructorByEnumeration();
        pathValueConstructorByEnumeration(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathValueConstructorByEnumeration(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 918, GQLParser::RulePathValueConstructorByEnumeration);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4146);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::PATH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::PATH);
      setState(4147);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACKET);
      setState(4148);
      {
        auto childCtxHolder = ctx->EnterPathElementList();
        pathElementList(get_raw_pointer(childCtxHolder));
      }
      setState(4149);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathElementList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 920, GQLParser::RulePathElementList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4151);
      {
        auto childCtxHolder = ctx->EnterPathElementListStart();
        pathElementListStart(get_raw_pointer(childCtxHolder));
      }
      setState(4155);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(4152);
        {
          auto childCtxHolder = ctx->EnterPathElementListStep();
          pathElementListStep(get_raw_pointer(childCtxHolder));
        }
        setState(4157);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathElementListStart(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 922, GQLParser::RulePathElementListStart);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4158);
      {
        auto childCtxHolder = ctx->EnterNodeReferenceValueExpression();
        nodeReferenceValueExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathElementListStep(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 924, GQLParser::RulePathElementListStep);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4160);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4161);
      {
        auto childCtxHolder = ctx->EnterEdgeReferenceValueExpression();
        edgeReferenceValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4162);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4163);
      {
        auto childCtxHolder = ctx->EnterNodeReferenceValueExpression();
        nodeReferenceValueExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* listValueExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 926, GQLParser::RuleListValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4165);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* listValueFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 928, GQLParser::RuleListValueFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4169);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::TRIM: {
          enterOuterAlt(_localctx, 1);
          setState(4167);
          {
            auto childCtxHolder = ctx->EnterTrimListFunction();
            trimListFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ELEMENTS: {
          enterOuterAlt(_localctx, 2);
          setState(4168);
          {
            auto childCtxHolder = ctx->EnterElementsFunction();
            elementsFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* trimListFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 930, GQLParser::RuleTrimListFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4171);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TRIM) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TRIM);
      setState(4172);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4173);
      {
        auto childCtxHolder = ctx->EnterListValueExpression();
        listValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4174);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4175);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4176);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* elementsFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 932, GQLParser::RuleElementsFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4178);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ELEMENTS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ELEMENTS);
      setState(4179);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4180);
      {
        auto childCtxHolder = ctx->EnterPathValueExpression();
        pathValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4181);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* listValueConstructor(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 934, GQLParser::RuleListValueConstructor);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4183);
      {
        auto childCtxHolder = ctx->EnterListValueConstructorByEnumeration();
        listValueConstructorByEnumeration(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* listValueConstructorByEnumeration(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 936, GQLParser::RuleListValueConstructorByEnumeration);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4186);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ARRAY || _la == GQLParser::GROUP

      || _la == GQLParser::LIST) {
        setState(4185);
        {
          auto childCtxHolder = ctx->EnterListValueTypeName();
          listValueTypeName(get_raw_pointer(childCtxHolder));
        }
      }
      setState(4188);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACKET);
      setState(4190);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8762849302180528028) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 309341980913) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 129)) & -8011702113698201677) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & 26393111092643) != 0) || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 1686650837008383) != 0) || ((((_la - 369) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 369)) & 151) != 0)) {
        setState(4189);
        {
          auto childCtxHolder = ctx->EnterListElementList();
          listElementList(get_raw_pointer(childCtxHolder));
        }
      }
      setState(4192);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* listElementList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 938, GQLParser::RuleListElementList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4194);
      {
        auto childCtxHolder = ctx->EnterListElement();
        listElement(get_raw_pointer(childCtxHolder));
      }
      setState(4199);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(4195);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(4196);
        {
          auto childCtxHolder = ctx->EnterListElement();
          listElement(get_raw_pointer(childCtxHolder));
        }
        setState(4201);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* listElement(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 940, GQLParser::RuleListElement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4202);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* recordConstructor(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 942, GQLParser::RuleRecordConstructor);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4205);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::RECORD) {
        setState(4204);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RECORD) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RECORD);
      }
      setState(4207);
      {
        auto childCtxHolder = ctx->EnterFieldsSpecification();
        fieldsSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fieldsSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 944, GQLParser::RuleFieldsSpecification);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4209);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(4211);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE

      || _la == GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0)) {
        setState(4210);
        {
          auto childCtxHolder = ctx->EnterFieldList();
          fieldList(get_raw_pointer(childCtxHolder));
        }
      }
      setState(4213);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fieldList(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 946, GQLParser::RuleFieldList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4215);
      {
        auto childCtxHolder = ctx->EnterField();
        field(get_raw_pointer(childCtxHolder));
      }
      setState(4220);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(4216);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(4217);
        {
          auto childCtxHolder = ctx->EnterField();
          field(get_raw_pointer(childCtxHolder));
        }
        setState(4222);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* field(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 948, GQLParser::RuleField);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4223);
      {
        auto childCtxHolder = ctx->EnterFieldName();
        fieldName(get_raw_pointer(childCtxHolder));
      }
      setState(4224);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COLON) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COLON);
      setState(4225);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* truthValue(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 950, GQLParser::RuleTruthValue);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4227);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BOOLEAN_LITERAL) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BOOLEAN_LITERAL);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }


  template<typename ContextT>
  antlr4::ParserRuleContext* numericValueExpression(ContextT* ctx) {
     return numericValueExpression(0, ctx);
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* numericValueExpression(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, parentState);
    antlr4::ParserRuleContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 952;
    enterRecursionRule(_localctx, 952, GQLParser::RuleNumericValueExpression, precedence);

      size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(4234);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::MINUS_SIGN:
        case GQLParser::PLUS_SIGN: {
          {
            auto savedLocalCtx = _localctx;
            _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
            _localctx->copyFrom(savedLocalCtx);
          }
          _ctx = _localctx;
          previousContext = _localctx;
          auto ctxHolder = ctx->EnterSignedExprAlt2();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });

          setState(4230);
          _la = _input->LA(1);
          if (!(_la == GQLParser::MINUS_SIGN

          || _la == GQLParser::PLUS_SIGN)) {
            _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            antlr4::Token * token = consume();
            ctx->OnToken(token);
          }
          setState(4231);
          {
            auto childCtxHolder = ctx->EnterNumericValueExpression();
            numericValueExpression(5, get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BOOLEAN_LITERAL:
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::BYTE_STRING_LITERAL:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER:
        case GQLParser::ARRAY:
        case GQLParser::AVG:
        case GQLParser::CASE:
        case GQLParser::CAST:
        case GQLParser::COALESCE:
        case GQLParser::COLLECT_LIST:
        case GQLParser::COUNT:
        case GQLParser::DATE:
        case GQLParser::DATETIME:
        case GQLParser::DURATION:
        case GQLParser::ELEMENT_ID:
        case GQLParser::GROUP:
        case GQLParser::LET:
        case GQLParser::LIST:
        case GQLParser::MAX:
        case GQLParser::MIN:
        case GQLParser::NULL_KW:
        case GQLParser::NULLIF:
        case GQLParser::PATH:
        case GQLParser::PERCENTILE_CONT:
        case GQLParser::PERCENTILE_DISC:
        case GQLParser::RECORD:
        case GQLParser::SESSION_USER:
        case GQLParser::STDDEV_POP:
        case GQLParser::STDDEV_SAMP:
        case GQLParser::SUM:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::VALUE:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER:
        case GQLParser::GENERAL_PARAMETER_REFERENCE:
        case GQLParser::LEFT_BRACE:
        case GQLParser::LEFT_BRACKET:
        case GQLParser::LEFT_PAREN: {
          {
            auto savedLocalCtx = _localctx;
            _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
            _localctx->copyFrom(savedLocalCtx);
          }
          _ctx = _localctx;
          previousContext = _localctx;
          auto ctxHolder = ctx->EnterPrimaryExprAlt2();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          setState(4232);
          {
            auto childCtxHolder = ctx->EnterValueExpressionPrimary();
            valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ABS:
        case GQLParser::ACOS:
        case GQLParser::ASIN:
        case GQLParser::ATAN:
        case GQLParser::BYTE_LENGTH:
        case GQLParser::CARDINALITY:
        case GQLParser::CEIL:
        case GQLParser::CEILING:
        case GQLParser::CHAR_LENGTH:
        case GQLParser::CHARACTER_LENGTH:
        case GQLParser::COS:
        case GQLParser::COSH:
        case GQLParser::COT:
        case GQLParser::DEGREES:
        case GQLParser::EXP:
        case GQLParser::FLOOR:
        case GQLParser::LN:
        case GQLParser::LOG_KW:
        case GQLParser::LOG10:
        case GQLParser::MOD:
        case GQLParser::OCTET_LENGTH:
        case GQLParser::PATH_LENGTH:
        case GQLParser::POWER:
        case GQLParser::RADIANS:
        case GQLParser::SIN:
        case GQLParser::SINH:
        case GQLParser::SIZE:
        case GQLParser::SQRT:
        case GQLParser::TAN:
        case GQLParser::TANH: {
          {
            auto savedLocalCtx = _localctx;
            _localctx = _tracker.createInstance<antlr4::ParserRuleContext>();
            _localctx->copyFrom(savedLocalCtx);
          }
          _ctx = _localctx;
          previousContext = _localctx;
          auto ctxHolder = ctx->EnterNumericValueFunctionExprAlt();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          setState(4233);
          {
            auto childCtxHolder = ctx->EnterNumericValueFunction();
            numericValueFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
      _ctx->stop = _input->LT(-1);
      setState(4244);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 478, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          setState(4242);
          _errHandler->sync(this);
          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 477, _ctx)) {
          case 1: {
            auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
            auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
            newContext->copyFrom(newParentContext);
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleNumericValueExpression);
            auto ctxHolder = ctx->PushMultDivExprAlt2_NumericValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(4236);

            if (!(precpred(_ctx, 4))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 4)");
            setState(4237);
            _la = _input->LA(1);
            if (!(_la == GQLParser::ASTERISK

            || _la == GQLParser::SOLIDUS)) {
              _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              antlr4::Token * token = consume();
              ctx->OnToken(token);
            }
            setState(4238);
            {
              auto childCtxHolder = ctx->EnterNumericValueExpression();
              numericValueExpression(5, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 2: {
            auto newParentContext = _tracker.createInstance<antlr4::ParserRuleContext>(parentContext, parentState);
            auto newContext = _tracker.createInstance<antlr4::ParserRuleContext>();
            newContext->copyFrom(newParentContext);
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleNumericValueExpression);
            auto ctxHolder = ctx->PushAddSubtractExprAlt2_NumericValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(4239);

            if (!(precpred(_ctx, 3))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 3)");
            setState(4240);
            _la = _input->LA(1);
            if (!(_la == GQLParser::MINUS_SIGN

            || _la == GQLParser::PLUS_SIGN)) {
              _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              antlr4::Token * token = consume();
              ctx->OnToken(token);
            }
            setState(4241);
            {
              auto childCtxHolder = ctx->EnterNumericValueExpression();
              numericValueExpression(4, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          } 
        }
        setState(4246);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 478, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* numericValueFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 954, GQLParser::RuleNumericValueFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4260);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BYTE_LENGTH:
        case GQLParser::CHAR_LENGTH:
        case GQLParser::CHARACTER_LENGTH:
        case GQLParser::OCTET_LENGTH:
        case GQLParser::PATH_LENGTH: {
          enterOuterAlt(_localctx, 1);
          setState(4247);
          {
            auto childCtxHolder = ctx->EnterLengthExpression();
            lengthExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CARDINALITY:
        case GQLParser::SIZE: {
          enterOuterAlt(_localctx, 2);
          setState(4248);
          {
            auto childCtxHolder = ctx->EnterCardinalityExpression();
            cardinalityExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ABS: {
          enterOuterAlt(_localctx, 3);
          setState(4249);
          {
            auto childCtxHolder = ctx->EnterAbsoluteValueExpression();
            absoluteValueExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::MOD: {
          enterOuterAlt(_localctx, 4);
          setState(4250);
          {
            auto childCtxHolder = ctx->EnterModulusExpression();
            modulusExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ACOS:
        case GQLParser::ASIN:
        case GQLParser::ATAN:
        case GQLParser::COS:
        case GQLParser::COSH:
        case GQLParser::COT:
        case GQLParser::DEGREES:
        case GQLParser::RADIANS:
        case GQLParser::SIN:
        case GQLParser::SINH:
        case GQLParser::TAN:
        case GQLParser::TANH: {
          enterOuterAlt(_localctx, 5);
          setState(4251);
          {
            auto childCtxHolder = ctx->EnterTrigonometricFunction();
            trigonometricFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LOG_KW: {
          enterOuterAlt(_localctx, 6);
          setState(4252);
          {
            auto childCtxHolder = ctx->EnterGeneralLogarithmFunction();
            generalLogarithmFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LOG10: {
          enterOuterAlt(_localctx, 7);
          setState(4253);
          {
            auto childCtxHolder = ctx->EnterCommonLogarithm();
            commonLogarithm(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LN: {
          enterOuterAlt(_localctx, 8);
          setState(4254);
          {
            auto childCtxHolder = ctx->EnterNaturalLogarithm();
            naturalLogarithm(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::EXP: {
          enterOuterAlt(_localctx, 9);
          setState(4255);
          {
            auto childCtxHolder = ctx->EnterExponentialFunction();
            exponentialFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::POWER: {
          enterOuterAlt(_localctx, 10);
          setState(4256);
          {
            auto childCtxHolder = ctx->EnterPowerFunction();
            powerFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::SQRT: {
          enterOuterAlt(_localctx, 11);
          setState(4257);
          {
            auto childCtxHolder = ctx->EnterSquareRoot();
            squareRoot(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::FLOOR: {
          enterOuterAlt(_localctx, 12);
          setState(4258);
          {
            auto childCtxHolder = ctx->EnterFloorFunction();
            floorFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CEIL:
        case GQLParser::CEILING: {
          enterOuterAlt(_localctx, 13);
          setState(4259);
          {
            auto childCtxHolder = ctx->EnterCeilingFunction();
            ceilingFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* lengthExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 956, GQLParser::RuleLengthExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4265);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CHAR_LENGTH:
        case GQLParser::CHARACTER_LENGTH: {
          enterOuterAlt(_localctx, 1);
          setState(4262);
          {
            auto childCtxHolder = ctx->EnterCharLengthExpression();
            charLengthExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BYTE_LENGTH:
        case GQLParser::OCTET_LENGTH: {
          enterOuterAlt(_localctx, 2);
          setState(4263);
          {
            auto childCtxHolder = ctx->EnterByteLengthExpression();
            byteLengthExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::PATH_LENGTH: {
          enterOuterAlt(_localctx, 3);
          setState(4264);
          {
            auto childCtxHolder = ctx->EnterPathLengthExpression();
            pathLengthExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* cardinalityExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 958, GQLParser::RuleCardinalityExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4277);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CARDINALITY: {
          enterOuterAlt(_localctx, 1);
          setState(4267);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::CARDINALITY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::CARDINALITY);
          setState(4268);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(4269);
          {
            auto childCtxHolder = ctx->EnterCardinalityExpressionArgument();
            cardinalityExpressionArgument(get_raw_pointer(childCtxHolder));
          }
          setState(4270);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

        case GQLParser::SIZE: {
          enterOuterAlt(_localctx, 2);
          setState(4272);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::SIZE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::SIZE);
          setState(4273);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(4274);
          {
            auto childCtxHolder = ctx->EnterListValueExpression();
            listValueExpression(get_raw_pointer(childCtxHolder));
          }
          setState(4275);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* cardinalityExpressionArgument(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 960, GQLParser::RuleCardinalityExpressionArgument);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4279);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* charLengthExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 962, GQLParser::RuleCharLengthExpression);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4281);
      _la = _input->LA(1);
      if (!(_la == GQLParser::CHAR_LENGTH

      || _la == GQLParser::CHARACTER_LENGTH)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(4282);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4283);
      {
        auto childCtxHolder = ctx->EnterCharacterStringValueExpression();
        characterStringValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4284);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* byteLengthExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 964, GQLParser::RuleByteLengthExpression);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4286);
      _la = _input->LA(1);
      if (!(_la == GQLParser::BYTE_LENGTH || _la == GQLParser::OCTET_LENGTH)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(4287);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4288);
      {
        auto childCtxHolder = ctx->EnterByteStringValueExpression();
        byteStringValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4289);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathLengthExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 966, GQLParser::RulePathLengthExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4291);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::PATH_LENGTH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::PATH_LENGTH);
      setState(4292);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4293);
      {
        auto childCtxHolder = ctx->EnterPathValueExpression();
        pathValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4294);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* absoluteValueExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 968, GQLParser::RuleAbsoluteValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4296);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ABS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ABS);
      setState(4297);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4298);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4299);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* modulusExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 970, GQLParser::RuleModulusExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4301);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MOD) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MOD);
      setState(4302);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4303);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpressionDividend();
        numericValueExpressionDividend(get_raw_pointer(childCtxHolder));
      }
      setState(4304);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4305);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpressionDivisor();
        numericValueExpressionDivisor(get_raw_pointer(childCtxHolder));
      }
      setState(4306);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* numericValueExpressionDividend(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 972, GQLParser::RuleNumericValueExpressionDividend);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4308);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* numericValueExpressionDivisor(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 974, GQLParser::RuleNumericValueExpressionDivisor);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4310);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* trigonometricFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 976, GQLParser::RuleTrigonometricFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4312);
      {
        auto childCtxHolder = ctx->EnterTrigonometricFunctionName();
        trigonometricFunctionName(get_raw_pointer(childCtxHolder));
      }
      setState(4313);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4314);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4315);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* trigonometricFunctionName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 978, GQLParser::RuleTrigonometricFunctionName);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4317);
      _la = _input->LA(1);
      if (!(((((_la - 21) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 21)) & 18016322654833153) != 0) || ((((_la - 174) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 174)) & 3222011905) != 0))) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* generalLogarithmFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 980, GQLParser::RuleGeneralLogarithmFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4319);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LOG_KW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LOG_KW);
      setState(4320);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4321);
      {
        auto childCtxHolder = ctx->EnterGeneralLogarithmBase();
        generalLogarithmBase(get_raw_pointer(childCtxHolder));
      }
      setState(4322);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4323);
      {
        auto childCtxHolder = ctx->EnterGeneralLogarithmArgument();
        generalLogarithmArgument(get_raw_pointer(childCtxHolder));
      }
      setState(4324);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* generalLogarithmBase(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 982, GQLParser::RuleGeneralLogarithmBase);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4326);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* generalLogarithmArgument(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 984, GQLParser::RuleGeneralLogarithmArgument);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4328);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* commonLogarithm(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 986, GQLParser::RuleCommonLogarithm);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4330);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LOG10) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LOG10);
      setState(4331);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4332);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4333);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* naturalLogarithm(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 988, GQLParser::RuleNaturalLogarithm);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4335);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LN);
      setState(4336);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4337);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4338);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* exponentialFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 990, GQLParser::RuleExponentialFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4340);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EXP) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EXP);
      setState(4341);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4342);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4343);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* powerFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 992, GQLParser::RulePowerFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4345);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::POWER) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::POWER);
      setState(4346);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4347);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpressionBase();
        numericValueExpressionBase(get_raw_pointer(childCtxHolder));
      }
      setState(4348);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4349);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpressionExponent();
        numericValueExpressionExponent(get_raw_pointer(childCtxHolder));
      }
      setState(4350);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* numericValueExpressionBase(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 994, GQLParser::RuleNumericValueExpressionBase);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4352);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* numericValueExpressionExponent(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 996, GQLParser::RuleNumericValueExpressionExponent);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4354);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* squareRoot(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 998, GQLParser::RuleSquareRoot);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4356);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SQRT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SQRT);
      setState(4357);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4358);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4359);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* floorFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1000, GQLParser::RuleFloorFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4361);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::FLOOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::FLOOR);
      setState(4362);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4363);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4364);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* ceilingFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1002, GQLParser::RuleCeilingFunction);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4366);
      _la = _input->LA(1);
      if (!(_la == GQLParser::CEIL

      || _la == GQLParser::CEILING)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(4367);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4368);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4369);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* characterStringValueExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1004, GQLParser::RuleCharacterStringValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4371);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* byteStringValueExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1006, GQLParser::RuleByteStringValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4373);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* trimOperands(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1008, GQLParser::RuleTrimOperands);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4382);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 484, _ctx)) {
      case 1: {
        setState(4376);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::BOTH || _la == GQLParser::LEADING || _la == GQLParser::TRAILING) {
          setState(4375);
          {
            auto childCtxHolder = ctx->EnterTrimSpecification();
            trimSpecification(get_raw_pointer(childCtxHolder));
          }
        }
        setState(4379);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8762849302180528028) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 309341980913) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 129)) & -8011702113698201677) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 193)) & 26393111092643) != 0) || ((((_la - 277) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 277)) & 1686650837008383) != 0) || ((((_la - 369) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 369)) & 151) != 0)) {
          setState(4378);
          {
            auto childCtxHolder = ctx->EnterTrimCharacterOrByteString();
            trimCharacterOrByteString(get_raw_pointer(childCtxHolder));
          }
        }
        setState(4381);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::FROM) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::FROM);
        break;
      }

      default:
        break;
      }
      setState(4384);
      {
        auto childCtxHolder = ctx->EnterTrimCharacterOrByteStringSource();
        trimCharacterOrByteStringSource(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* trimCharacterOrByteStringSource(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1010, GQLParser::RuleTrimCharacterOrByteStringSource);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4386);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* trimSpecification(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1012, GQLParser::RuleTrimSpecification);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4388);
      _la = _input->LA(1);
      if (!(_la == GQLParser::BOTH || _la == GQLParser::LEADING || _la == GQLParser::TRAILING)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* trimCharacterOrByteString(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1014, GQLParser::RuleTrimCharacterOrByteString);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4390);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* normalForm(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1016, GQLParser::RuleNormalForm);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4392);
      _la = _input->LA(1);
      if (!(((((_la - 296) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 296)) & 15) != 0))) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* stringLength(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1018, GQLParser::RuleStringLength);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4394);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* datetimeValueExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1020, GQLParser::RuleDatetimeValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4396);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* datetimeValueFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1022, GQLParser::RuleDatetimeValueFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4403);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CURRENT_DATE:
        case GQLParser::DATE: {
          enterOuterAlt(_localctx, 1);
          setState(4398);
          {
            auto childCtxHolder = ctx->EnterDateFunction();
            dateFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CURRENT_TIME:
        case GQLParser::ZONED_TIME: {
          enterOuterAlt(_localctx, 2);
          setState(4399);
          {
            auto childCtxHolder = ctx->EnterTimeFunction();
            timeFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CURRENT_TIMESTAMP:
        case GQLParser::ZONED_DATETIME: {
          enterOuterAlt(_localctx, 3);
          setState(4400);
          {
            auto childCtxHolder = ctx->EnterDatetimeFunction();
            datetimeFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LOCAL_TIME: {
          enterOuterAlt(_localctx, 4);
          setState(4401);
          {
            auto childCtxHolder = ctx->EnterLocaltimeFunction();
            localtimeFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LOCAL_DATETIME:
        case GQLParser::LOCAL_TIMESTAMP: {
          enterOuterAlt(_localctx, 5);
          setState(4402);
          {
            auto childCtxHolder = ctx->EnterLocaldatetimeFunction();
            localdatetimeFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* dateFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1024, GQLParser::RuleDateFunction);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4412);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CURRENT_DATE: {
          enterOuterAlt(_localctx, 1);
          setState(4405);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::CURRENT_DATE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::CURRENT_DATE);
          break;
        }

        case GQLParser::DATE: {
          enterOuterAlt(_localctx, 2);
          setState(4406);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::DATE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::DATE);
          setState(4407);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(4409);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE

          || _la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParser::RECORD || _la == GQLParser::LEFT_BRACE) {
            setState(4408);
            {
              auto childCtxHolder = ctx->EnterDateFunctionParameters();
              dateFunctionParameters(get_raw_pointer(childCtxHolder));
            }
          }
          setState(4411);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* timeFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1026, GQLParser::RuleTimeFunction);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4421);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CURRENT_TIME: {
          enterOuterAlt(_localctx, 1);
          setState(4414);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::CURRENT_TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::CURRENT_TIME);
          break;
        }

        case GQLParser::ZONED_TIME: {
          enterOuterAlt(_localctx, 2);
          setState(4415);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONED_TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONED_TIME);
          setState(4416);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(4418);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE

          || _la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParser::RECORD || _la == GQLParser::LEFT_BRACE) {
            setState(4417);
            {
              auto childCtxHolder = ctx->EnterTimeFunctionParameters();
              timeFunctionParameters(get_raw_pointer(childCtxHolder));
            }
          }
          setState(4420);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* localtimeFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1028, GQLParser::RuleLocaltimeFunction);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4423);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LOCAL_TIME) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LOCAL_TIME);
      setState(4429);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 491, _ctx)) {
      case 1: {
        setState(4424);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(4426);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE

        || _la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParser::RECORD || _la == GQLParser::LEFT_BRACE) {
          setState(4425);
          {
            auto childCtxHolder = ctx->EnterTimeFunctionParameters();
            timeFunctionParameters(get_raw_pointer(childCtxHolder));
          }
        }
        setState(4428);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* datetimeFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1030, GQLParser::RuleDatetimeFunction);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4438);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CURRENT_TIMESTAMP: {
          enterOuterAlt(_localctx, 1);
          setState(4431);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::CURRENT_TIMESTAMP) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::CURRENT_TIMESTAMP);
          break;
        }

        case GQLParser::ZONED_DATETIME: {
          enterOuterAlt(_localctx, 2);
          setState(4432);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONED_DATETIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONED_DATETIME);
          setState(4433);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(4435);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE

          || _la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParser::RECORD || _la == GQLParser::LEFT_BRACE) {
            setState(4434);
            {
              auto childCtxHolder = ctx->EnterDatetimeFunctionParameters();
              datetimeFunctionParameters(get_raw_pointer(childCtxHolder));
            }
          }
          setState(4437);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* localdatetimeFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1032, GQLParser::RuleLocaldatetimeFunction);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4447);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LOCAL_TIMESTAMP: {
          enterOuterAlt(_localctx, 1);
          setState(4440);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LOCAL_TIMESTAMP) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LOCAL_TIMESTAMP);
          break;
        }

        case GQLParser::LOCAL_DATETIME: {
          enterOuterAlt(_localctx, 2);
          setState(4441);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LOCAL_DATETIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LOCAL_DATETIME);
          setState(4442);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(4444);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE

          || _la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParser::RECORD || _la == GQLParser::LEFT_BRACE) {
            setState(4443);
            {
              auto childCtxHolder = ctx->EnterDatetimeFunctionParameters();
              datetimeFunctionParameters(get_raw_pointer(childCtxHolder));
            }
          }
          setState(4446);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* dateFunctionParameters(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1034, GQLParser::RuleDateFunctionParameters);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4451);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 1);
          setState(4449);
          {
            auto childCtxHolder = ctx->EnterDateString();
            dateString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::RECORD:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(4450);
          {
            auto childCtxHolder = ctx->EnterRecordConstructor();
            recordConstructor(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* timeFunctionParameters(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1036, GQLParser::RuleTimeFunctionParameters);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4455);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 1);
          setState(4453);
          {
            auto childCtxHolder = ctx->EnterTimeString();
            timeString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::RECORD:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(4454);
          {
            auto childCtxHolder = ctx->EnterRecordConstructor();
            recordConstructor(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* datetimeFunctionParameters(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1038, GQLParser::RuleDatetimeFunctionParameters);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4459);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 1);
          setState(4457);
          {
            auto childCtxHolder = ctx->EnterDatetimeString();
            datetimeString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::RECORD:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(4458);
          {
            auto childCtxHolder = ctx->EnterRecordConstructor();
            recordConstructor(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* durationValueExpression(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1040, GQLParser::RuleDurationValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4461);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* datetimeSubtraction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1042, GQLParser::RuleDatetimeSubtraction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4463);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DURATION_BETWEEN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DURATION_BETWEEN);
      setState(4464);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4465);
      {
        auto childCtxHolder = ctx->EnterDatetimeSubtractionParameters();
        datetimeSubtractionParameters(get_raw_pointer(childCtxHolder));
      }
      setState(4466);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
      setState(4468);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 499, _ctx)) {
      case 1: {
        setState(4467);
        {
          auto childCtxHolder = ctx->EnterTemporalDurationQualifier();
          temporalDurationQualifier(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* datetimeSubtractionParameters(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1044, GQLParser::RuleDatetimeSubtractionParameters);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4470);
      {
        auto childCtxHolder = ctx->EnterDatetimeValueExpression1();
        datetimeValueExpression1(get_raw_pointer(childCtxHolder));
      }
      setState(4471);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4472);
      {
        auto childCtxHolder = ctx->EnterDatetimeValueExpression2();
        datetimeValueExpression2(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* datetimeValueExpression1(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1046, GQLParser::RuleDatetimeValueExpression1);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4474);
      {
        auto childCtxHolder = ctx->EnterDatetimeValueExpression();
        datetimeValueExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* datetimeValueExpression2(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1048, GQLParser::RuleDatetimeValueExpression2);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4476);
      {
        auto childCtxHolder = ctx->EnterDatetimeValueExpression();
        datetimeValueExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* durationValueFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1050, GQLParser::RuleDurationValueFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4480);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::DURATION: {
          enterOuterAlt(_localctx, 1);
          setState(4478);
          {
            auto childCtxHolder = ctx->EnterDurationFunction();
            durationFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ABS: {
          enterOuterAlt(_localctx, 2);
          setState(4479);
          {
            auto childCtxHolder = ctx->EnterAbsoluteValueExpression();
            absoluteValueExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* durationFunction(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1052, GQLParser::RuleDurationFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4482);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DURATION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DURATION);
      setState(4483);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4484);
      {
        auto childCtxHolder = ctx->EnterDurationFunctionParameters();
        durationFunctionParameters(get_raw_pointer(childCtxHolder));
      }
      setState(4485);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* durationFunctionParameters(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1054, GQLParser::RuleDurationFunctionParameters);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4489);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 1);
          setState(4487);
          {
            auto childCtxHolder = ctx->EnterDurationString();
            durationString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::RECORD:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(4488);
          {
            auto childCtxHolder = ctx->EnterRecordConstructor();
            recordConstructor(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* objectName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1056, GQLParser::RuleObjectName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4491);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* objectNameOrBindingVariable(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1058, GQLParser::RuleObjectNameOrBindingVariable);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4493);
      {
        auto childCtxHolder = ctx->EnterRegularIdentifier();
        regularIdentifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* directoryName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1060, GQLParser::RuleDirectoryName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4495);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* schemaName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1062, GQLParser::RuleSchemaName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4497);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1064, GQLParser::RuleGraphName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4501);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 1);
          setState(4499);
          {
            auto childCtxHolder = ctx->EnterRegularIdentifier();
            regularIdentifier(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 2);
          setState(4500);
          {
            auto childCtxHolder = ctx->EnterDelimitedGraphName();
            delimitedGraphName(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* delimitedGraphName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1066, GQLParser::RuleDelimitedGraphName);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4503);
      _la = _input->LA(1);
      if (!(_la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE

      || _la == GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* graphTypeName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1068, GQLParser::RuleGraphTypeName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4505);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nodeTypeName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1070, GQLParser::RuleNodeTypeName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4507);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeTypeName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1072, GQLParser::RuleEdgeTypeName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4509);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* bindingTableName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1074, GQLParser::RuleBindingTableName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4513);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 1);
          setState(4511);
          {
            auto childCtxHolder = ctx->EnterRegularIdentifier();
            regularIdentifier(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 2);
          setState(4512);
          {
            auto childCtxHolder = ctx->EnterDelimitedBindingTableName();
            delimitedBindingTableName(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* delimitedBindingTableName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1076, GQLParser::RuleDelimitedBindingTableName);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4515);
      _la = _input->LA(1);
      if (!(_la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE

      || _la == GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* procedureName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1078, GQLParser::RuleProcedureName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4517);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* labelName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1080, GQLParser::RuleLabelName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4519);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* propertyName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1082, GQLParser::RulePropertyName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4521);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* fieldName(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1084, GQLParser::RuleFieldName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4523);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* elementVariable(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1086, GQLParser::RuleElementVariable);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4525);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* pathVariable(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1088, GQLParser::RulePathVariable);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4527);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* subpathVariable(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1090, GQLParser::RuleSubpathVariable);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4529);
      {
        auto childCtxHolder = ctx->EnterRegularIdentifier();
        regularIdentifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* bindingVariable(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1092, GQLParser::RuleBindingVariable);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4531);
      {
        auto childCtxHolder = ctx->EnterRegularIdentifier();
        regularIdentifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* unsignedLiteral(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1094, GQLParser::RuleUnsignedLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4535);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER: {
          enterOuterAlt(_localctx, 1);
          setState(4533);
          {
            auto childCtxHolder = ctx->EnterUnsignedNumericLiteral();
            unsignedNumericLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BOOLEAN_LITERAL:
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::BYTE_STRING_LITERAL:
        case GQLParser::ARRAY:
        case GQLParser::DATE:
        case GQLParser::DATETIME:
        case GQLParser::DURATION:
        case GQLParser::GROUP:
        case GQLParser::LIST:
        case GQLParser::NULL_KW:
        case GQLParser::RECORD:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::LEFT_BRACE:
        case GQLParser::LEFT_BRACKET: {
          enterOuterAlt(_localctx, 2);
          setState(4534);
          {
            auto childCtxHolder = ctx->EnterGeneralLiteral();
            generalLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* generalLiteral(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1096, GQLParser::RuleGeneralLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4545);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BOOLEAN_LITERAL: {
          enterOuterAlt(_localctx, 1);
          setState(4537);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::BOOLEAN_LITERAL) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::BOOLEAN_LITERAL);
          break;
        }

        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 2);
          setState(4538);
          {
            auto childCtxHolder = ctx->EnterCharacterStringLiteral();
            characterStringLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BYTE_STRING_LITERAL: {
          enterOuterAlt(_localctx, 3);
          setState(4539);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::BYTE_STRING_LITERAL) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::BYTE_STRING_LITERAL);
          break;
        }

        case GQLParser::DATE:
        case GQLParser::DATETIME:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP: {
          enterOuterAlt(_localctx, 4);
          setState(4540);
          {
            auto childCtxHolder = ctx->EnterTemporalLiteral();
            temporalLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DURATION: {
          enterOuterAlt(_localctx, 5);
          setState(4541);
          {
            auto childCtxHolder = ctx->EnterDurationLiteral();
            durationLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::NULL_KW: {
          enterOuterAlt(_localctx, 6);
          setState(4542);
          {
            auto childCtxHolder = ctx->EnterNullLiteral();
            nullLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ARRAY:
        case GQLParser::GROUP:
        case GQLParser::LIST:
        case GQLParser::LEFT_BRACKET: {
          enterOuterAlt(_localctx, 7);
          setState(4543);
          {
            auto childCtxHolder = ctx->EnterListLiteral();
            listLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::RECORD:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 8);
          setState(4544);
          {
            auto childCtxHolder = ctx->EnterRecordLiteral();
            recordLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* temporalLiteral(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1098, GQLParser::RuleTemporalLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4550);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::DATE: {
          enterOuterAlt(_localctx, 1);
          setState(4547);
          {
            auto childCtxHolder = ctx->EnterDateLiteral();
            dateLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::TIME: {
          enterOuterAlt(_localctx, 2);
          setState(4548);
          {
            auto childCtxHolder = ctx->EnterTimeLiteral();
            timeLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DATETIME:
        case GQLParser::TIMESTAMP: {
          enterOuterAlt(_localctx, 3);
          setState(4549);
          {
            auto childCtxHolder = ctx->EnterDatetimeLiteral();
            datetimeLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* dateLiteral(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1100, GQLParser::RuleDateLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4552);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DATE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DATE);
      setState(4553);
      {
        auto childCtxHolder = ctx->EnterDateString();
        dateString(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* timeLiteral(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1102, GQLParser::RuleTimeLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4555);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TIME) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TIME);
      setState(4556);
      {
        auto childCtxHolder = ctx->EnterTimeString();
        timeString(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* datetimeLiteral(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1104, GQLParser::RuleDatetimeLiteral);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4558);
      _la = _input->LA(1);
      if (!(_la == GQLParser::DATETIME || _la == GQLParser::TIMESTAMP)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(4559);
      {
        auto childCtxHolder = ctx->EnterDatetimeString();
        datetimeString(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* listLiteral(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1106, GQLParser::RuleListLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4561);
      {
        auto childCtxHolder = ctx->EnterListValueConstructorByEnumeration();
        listValueConstructorByEnumeration(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* recordLiteral(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1108, GQLParser::RuleRecordLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4563);
      {
        auto childCtxHolder = ctx->EnterRecordConstructor();
        recordConstructor(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* identifier(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1110, GQLParser::RuleIdentifier);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4568);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 1);
          setState(4565);
          {
            auto childCtxHolder = ctx->EnterRegularIdentifier();
            regularIdentifier(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 2);
          setState(4566);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE);
          break;
        }

        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 3);
          setState(4567);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* regularIdentifier(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1112, GQLParser::RuleRegularIdentifier);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4572);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 1);
          setState(4570);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::REGULAR_IDENTIFIER) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::REGULAR_IDENTIFIER);
          break;
        }

        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE: {
          enterOuterAlt(_localctx, 2);
          setState(4571);
          {
            auto childCtxHolder = ctx->EnterNonReservedWords();
            nonReservedWords(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* timeZoneString(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1114, GQLParser::RuleTimeZoneString);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4574);
      {
        auto childCtxHolder = ctx->EnterCharacterStringLiteral();
        characterStringLiteral(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* characterStringLiteral(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1116, GQLParser::RuleCharacterStringLiteral);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4576);
      _la = _input->LA(1);
      if (!(_la == GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE

      || _la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* unsignedNumericLiteral(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1118, GQLParser::RuleUnsignedNumericLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4580);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER: {
          enterOuterAlt(_localctx, 1);
          setState(4578);
          {
            auto childCtxHolder = ctx->EnterExactNumericLiteral();
            exactNumericLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX: {
          enterOuterAlt(_localctx, 2);
          setState(4579);
          {
            auto childCtxHolder = ctx->EnterApproximateNumericLiteral();
            approximateNumericLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* exactNumericLiteral(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1120, GQLParser::RuleExactNumericLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4587);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX: {
          enterOuterAlt(_localctx, 1);
          setState(4582);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX);
          break;
        }

        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX: {
          enterOuterAlt(_localctx, 2);
          setState(4583);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX);
          break;
        }

        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX: {
          enterOuterAlt(_localctx, 3);
          setState(4584);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX);
          break;
        }

        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX: {
          enterOuterAlt(_localctx, 4);
          setState(4585);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX);
          break;
        }

        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER: {
          enterOuterAlt(_localctx, 5);
          setState(4586);
          {
            auto childCtxHolder = ctx->EnterUnsignedInteger();
            unsignedInteger(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* approximateNumericLiteral(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1122, GQLParser::RuleApproximateNumericLiteral);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4589);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 42496) != 0))) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* unsignedInteger(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1124, GQLParser::RuleUnsignedInteger);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4591);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 983040) != 0))) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* unsignedDecimalInteger(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1126, GQLParser::RuleUnsignedDecimalInteger);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4593);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::UNSIGNED_DECIMAL_INTEGER) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::UNSIGNED_DECIMAL_INTEGER);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nullLiteral(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1128, GQLParser::RuleNullLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4595);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NULL_KW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NULL_KW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* dateString(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1130, GQLParser::RuleDateString);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4597);
      {
        auto childCtxHolder = ctx->EnterCharacterStringLiteral();
        characterStringLiteral(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* timeString(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1132, GQLParser::RuleTimeString);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4599);
      {
        auto childCtxHolder = ctx->EnterCharacterStringLiteral();
        characterStringLiteral(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* datetimeString(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1134, GQLParser::RuleDatetimeString);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4601);
      {
        auto childCtxHolder = ctx->EnterCharacterStringLiteral();
        characterStringLiteral(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* durationLiteral(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1136, GQLParser::RuleDurationLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4603);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DURATION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DURATION);
      setState(4604);
      {
        auto childCtxHolder = ctx->EnterDurationString();
        durationString(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* durationString(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1138, GQLParser::RuleDurationString);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4606);
      {
        auto childCtxHolder = ctx->EnterCharacterStringLiteral();
        characterStringLiteral(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nodeSynonym(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1140, GQLParser::RuleNodeSynonym);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4608);
      _la = _input->LA(1);
      if (!(_la == GQLParser::NODE

      || _la == GQLParser::VERTEX)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgesSynonym(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1142, GQLParser::RuleEdgesSynonym);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4610);
      _la = _input->LA(1);
      if (!(_la == GQLParser::EDGES

      || _la == GQLParser::RELATIONSHIPS)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* edgeSynonym(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1144, GQLParser::RuleEdgeSynonym);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4612);
      _la = _input->LA(1);
      if (!(_la == GQLParser::EDGE

      || _la == GQLParser::RELATIONSHIP)) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  template<typename ContextT>
  antlr4::ParserRuleContext* nonReservedWords(ContextT* ctx) {
    antlr4::ParserRuleContext *_localctx = _tracker.createInstance<antlr4::ParserRuleContext>(_ctx, getState());
    enterRule(_localctx, 1146, GQLParser::RuleNonReservedWords);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4614);
      _la = _input->LA(1);
      if (!(((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 279275953455103) != 0))) {
        _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }


  bool sempred(antlr4::RuleContext *_localctx, size_t ruleIndex, size_t predicateIndex) override;

  bool compositeQueryExpressionSempred(antlr4::ParserRuleContext *_localctx, size_t predicateIndex);
  bool labelExpressionSempred(antlr4::ParserRuleContext *_localctx, size_t predicateIndex);
  bool simplifiedTermSempred(antlr4::ParserRuleContext *_localctx, size_t predicateIndex);
  bool simplifiedFactorLowSempred(antlr4::ParserRuleContext *_localctx, size_t predicateIndex);
  bool valueTypeSempred(antlr4::ParserRuleContext *_localctx, size_t predicateIndex);
  bool valueExpressionSempred(antlr4::ParserRuleContext *_localctx, size_t predicateIndex);
  bool valueExpressionPrimarySempred(antlr4::ParserRuleContext *_localctx, size_t predicateIndex);
  bool numericValueExpressionSempred(antlr4::ParserRuleContext *_localctx, size_t predicateIndex);

  // By default the static state used to implement the parser is lazily initialized during the first
  // call to the constructor. You can call this function if you wish to initialize the static state
  // ahead of time.
  static void initialize();

private:
};

#ifdef _MSC_VER
#pragma warning( pop )
#endif

