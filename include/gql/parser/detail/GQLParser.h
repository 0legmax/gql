// Copyright 2025 Oleg Maximenko
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.



#pragma once


#include <type_traits>
#include "antlr4-runtime.h"



#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable : 4456 4457 )
#endif


class  GQLParser : public antlr4::Parser {
public:
  enum {
    IMPLIES = 1, BOOLEAN_LITERAL = 2, SINGLE_QUOTED_CHARACTER_SEQUENCE = 3, 
    DOUBLE_QUOTED_CHARACTER_SEQUENCE = 4, ACCENT_QUOTED_CHARACTER_SEQUENCE = 5, 
    NO_ESCAPE = 6, BYTE_STRING_LITERAL = 7, UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX = 8, 
    UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX = 9, UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX = 10, 
    UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX = 11, UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX = 12, 
    UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX = 13, 
    UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX = 14, UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX = 15, 
    UNSIGNED_DECIMAL_INTEGER = 16, UNSIGNED_HEXADECIMAL_INTEGER = 17, UNSIGNED_OCTAL_INTEGER = 18, 
    UNSIGNED_BINARY_INTEGER = 19, ABS = 20, ACOS = 21, ALL = 22, ALL_DIFFERENT = 23, 
    AND = 24, ANY = 25, ARRAY = 26, AS = 27, ASC = 28, ASCENDING = 29, ASIN = 30, 
    AT = 31, ATAN = 32, AVG = 33, BIG = 34, BIGINT = 35, BINARY = 36, BOOL = 37, 
    BOOLEAN = 38, BOTH = 39, BTRIM = 40, BY = 41, BYTE_LENGTH = 42, BYTES = 43, 
    CALL = 44, CARDINALITY = 45, CASE = 46, CAST = 47, CEIL = 48, CEILING = 49, 
    CHAR = 50, CHAR_LENGTH = 51, CHARACTER_LENGTH = 52, CHARACTERISTICS = 53, 
    CLOSE = 54, COALESCE = 55, COLLECT_LIST = 56, COMMIT = 57, COPY = 58, 
    COS = 59, COSH = 60, COT = 61, COUNT = 62, CREATE = 63, CURRENT_DATE = 64, 
    CURRENT_GRAPH = 65, CURRENT_PROPERTY_GRAPH = 66, CURRENT_SCHEMA = 67, 
    CURRENT_TIME = 68, CURRENT_TIMESTAMP = 69, DATE = 70, DATETIME = 71, 
    DAY = 72, DEC = 73, DECIMAL = 74, DEGREES = 75, DELETE = 76, DESC = 77, 
    DESCENDING = 78, DETACH = 79, DISTINCT = 80, DOUBLE = 81, DROP = 82, 
    DURATION = 83, DURATION_BETWEEN = 84, ELEMENT_ID = 85, ELSE = 86, END = 87, 
    EXCEPT = 88, EXISTS = 89, EXP = 90, FILTER = 91, FINISH = 92, FLOAT = 93, 
    FLOAT16 = 94, FLOAT32 = 95, FLOAT64 = 96, FLOAT128 = 97, FLOAT256 = 98, 
    FLOOR = 99, FOR = 100, FROM = 101, GROUP = 102, HAVING = 103, HOME_GRAPH = 104, 
    HOME_PROPERTY_GRAPH = 105, HOME_SCHEMA = 106, HOUR = 107, IF = 108, 
    IN = 109, INSERT = 110, INT = 111, INTEGER = 112, INT8 = 113, INTEGER8 = 114, 
    INT16 = 115, INTEGER16 = 116, INT32 = 117, INTEGER32 = 118, INT64 = 119, 
    INTEGER64 = 120, INT128 = 121, INTEGER128 = 122, INT256 = 123, INTEGER256 = 124, 
    INTERSECT = 125, INTERVAL = 126, IS = 127, LEADING = 128, LEFT = 129, 
    LET = 130, LIKE = 131, LIMIT = 132, LIST = 133, LN = 134, LOCAL = 135, 
    LOCAL_DATETIME = 136, LOCAL_TIME = 137, LOCAL_TIMESTAMP = 138, LOG_KW = 139, 
    LOG10 = 140, LOWER = 141, LTRIM = 142, MATCH = 143, MAX = 144, MIN = 145, 
    MINUTE = 146, MOD = 147, MONTH = 148, NEXT = 149, NODETACH = 150, NORMALIZE = 151, 
    NOT = 152, NOTHING = 153, NULL_KW = 154, NULLS = 155, NULLIF = 156, 
    OCTET_LENGTH = 157, OF = 158, OFFSET = 159, OPTIONAL = 160, OR = 161, 
    ORDER = 162, OTHERWISE = 163, PARAMETER = 164, PARAMETERS = 165, PATH = 166, 
    PATH_LENGTH = 167, PATHS = 168, PERCENTILE_CONT = 169, PERCENTILE_DISC = 170, 
    POWER = 171, PRECISION = 172, PROPERTY_EXISTS = 173, RADIANS = 174, 
    REAL = 175, RECORD = 176, REMOVE = 177, REPLACE = 178, RESET = 179, 
    RETURN = 180, RIGHT = 181, ROLLBACK = 182, RTRIM = 183, SAME = 184, 
    SCHEMA = 185, SECOND = 186, SELECT = 187, SESSION = 188, SESSION_USER = 189, 
    SET = 190, SIGNED = 191, SIN = 192, SINH = 193, SIZE = 194, SKIP_RESERVED_WORD = 195, 
    SMALL = 196, SMALLINT = 197, SQRT = 198, START = 199, STDDEV_POP = 200, 
    STDDEV_SAMP = 201, STRING = 202, SUM = 203, TAN = 204, TANH = 205, THEN = 206, 
    TIME = 207, TIMESTAMP = 208, TRAILING = 209, TRIM = 210, TYPED = 211, 
    UBIGINT = 212, UINT = 213, UINT8 = 214, UINT16 = 215, UINT32 = 216, 
    UINT64 = 217, UINT128 = 218, UINT256 = 219, UNION = 220, UNSIGNED = 221, 
    UPPER = 222, USE = 223, USMALLINT = 224, VALUE = 225, VARBINARY = 226, 
    VARCHAR = 227, VARIABLE = 228, WHEN = 229, WHERE = 230, WITH = 231, 
    XOR = 232, YEAR = 233, YIELD = 234, ZONED = 235, ZONED_DATETIME = 236, 
    ZONED_TIME = 237, ABSTRACT = 238, AGGREGATE = 239, AGGREGATES = 240, 
    ALTER = 241, CATALOG = 242, CLEAR = 243, CLONE = 244, CONSTRAINT = 245, 
    CURRENT_ROLE = 246, CURRENT_USER = 247, DATA = 248, DIRECTORY = 249, 
    DRYRUN = 250, EXACT = 251, EXISTING = 252, FUNCTION = 253, GQLSTATUS = 254, 
    GRANT = 255, INSTANT = 256, INFINITY_KW = 257, NUMBER = 258, NUMERIC = 259, 
    ON = 260, OPEN = 261, PARTITION = 262, PROCEDURE = 263, PRODUCT = 264, 
    PROJECT = 265, QUERY = 266, RECORDS = 267, REFERENCE = 268, RENAME = 269, 
    REVOKE = 270, SUBSTRING = 271, SYSTEM_USER = 272, TEMPORAL = 273, UNIQUE = 274, 
    UNIT = 275, VALUES = 276, ACYCLIC = 277, BINDING = 278, BINDINGS = 279, 
    CONNECTING = 280, DESTINATION = 281, DIFFERENT = 282, DIRECTED = 283, 
    EDGE = 284, EDGES = 285, ELEMENT = 286, ELEMENTS = 287, FIRST = 288, 
    GRAPH = 289, GROUPS = 290, KEEP = 291, LABEL = 292, LABELED = 293, LABELS = 294, 
    LAST = 295, NFC = 296, NFD = 297, NFKC = 298, NFKD = 299, NO = 300, 
    NODE = 301, NORMALIZED = 302, ONLY = 303, ORDINALITY = 304, PROPERTY = 305, 
    READ = 306, RELATIONSHIP = 307, RELATIONSHIPS = 308, REPEATABLE = 309, 
    SHORTEST = 310, SIMPLE = 311, SOURCE = 312, TABLE = 313, TEMP = 314, 
    TO = 315, TRAIL = 316, TRANSACTION = 317, TYPE = 318, UNDIRECTED = 319, 
    VERTEX = 320, WALK = 321, WITHOUT = 322, WRITE = 323, ZONE = 324, REGULAR_IDENTIFIER = 325, 
    SUBSTITUTED_PARAMETER_REFERENCE = 326, GENERAL_PARAMETER_REFERENCE = 327, 
    MULTISET_ALTERNATION_OPERATOR = 328, BRACKET_RIGHT_ARROW = 329, BRACKET_TILDE_RIGHT_ARROW = 330, 
    CONCATENATION_OPERATOR = 331, DOUBLE_COLON = 332, DOUBLE_DOLLAR_SIGN = 333, 
    DOUBLE_PERIOD = 334, GREATER_THAN_OR_EQUALS_OPERATOR = 335, LEFT_ARROW = 336, 
    LEFT_ARROW_TILDE = 337, LEFT_ARROW_BRACKET = 338, LEFT_ARROW_TILDE_BRACKET = 339, 
    LEFT_MINUS_RIGHT = 340, LEFT_MINUS_SLASH = 341, LEFT_TILDE_SLASH = 342, 
    LESS_THAN_OR_EQUALS_OPERATOR = 343, MINUS_LEFT_BRACKET = 344, MINUS_SLASH = 345, 
    NOT_EQUALS_OPERATOR = 346, RIGHT_ARROW = 347, RIGHT_BRACKET_MINUS = 348, 
    RIGHT_BRACKET_TILDE = 349, RIGHT_DOUBLE_ARROW = 350, SLASH_MINUS = 351, 
    SLASH_MINUS_RIGHT = 352, SLASH_TILDE = 353, SLASH_TILDE_RIGHT = 354, 
    TILDE_LEFT_BRACKET = 355, TILDE_RIGHT_ARROW = 356, TILDE_SLASH = 357, 
    AMPERSAND = 358, ASTERISK = 359, COLON = 360, COMMA = 361, COMMERCIAL_AT = 362, 
    DOLLAR_SIGN = 363, DOUBLE_QUOTE = 364, EQUALS_OPERATOR = 365, EXCLAMATION_MARK = 366, 
    RIGHT_ANGLE_BRACKET = 367, GRAVE_ACCENT = 368, LEFT_BRACE = 369, LEFT_BRACKET = 370, 
    LEFT_PAREN = 371, LEFT_ANGLE_BRACKET = 372, MINUS_SIGN = 373, PERCENT = 374, 
    PERIOD = 375, PLUS_SIGN = 376, QUESTION_MARK = 377, QUOTE = 378, REVERSE_SOLIDUS = 379, 
    RIGHT_BRACE = 380, RIGHT_BRACKET = 381, RIGHT_PAREN = 382, SOLIDUS = 383, 
    TILDE = 384, UNDERSCORE = 385, VERTICAL_BAR = 386, SP = 387, WHITESPACE = 388, 
    BRACKETED_COMMENT = 389, SIMPLE_COMMENT_SOLIDUS = 390, SIMPLE_COMMENT_MINUS = 391
  };

  enum {
    RuleGqlProgram = 0, RuleProgramActivity = 1, RuleSessionActivity = 2, 
    RuleTransactionActivity = 3, RuleEndTransactionCommand = 4, RuleSessionSetCommand = 5, 
    RuleSessionSetSchemaClause = 6, RuleSessionSetGraphClause = 7, RuleSessionSetTimeZoneClause = 8, 
    RuleSetTimeZoneValue = 9, RuleSessionSetParameterClause = 10, RuleSessionSetGraphParameterClause = 11, 
    RuleSessionSetBindingTableParameterClause = 12, RuleSessionSetValueParameterClause = 13, 
    RuleSessionSetParameterName = 14, RuleSessionResetCommand = 15, RuleSessionResetArguments = 16, 
    RuleSessionCloseCommand = 17, RuleSessionParameterSpecification = 18, 
    RuleStartTransactionCommand = 19, RuleTransactionCharacteristics = 20, 
    RuleTransactionMode = 21, RuleTransactionAccessMode = 22, RuleRollbackCommand = 23, 
    RuleCommitCommand = 24, RuleNestedProcedureSpecification = 25, RuleProcedureSpecification = 26, 
    RuleNestedDataModifyingProcedureSpecification = 27, RuleNestedQuerySpecification = 28, 
    RuleProcedureBody = 29, RuleBindingVariableDefinitionBlock = 30, RuleBindingVariableDefinition = 31, 
    RuleStatementBlock = 32, RuleStatement = 33, RuleNextStatement = 34, 
    RuleGraphVariableDefinition = 35, RuleOptTypedGraphInitializer = 36, 
    RuleGraphInitializer = 37, RuleBindingTableVariableDefinition = 38, 
    RuleOptTypedBindingTableInitializer = 39, RuleBindingTableInitializer = 40, 
    RuleValueVariableDefinition = 41, RuleOptTypedValueInitializer = 42, 
    RuleValueInitializer = 43, RuleGraphExpression = 44, RuleCurrentGraph = 45, 
    RuleBindingTableExpression = 46, RuleNestedBindingTableQuerySpecification = 47, 
    RuleObjectExpressionPrimary = 48, RuleLinearCatalogModifyingStatement = 49, 
    RuleSimpleCatalogModifyingStatement = 50, RulePrimitiveCatalogModifyingStatement = 51, 
    RuleCreateSchemaStatement = 52, RuleDropSchemaStatement = 53, RuleCreateGraphStatement = 54, 
    RuleOpenGraphType = 55, RuleOfGraphType = 56, RuleGraphTypeLikeGraph = 57, 
    RuleGraphSource = 58, RuleDropGraphStatement = 59, RuleCreateGraphTypeStatement = 60, 
    RuleGraphTypeSource = 61, RuleCopyOfGraphType = 62, RuleDropGraphTypeStatement = 63, 
    RuleCallCatalogModifyingProcedureStatement = 64, RuleLinearDataModifyingStatement = 65, 
    RuleFocusedLinearDataModifyingStatement = 66, RuleFocusedLinearDataModifyingStatementBody = 67, 
    RuleFocusedNestedDataModifyingProcedureSpecification = 68, RuleAmbientLinearDataModifyingStatement = 69, 
    RuleAmbientLinearDataModifyingStatementBody = 70, RuleSimpleLinearDataAccessingStatement = 71, 
    RuleSimpleDataAccessingStatement = 72, RuleSimpleDataModifyingStatement = 73, 
    RulePrimitiveDataModifyingStatement = 74, RuleInsertStatement = 75, 
    RuleSetStatement = 76, RuleSetItemList = 77, RuleSetItem = 78, RuleSetPropertyItem = 79, 
    RuleSetAllPropertiesItem = 80, RuleSetLabelItem = 81, RuleRemoveStatement = 82, 
    RuleRemoveItemList = 83, RuleRemoveItem = 84, RuleRemovePropertyItem = 85, 
    RuleRemoveLabelItem = 86, RuleDeleteStatement = 87, RuleDeleteItemList = 88, 
    RuleDeleteItem = 89, RuleCallDataModifyingProcedureStatement = 90, RuleCompositeQueryStatement = 91, 
    RuleCompositeQueryExpression = 92, RuleQueryConjunction = 93, RuleSetOperator = 94, 
    RuleCompositeQueryPrimary = 95, RuleLinearQueryStatement = 96, RuleFocusedLinearQueryStatement = 97, 
    RuleFocusedLinearQueryStatementPart = 98, RuleFocusedLinearQueryAndPrimitiveResultStatementPart = 99, 
    RuleFocusedPrimitiveResultStatement = 100, RuleFocusedNestedQuerySpecification = 101, 
    RuleAmbientLinearQueryStatement = 102, RuleSimpleLinearQueryStatement = 103, 
    RuleSimpleQueryStatement = 104, RulePrimitiveQueryStatement = 105, RuleMatchStatement = 106, 
    RuleSimpleMatchStatement = 107, RuleOptionalMatchStatement = 108, RuleOptionalOperand = 109, 
    RuleMatchStatementBlock = 110, RuleCallQueryStatement = 111, RuleFilterStatement = 112, 
    RuleLetStatement = 113, RuleLetVariableDefinitionList = 114, RuleLetVariableDefinition = 115, 
    RuleForStatement = 116, RuleForItem = 117, RuleForItemAlias = 118, RuleForItemSource = 119, 
    RuleForOrdinalityOrOffset = 120, RuleOrderByAndPageStatement = 121, 
    RulePrimitiveResultStatement = 122, RuleReturnStatement = 123, RuleReturnStatementBody = 124, 
    RuleReturnItemList = 125, RuleReturnItem = 126, RuleReturnItemAlias = 127, 
    RuleSelectStatement = 128, RuleSelectItemList = 129, RuleSelectItem = 130, 
    RuleSelectItemAlias = 131, RuleHavingClause = 132, RuleSelectStatementBody = 133, 
    RuleSelectGraphMatchList = 134, RuleSelectGraphMatch = 135, RuleSelectQuerySpecification = 136, 
    RuleCallProcedureStatement = 137, RuleProcedureCall = 138, RuleInlineProcedureCall = 139, 
    RuleVariableScopeClause = 140, RuleBindingVariableReferenceList = 141, 
    RuleNamedProcedureCall = 142, RuleProcedureArgumentList = 143, RuleProcedureArgument = 144, 
    RuleAtSchemaClause = 145, RuleUseGraphClause = 146, RuleGraphPatternBindingTable = 147, 
    RuleGraphPatternYieldClause = 148, RuleGraphPatternYieldItemList = 149, 
    RuleGraphPatternYieldItem = 150, RuleGraphPattern = 151, RuleMatchMode = 152, 
    RuleRepeatableElementsMatchMode = 153, RuleDifferentEdgesMatchMode = 154, 
    RuleElementBindingsOrElements = 155, RuleEdgeBindingsOrEdges = 156, 
    RulePathPatternList = 157, RulePathPattern = 158, RulePathVariableDeclaration = 159, 
    RuleKeepClause = 160, RuleGraphPatternWhereClause = 161, RuleInsertGraphPattern = 162, 
    RuleInsertPathPatternList = 163, RuleInsertPathPattern = 164, RuleInsertNodePattern = 165, 
    RuleInsertEdgePattern = 166, RuleInsertEdgePointingLeft = 167, RuleInsertEdgePointingRight = 168, 
    RuleInsertEdgeUndirected = 169, RuleInsertElementPatternFiller = 170, 
    RuleLabelAndPropertySetSpecification = 171, RulePathPatternPrefix = 172, 
    RulePathModePrefix = 173, RulePathMode = 174, RulePathSearchPrefix = 175, 
    RuleAllPathSearch = 176, RulePathOrPaths = 177, RuleAnyPathSearch = 178, 
    RuleNumberOfPaths = 179, RuleShortestPathSearch = 180, RuleAllShortestPathSearch = 181, 
    RuleAnyShortestPathSearch = 182, RuleCountedShortestPathSearch = 183, 
    RuleCountedShortestGroupSearch = 184, RuleNumberOfGroups = 185, RulePathPatternExpression = 186, 
    RulePathTerm = 187, RulePathFactor = 188, RulePathPrimary = 189, RuleElementPattern = 190, 
    RuleNodePattern = 191, RuleElementPatternFiller = 192, RuleElementVariableDeclaration = 193, 
    RuleIsLabelExpression = 194, RuleIsOrColon = 195, RuleElementPatternPredicate = 196, 
    RuleElementPatternWhereClause = 197, RuleElementPropertySpecification = 198, 
    RulePropertyKeyValuePairList = 199, RulePropertyKeyValuePair = 200, 
    RuleEdgePattern = 201, RuleFullEdgePattern = 202, RuleFullEdgePointingLeft = 203, 
    RuleFullEdgeUndirected = 204, RuleFullEdgePointingRight = 205, RuleFullEdgeLeftOrUndirected = 206, 
    RuleFullEdgeUndirectedOrRight = 207, RuleFullEdgeLeftOrRight = 208, 
    RuleFullEdgeAnyDirection = 209, RuleAbbreviatedEdgePattern = 210, RuleParenthesizedPathPatternExpression = 211, 
    RuleSubpathVariableDeclaration = 212, RuleParenthesizedPathPatternWhereClause = 213, 
    RuleLabelExpression = 214, RulePathVariableReference = 215, RuleElementVariableReference = 216, 
    RuleGraphPatternQuantifier = 217, RuleFixedQuantifier = 218, RuleGeneralQuantifier = 219, 
    RuleLowerBound = 220, RuleUpperBound = 221, RuleSimplifiedPathPatternExpression = 222, 
    RuleSimplifiedDefaultingLeft = 223, RuleSimplifiedDefaultingUndirected = 224, 
    RuleSimplifiedDefaultingRight = 225, RuleSimplifiedDefaultingLeftOrUndirected = 226, 
    RuleSimplifiedDefaultingUndirectedOrRight = 227, RuleSimplifiedDefaultingLeftOrRight = 228, 
    RuleSimplifiedDefaultingAnyDirection = 229, RuleSimplifiedContents = 230, 
    RuleSimplifiedPathUnion = 231, RuleSimplifiedMultisetAlternation = 232, 
    RuleSimplifiedTerm = 233, RuleSimplifiedFactorLow = 234, RuleSimplifiedFactorHigh = 235, 
    RuleSimplifiedQuantified = 236, RuleSimplifiedQuestioned = 237, RuleSimplifiedTertiary = 238, 
    RuleSimplifiedDirectionOverride = 239, RuleSimplifiedOverrideLeft = 240, 
    RuleSimplifiedOverrideUndirected = 241, RuleSimplifiedOverrideRight = 242, 
    RuleSimplifiedOverrideLeftOrUndirected = 243, RuleSimplifiedOverrideUndirectedOrRight = 244, 
    RuleSimplifiedOverrideLeftOrRight = 245, RuleSimplifiedOverrideAnyDirection = 246, 
    RuleSimplifiedSecondary = 247, RuleSimplifiedNegation = 248, RuleSimplifiedPrimary = 249, 
    RuleWhereClause = 250, RuleYieldClause = 251, RuleYieldItemList = 252, 
    RuleYieldItem = 253, RuleYieldItemName = 254, RuleYieldItemAlias = 255, 
    RuleGroupByClause = 256, RuleGroupingElementList = 257, RuleGroupingElement = 258, 
    RuleEmptyGroupingSet = 259, RuleOrderByClause = 260, RuleSortSpecificationList = 261, 
    RuleSortSpecification = 262, RuleSortKey = 263, RuleOrderingSpecification = 264, 
    RuleNullOrdering = 265, RuleLimitClause = 266, RuleOffsetClause = 267, 
    RuleOffsetSynonym = 268, RuleSchemaReference = 269, RuleAbsoluteCatalogSchemaReference = 270, 
    RuleCatalogSchemaParentAndName = 271, RuleRelativeCatalogSchemaReference = 272, 
    RulePredefinedSchemaReference = 273, RuleAbsoluteDirectoryPath = 274, 
    RuleRelativeDirectoryPath = 275, RuleSimpleDirectoryPath = 276, RuleGraphReference = 277, 
    RuleCatalogGraphParentAndName = 278, RuleHomeGraph = 279, RuleGraphTypeReference = 280, 
    RuleCatalogGraphTypeParentAndName = 281, RuleBindingTableReference = 282, 
    RuleProcedureReference = 283, RuleCatalogProcedureParentAndName = 284, 
    RuleCatalogObjectParentReference = 285, RuleReferenceParameterSpecification = 286, 
    RuleNestedGraphTypeSpecification = 287, RuleGraphTypeSpecificationBody = 288, 
    RuleElementTypeList = 289, RuleElementTypeSpecification = 290, RuleNodeTypeSpecification = 291, 
    RuleNodeTypePattern = 292, RuleNodeTypePhrase = 293, RuleNodeTypePhraseFiller = 294, 
    RuleNodeTypeFiller = 295, RuleLocalNodeTypeAlias = 296, RuleNodeTypeImpliedContent = 297, 
    RuleNodeTypeKeyLabelSet = 298, RuleNodeTypeLabelSet = 299, RuleNodeTypePropertyTypes = 300, 
    RuleEdgeTypeSpecification = 301, RuleEdgeTypePattern = 302, RuleEdgeTypePhrase = 303, 
    RuleEdgeTypePhraseFiller = 304, RuleEdgeTypeFiller = 305, RuleEdgeTypeImpliedContent = 306, 
    RuleEdgeTypeKeyLabelSet = 307, RuleEdgeTypeLabelSet = 308, RuleEdgeTypePropertyTypes = 309, 
    RuleEdgeTypePatternDirected = 310, RuleEdgeTypePatternPointingRight = 311, 
    RuleEdgeTypePatternPointingLeft = 312, RuleEdgeTypePatternUndirected = 313, 
    RuleArcTypePointingRight = 314, RuleArcTypePointingLeft = 315, RuleArcTypeUndirected = 316, 
    RuleSourceNodeTypeReference = 317, RuleDestinationNodeTypeReference = 318, 
    RuleEdgeKind = 319, RuleEndpointPairPhrase = 320, RuleEndpointPair = 321, 
    RuleEndpointPairDirected = 322, RuleEndpointPairPointingRight = 323, 
    RuleEndpointPairPointingLeft = 324, RuleEndpointPairUndirected = 325, 
    RuleConnectorPointingRight = 326, RuleConnectorUndirected = 327, RuleSourceNodeTypeAlias = 328, 
    RuleDestinationNodeTypeAlias = 329, RuleLabelSetPhrase = 330, RuleLabelSetSpecification = 331, 
    RulePropertyTypesSpecification = 332, RulePropertyTypeList = 333, RulePropertyType = 334, 
    RulePropertyValueType = 335, RuleBindingTableType = 336, RuleValueType = 337, 
    RuleTyped = 338, RulePredefinedType = 339, RuleBooleanType = 340, RuleCharacterStringType = 341, 
    RuleByteStringType = 342, RuleMinLength = 343, RuleMaxLength = 344, 
    RuleFixedLength = 345, RuleNumericType = 346, RuleExactNumericType = 347, 
    RuleBinaryExactNumericType = 348, RuleSignedBinaryExactNumericType = 349, 
    RuleUnsignedBinaryExactNumericType = 350, RuleVerboseBinaryExactNumericType = 351, 
    RuleDecimalExactNumericType = 352, RulePrecision = 353, RuleScale = 354, 
    RuleApproximateNumericType = 355, RuleTemporalType = 356, RuleTemporalInstantType = 357, 
    RuleDatetimeType = 358, RuleLocaldatetimeType = 359, RuleDateType = 360, 
    RuleTimeType = 361, RuleLocaltimeType = 362, RuleTemporalDurationType = 363, 
    RuleTemporalDurationQualifier = 364, RuleReferenceValueType = 365, RuleImmaterialValueType = 366, 
    RuleNullType = 367, RuleEmptyType = 368, RuleGraphReferenceValueType = 369, 
    RuleClosedGraphReferenceValueType = 370, RuleOpenGraphReferenceValueType = 371, 
    RuleBindingTableReferenceValueType = 372, RuleNodeReferenceValueType = 373, 
    RuleClosedNodeReferenceValueType = 374, RuleOpenNodeReferenceValueType = 375, 
    RuleEdgeReferenceValueType = 376, RuleClosedEdgeReferenceValueType = 377, 
    RuleOpenEdgeReferenceValueType = 378, RulePathValueType = 379, RuleListValueTypeName = 380, 
    RuleListValueTypeNameSynonym = 381, RuleRecordType = 382, RuleFieldTypesSpecification = 383, 
    RuleFieldTypeList = 384, RuleNotNull = 385, RuleFieldType = 386, RuleSearchCondition = 387, 
    RulePredicate = 388, RuleCompOp = 389, RuleExistsPredicate = 390, RuleNullPredicate = 391, 
    RuleNullPredicatePart2 = 392, RuleValueTypePredicate = 393, RuleValueTypePredicatePart2 = 394, 
    RuleNormalizedPredicatePart2 = 395, RuleDirectedPredicate = 396, RuleDirectedPredicatePart2 = 397, 
    RuleLabeledPredicate = 398, RuleLabeledPredicatePart2 = 399, RuleIsLabeledOrColon = 400, 
    RuleSourceDestinationPredicate = 401, RuleNodeReference = 402, RuleSourcePredicatePart2 = 403, 
    RuleDestinationPredicatePart2 = 404, RuleEdgeReference = 405, RuleAll_differentPredicate = 406, 
    RuleSamePredicate = 407, RuleProperty_existsPredicate = 408, RuleValueExpression = 409, 
    RuleValueFunction = 410, RuleBooleanValueExpression = 411, RuleCharacterOrByteStringFunction = 412, 
    RuleSubCharacterOrByteString = 413, RuleTrimSingleCharacterOrByteString = 414, 
    RuleFoldCharacterString = 415, RuleTrimMultiCharacterCharacterString = 416, 
    RuleNormalizeCharacterString = 417, RuleNodeReferenceValueExpression = 418, 
    RuleEdgeReferenceValueExpression = 419, RuleAggregatingValueExpression = 420, 
    RuleValueExpressionPrimary = 421, RuleParenthesizedValueExpression = 422, 
    RuleNonParenthesizedValueExpressionPrimary = 423, RuleNonParenthesizedValueExpressionPrimarySpecialCase = 424, 
    RuleUnsignedValueSpecification = 425, RuleNonNegativeIntegerSpecification = 426, 
    RuleGeneralValueSpecification = 427, RuleDynamicParameterSpecification = 428, 
    RuleLetValueExpression = 429, RuleValueQueryExpression = 430, RuleCaseExpression = 431, 
    RuleCaseAbbreviation = 432, RuleCaseSpecification = 433, RuleSimpleCase = 434, 
    RuleSearchedCase = 435, RuleSimpleWhenClause = 436, RuleSearchedWhenClause = 437, 
    RuleElseClause = 438, RuleCaseOperand = 439, RuleWhenOperandList = 440, 
    RuleWhenOperand = 441, RuleResult = 442, RuleResultExpression = 443, 
    RuleCastSpecification = 444, RuleCastOperand = 445, RuleCastTarget = 446, 
    RuleAggregateFunction = 447, RuleGeneralSetFunction = 448, RuleBinarySetFunction = 449, 
    RuleGeneralSetFunctionType = 450, RuleSetQuantifier = 451, RuleBinarySetFunctionType = 452, 
    RuleDependentValueExpression = 453, RuleIndependentValueExpression = 454, 
    RuleElement_idFunction = 455, RuleBindingVariableReference = 456, RulePathValueExpression = 457, 
    RulePathValueConstructor = 458, RulePathValueConstructorByEnumeration = 459, 
    RulePathElementList = 460, RulePathElementListStart = 461, RulePathElementListStep = 462, 
    RuleListValueExpression = 463, RuleListValueFunction = 464, RuleTrimListFunction = 465, 
    RuleElementsFunction = 466, RuleListValueConstructor = 467, RuleListValueConstructorByEnumeration = 468, 
    RuleListElementList = 469, RuleListElement = 470, RuleRecordConstructor = 471, 
    RuleFieldsSpecification = 472, RuleFieldList = 473, RuleField = 474, 
    RuleTruthValue = 475, RuleNumericValueExpression = 476, RuleNumericValueFunction = 477, 
    RuleLengthExpression = 478, RuleCardinalityExpression = 479, RuleCardinalityExpressionArgument = 480, 
    RuleCharLengthExpression = 481, RuleByteLengthExpression = 482, RulePathLengthExpression = 483, 
    RuleAbsoluteValueExpression = 484, RuleModulusExpression = 485, RuleNumericValueExpressionDividend = 486, 
    RuleNumericValueExpressionDivisor = 487, RuleTrigonometricFunction = 488, 
    RuleTrigonometricFunctionName = 489, RuleGeneralLogarithmFunction = 490, 
    RuleGeneralLogarithmBase = 491, RuleGeneralLogarithmArgument = 492, 
    RuleCommonLogarithm = 493, RuleNaturalLogarithm = 494, RuleExponentialFunction = 495, 
    RulePowerFunction = 496, RuleNumericValueExpressionBase = 497, RuleNumericValueExpressionExponent = 498, 
    RuleSquareRoot = 499, RuleFloorFunction = 500, RuleCeilingFunction = 501, 
    RuleCharacterStringValueExpression = 502, RuleByteStringValueExpression = 503, 
    RuleTrimOperands = 504, RuleTrimCharacterOrByteStringSource = 505, RuleTrimSpecification = 506, 
    RuleTrimCharacterOrByteString = 507, RuleNormalForm = 508, RuleStringLength = 509, 
    RuleDatetimeValueExpression = 510, RuleDatetimeValueFunction = 511, 
    RuleDateFunction = 512, RuleTimeFunction = 513, RuleLocaltimeFunction = 514, 
    RuleDatetimeFunction = 515, RuleLocaldatetimeFunction = 516, RuleDateFunctionParameters = 517, 
    RuleTimeFunctionParameters = 518, RuleDatetimeFunctionParameters = 519, 
    RuleDurationValueExpression = 520, RuleDatetimeSubtraction = 521, RuleDatetimeSubtractionParameters = 522, 
    RuleDatetimeValueExpression1 = 523, RuleDatetimeValueExpression2 = 524, 
    RuleDurationValueFunction = 525, RuleDurationFunction = 526, RuleDurationFunctionParameters = 527, 
    RuleObjectName = 528, RuleObjectNameOrBindingVariable = 529, RuleDirectoryName = 530, 
    RuleSchemaName = 531, RuleGraphName = 532, RuleDelimitedGraphName = 533, 
    RuleGraphTypeName = 534, RuleNodeTypeName = 535, RuleEdgeTypeName = 536, 
    RuleBindingTableName = 537, RuleDelimitedBindingTableName = 538, RuleProcedureName = 539, 
    RuleLabelName = 540, RulePropertyName = 541, RuleFieldName = 542, RuleElementVariable = 543, 
    RulePathVariable = 544, RuleSubpathVariable = 545, RuleBindingVariable = 546, 
    RuleUnsignedLiteral = 547, RuleGeneralLiteral = 548, RuleTemporalLiteral = 549, 
    RuleDateLiteral = 550, RuleTimeLiteral = 551, RuleDatetimeLiteral = 552, 
    RuleListLiteral = 553, RuleRecordLiteral = 554, RuleIdentifier = 555, 
    RuleRegularIdentifier = 556, RuleTimeZoneString = 557, RuleCharacterStringLiteral = 558, 
    RuleUnsignedNumericLiteral = 559, RuleExactNumericLiteral = 560, RuleApproximateNumericLiteral = 561, 
    RuleUnsignedInteger = 562, RuleUnsignedDecimalInteger = 563, RuleNullLiteral = 564, 
    RuleDateString = 565, RuleTimeString = 566, RuleDatetimeString = 567, 
    RuleDurationLiteral = 568, RuleDurationString = 569, RuleNodeSynonym = 570, 
    RuleEdgesSynonym = 571, RuleEdgeSynonym = 572, RuleNonReservedWords = 573
  };

  explicit GQLParser(antlr4::TokenStream *input);

  GQLParser(antlr4::TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options);

  ~GQLParser() override;

  std::string getGrammarFileName() const override;

  const antlr4::atn::ATN& getATN() const override;

  const std::vector<std::string>& getRuleNames() const override;

  const antlr4::dfa::Vocabulary& getVocabulary() const override;

  antlr4::atn::SerializedATNView getSerializedATN() const override;

  template<typename T> struct is_shared_ptr : std::false_type {};
  template<typename T> struct is_shared_ptr<std::shared_ptr<T>> : std::true_type {};

  template<typename T> struct is_unique_ptr : std::false_type {};
  template<typename T> struct is_unique_ptr<std::unique_ptr<T>> : std::true_type {};

  template<typename T>
  auto get_raw_pointer(T& value) {
    if constexpr (std::is_pointer_v<std::decay_t<T>>) {
        // If it's a raw pointer, return it directly
        return value;
    } else if constexpr (is_unique_ptr<std::decay_t<T>>::value || is_shared_ptr<std::decay_t<T>>::value) {
        // If it's a smart pointer, return the raw pointer from .get()
        return value.get();
    } else {
        // Otherwise, return a pointer to the value itself
        return &value;
    }
  }

  template <typename Class, typename Enabled = void>
  struct has_ExitRule : std::false_type {};

  template <typename Class>
  struct has_ExitRule<Class,
                     std::enable_if_t<std::is_member_function_pointer_v<
                         decltype(&std::remove_pointer_t<Class>::ExitRule)>>> : std::true_type {};

  template <typename Class, typename Enabled = void>
  struct has_OnToken : std::false_type {};

  template <typename Class>
  struct has_OnToken<Class,
                     std::enable_if_t<std::is_member_function_pointer_v<
                         decltype(&std::remove_pointer_t<Class>::OnToken)>>> : std::true_type {};


  class GqlProgramContext;
  class ProgramActivityContext;
  class SessionActivityContext;
  class TransactionActivityContext;
  class EndTransactionCommandContext;
  class SessionSetCommandContext;
  class SessionSetSchemaClauseContext;
  class SessionSetGraphClauseContext;
  class SessionSetTimeZoneClauseContext;
  class SetTimeZoneValueContext;
  class SessionSetParameterClauseContext;
  class SessionSetGraphParameterClauseContext;
  class SessionSetBindingTableParameterClauseContext;
  class SessionSetValueParameterClauseContext;
  class SessionSetParameterNameContext;
  class SessionResetCommandContext;
  class SessionResetArgumentsContext;
  class SessionCloseCommandContext;
  class SessionParameterSpecificationContext;
  class StartTransactionCommandContext;
  class TransactionCharacteristicsContext;
  class TransactionModeContext;
  class TransactionAccessModeContext;
  class RollbackCommandContext;
  class CommitCommandContext;
  class NestedProcedureSpecificationContext;
  class ProcedureSpecificationContext;
  class NestedDataModifyingProcedureSpecificationContext;
  class NestedQuerySpecificationContext;
  class ProcedureBodyContext;
  class BindingVariableDefinitionBlockContext;
  class BindingVariableDefinitionContext;
  class StatementBlockContext;
  class StatementContext;
  class NextStatementContext;
  class GraphVariableDefinitionContext;
  class OptTypedGraphInitializerContext;
  class GraphInitializerContext;
  class BindingTableVariableDefinitionContext;
  class OptTypedBindingTableInitializerContext;
  class BindingTableInitializerContext;
  class ValueVariableDefinitionContext;
  class OptTypedValueInitializerContext;
  class ValueInitializerContext;
  class GraphExpressionContext;
  class CurrentGraphContext;
  class BindingTableExpressionContext;
  class NestedBindingTableQuerySpecificationContext;
  class ObjectExpressionPrimaryContext;
  class LinearCatalogModifyingStatementContext;
  class SimpleCatalogModifyingStatementContext;
  class PrimitiveCatalogModifyingStatementContext;
  class CreateSchemaStatementContext;
  class DropSchemaStatementContext;
  class CreateGraphStatementContext;
  class OpenGraphTypeContext;
  class OfGraphTypeContext;
  class GraphTypeLikeGraphContext;
  class GraphSourceContext;
  class DropGraphStatementContext;
  class CreateGraphTypeStatementContext;
  class GraphTypeSourceContext;
  class CopyOfGraphTypeContext;
  class DropGraphTypeStatementContext;
  class CallCatalogModifyingProcedureStatementContext;
  class LinearDataModifyingStatementContext;
  class FocusedLinearDataModifyingStatementContext;
  class FocusedLinearDataModifyingStatementBodyContext;
  class FocusedNestedDataModifyingProcedureSpecificationContext;
  class AmbientLinearDataModifyingStatementContext;
  class AmbientLinearDataModifyingStatementBodyContext;
  class SimpleLinearDataAccessingStatementContext;
  class SimpleDataAccessingStatementContext;
  class SimpleDataModifyingStatementContext;
  class PrimitiveDataModifyingStatementContext;
  class InsertStatementContext;
  class SetStatementContext;
  class SetItemListContext;
  class SetItemContext;
  class SetPropertyItemContext;
  class SetAllPropertiesItemContext;
  class SetLabelItemContext;
  class RemoveStatementContext;
  class RemoveItemListContext;
  class RemoveItemContext;
  class RemovePropertyItemContext;
  class RemoveLabelItemContext;
  class DeleteStatementContext;
  class DeleteItemListContext;
  class DeleteItemContext;
  class CallDataModifyingProcedureStatementContext;
  class CompositeQueryStatementContext;
  class CompositeQueryExpressionContext;
  class QueryConjunctionContext;
  class SetOperatorContext;
  class CompositeQueryPrimaryContext;
  class LinearQueryStatementContext;
  class FocusedLinearQueryStatementContext;
  class FocusedLinearQueryStatementPartContext;
  class FocusedLinearQueryAndPrimitiveResultStatementPartContext;
  class FocusedPrimitiveResultStatementContext;
  class FocusedNestedQuerySpecificationContext;
  class AmbientLinearQueryStatementContext;
  class SimpleLinearQueryStatementContext;
  class SimpleQueryStatementContext;
  class PrimitiveQueryStatementContext;
  class MatchStatementContext;
  class SimpleMatchStatementContext;
  class OptionalMatchStatementContext;
  class OptionalOperandContext;
  class MatchStatementBlockContext;
  class CallQueryStatementContext;
  class FilterStatementContext;
  class LetStatementContext;
  class LetVariableDefinitionListContext;
  class LetVariableDefinitionContext;
  class ForStatementContext;
  class ForItemContext;
  class ForItemAliasContext;
  class ForItemSourceContext;
  class ForOrdinalityOrOffsetContext;
  class OrderByAndPageStatementContext;
  class PrimitiveResultStatementContext;
  class ReturnStatementContext;
  class ReturnStatementBodyContext;
  class ReturnItemListContext;
  class ReturnItemContext;
  class ReturnItemAliasContext;
  class SelectStatementContext;
  class SelectItemListContext;
  class SelectItemContext;
  class SelectItemAliasContext;
  class HavingClauseContext;
  class SelectStatementBodyContext;
  class SelectGraphMatchListContext;
  class SelectGraphMatchContext;
  class SelectQuerySpecificationContext;
  class CallProcedureStatementContext;
  class ProcedureCallContext;
  class InlineProcedureCallContext;
  class VariableScopeClauseContext;
  class BindingVariableReferenceListContext;
  class NamedProcedureCallContext;
  class ProcedureArgumentListContext;
  class ProcedureArgumentContext;
  class AtSchemaClauseContext;
  class UseGraphClauseContext;
  class GraphPatternBindingTableContext;
  class GraphPatternYieldClauseContext;
  class GraphPatternYieldItemListContext;
  class GraphPatternYieldItemContext;
  class GraphPatternContext;
  class MatchModeContext;
  class RepeatableElementsMatchModeContext;
  class DifferentEdgesMatchModeContext;
  class ElementBindingsOrElementsContext;
  class EdgeBindingsOrEdgesContext;
  class PathPatternListContext;
  class PathPatternContext;
  class PathVariableDeclarationContext;
  class KeepClauseContext;
  class GraphPatternWhereClauseContext;
  class InsertGraphPatternContext;
  class InsertPathPatternListContext;
  class InsertPathPatternContext;
  class InsertNodePatternContext;
  class InsertEdgePatternContext;
  class InsertEdgePointingLeftContext;
  class InsertEdgePointingRightContext;
  class InsertEdgeUndirectedContext;
  class InsertElementPatternFillerContext;
  class LabelAndPropertySetSpecificationContext;
  class PathPatternPrefixContext;
  class PathModePrefixContext;
  class PathModeContext;
  class PathSearchPrefixContext;
  class AllPathSearchContext;
  class PathOrPathsContext;
  class AnyPathSearchContext;
  class NumberOfPathsContext;
  class ShortestPathSearchContext;
  class AllShortestPathSearchContext;
  class AnyShortestPathSearchContext;
  class CountedShortestPathSearchContext;
  class CountedShortestGroupSearchContext;
  class NumberOfGroupsContext;
  class PathPatternExpressionContext;
  class PathTermContext;
  class PathFactorContext;
  class PathPrimaryContext;
  class ElementPatternContext;
  class NodePatternContext;
  class ElementPatternFillerContext;
  class ElementVariableDeclarationContext;
  class IsLabelExpressionContext;
  class IsOrColonContext;
  class ElementPatternPredicateContext;
  class ElementPatternWhereClauseContext;
  class ElementPropertySpecificationContext;
  class PropertyKeyValuePairListContext;
  class PropertyKeyValuePairContext;
  class EdgePatternContext;
  class FullEdgePatternContext;
  class FullEdgePointingLeftContext;
  class FullEdgeUndirectedContext;
  class FullEdgePointingRightContext;
  class FullEdgeLeftOrUndirectedContext;
  class FullEdgeUndirectedOrRightContext;
  class FullEdgeLeftOrRightContext;
  class FullEdgeAnyDirectionContext;
  class AbbreviatedEdgePatternContext;
  class ParenthesizedPathPatternExpressionContext;
  class SubpathVariableDeclarationContext;
  class ParenthesizedPathPatternWhereClauseContext;
  class LabelExpressionContext;
  class PathVariableReferenceContext;
  class ElementVariableReferenceContext;
  class GraphPatternQuantifierContext;
  class FixedQuantifierContext;
  class GeneralQuantifierContext;
  class LowerBoundContext;
  class UpperBoundContext;
  class SimplifiedPathPatternExpressionContext;
  class SimplifiedDefaultingLeftContext;
  class SimplifiedDefaultingUndirectedContext;
  class SimplifiedDefaultingRightContext;
  class SimplifiedDefaultingLeftOrUndirectedContext;
  class SimplifiedDefaultingUndirectedOrRightContext;
  class SimplifiedDefaultingLeftOrRightContext;
  class SimplifiedDefaultingAnyDirectionContext;
  class SimplifiedContentsContext;
  class SimplifiedPathUnionContext;
  class SimplifiedMultisetAlternationContext;
  class SimplifiedTermContext;
  class SimplifiedFactorLowContext;
  class SimplifiedFactorHighContext;
  class SimplifiedQuantifiedContext;
  class SimplifiedQuestionedContext;
  class SimplifiedTertiaryContext;
  class SimplifiedDirectionOverrideContext;
  class SimplifiedOverrideLeftContext;
  class SimplifiedOverrideUndirectedContext;
  class SimplifiedOverrideRightContext;
  class SimplifiedOverrideLeftOrUndirectedContext;
  class SimplifiedOverrideUndirectedOrRightContext;
  class SimplifiedOverrideLeftOrRightContext;
  class SimplifiedOverrideAnyDirectionContext;
  class SimplifiedSecondaryContext;
  class SimplifiedNegationContext;
  class SimplifiedPrimaryContext;
  class WhereClauseContext;
  class YieldClauseContext;
  class YieldItemListContext;
  class YieldItemContext;
  class YieldItemNameContext;
  class YieldItemAliasContext;
  class GroupByClauseContext;
  class GroupingElementListContext;
  class GroupingElementContext;
  class EmptyGroupingSetContext;
  class OrderByClauseContext;
  class SortSpecificationListContext;
  class SortSpecificationContext;
  class SortKeyContext;
  class OrderingSpecificationContext;
  class NullOrderingContext;
  class LimitClauseContext;
  class OffsetClauseContext;
  class OffsetSynonymContext;
  class SchemaReferenceContext;
  class AbsoluteCatalogSchemaReferenceContext;
  class CatalogSchemaParentAndNameContext;
  class RelativeCatalogSchemaReferenceContext;
  class PredefinedSchemaReferenceContext;
  class AbsoluteDirectoryPathContext;
  class RelativeDirectoryPathContext;
  class SimpleDirectoryPathContext;
  class GraphReferenceContext;
  class CatalogGraphParentAndNameContext;
  class HomeGraphContext;
  class GraphTypeReferenceContext;
  class CatalogGraphTypeParentAndNameContext;
  class BindingTableReferenceContext;
  class ProcedureReferenceContext;
  class CatalogProcedureParentAndNameContext;
  class CatalogObjectParentReferenceContext;
  class ReferenceParameterSpecificationContext;
  class NestedGraphTypeSpecificationContext;
  class GraphTypeSpecificationBodyContext;
  class ElementTypeListContext;
  class ElementTypeSpecificationContext;
  class NodeTypeSpecificationContext;
  class NodeTypePatternContext;
  class NodeTypePhraseContext;
  class NodeTypePhraseFillerContext;
  class NodeTypeFillerContext;
  class LocalNodeTypeAliasContext;
  class NodeTypeImpliedContentContext;
  class NodeTypeKeyLabelSetContext;
  class NodeTypeLabelSetContext;
  class NodeTypePropertyTypesContext;
  class EdgeTypeSpecificationContext;
  class EdgeTypePatternContext;
  class EdgeTypePhraseContext;
  class EdgeTypePhraseFillerContext;
  class EdgeTypeFillerContext;
  class EdgeTypeImpliedContentContext;
  class EdgeTypeKeyLabelSetContext;
  class EdgeTypeLabelSetContext;
  class EdgeTypePropertyTypesContext;
  class EdgeTypePatternDirectedContext;
  class EdgeTypePatternPointingRightContext;
  class EdgeTypePatternPointingLeftContext;
  class EdgeTypePatternUndirectedContext;
  class ArcTypePointingRightContext;
  class ArcTypePointingLeftContext;
  class ArcTypeUndirectedContext;
  class SourceNodeTypeReferenceContext;
  class DestinationNodeTypeReferenceContext;
  class EdgeKindContext;
  class EndpointPairPhraseContext;
  class EndpointPairContext;
  class EndpointPairDirectedContext;
  class EndpointPairPointingRightContext;
  class EndpointPairPointingLeftContext;
  class EndpointPairUndirectedContext;
  class ConnectorPointingRightContext;
  class ConnectorUndirectedContext;
  class SourceNodeTypeAliasContext;
  class DestinationNodeTypeAliasContext;
  class LabelSetPhraseContext;
  class LabelSetSpecificationContext;
  class PropertyTypesSpecificationContext;
  class PropertyTypeListContext;
  class PropertyTypeContext;
  class PropertyValueTypeContext;
  class BindingTableTypeContext;
  class ValueTypeContext;
  class TypedContext;
  class PredefinedTypeContext;
  class BooleanTypeContext;
  class CharacterStringTypeContext;
  class ByteStringTypeContext;
  class MinLengthContext;
  class MaxLengthContext;
  class FixedLengthContext;
  class NumericTypeContext;
  class ExactNumericTypeContext;
  class BinaryExactNumericTypeContext;
  class SignedBinaryExactNumericTypeContext;
  class UnsignedBinaryExactNumericTypeContext;
  class VerboseBinaryExactNumericTypeContext;
  class DecimalExactNumericTypeContext;
  class PrecisionContext;
  class ScaleContext;
  class ApproximateNumericTypeContext;
  class TemporalTypeContext;
  class TemporalInstantTypeContext;
  class DatetimeTypeContext;
  class LocaldatetimeTypeContext;
  class DateTypeContext;
  class TimeTypeContext;
  class LocaltimeTypeContext;
  class TemporalDurationTypeContext;
  class TemporalDurationQualifierContext;
  class ReferenceValueTypeContext;
  class ImmaterialValueTypeContext;
  class NullTypeContext;
  class EmptyTypeContext;
  class GraphReferenceValueTypeContext;
  class ClosedGraphReferenceValueTypeContext;
  class OpenGraphReferenceValueTypeContext;
  class BindingTableReferenceValueTypeContext;
  class NodeReferenceValueTypeContext;
  class ClosedNodeReferenceValueTypeContext;
  class OpenNodeReferenceValueTypeContext;
  class EdgeReferenceValueTypeContext;
  class ClosedEdgeReferenceValueTypeContext;
  class OpenEdgeReferenceValueTypeContext;
  class PathValueTypeContext;
  class ListValueTypeNameContext;
  class ListValueTypeNameSynonymContext;
  class RecordTypeContext;
  class FieldTypesSpecificationContext;
  class FieldTypeListContext;
  class NotNullContext;
  class FieldTypeContext;
  class SearchConditionContext;
  class PredicateContext;
  class CompOpContext;
  class ExistsPredicateContext;
  class NullPredicateContext;
  class NullPredicatePart2Context;
  class ValueTypePredicateContext;
  class ValueTypePredicatePart2Context;
  class NormalizedPredicatePart2Context;
  class DirectedPredicateContext;
  class DirectedPredicatePart2Context;
  class LabeledPredicateContext;
  class LabeledPredicatePart2Context;
  class IsLabeledOrColonContext;
  class SourceDestinationPredicateContext;
  class NodeReferenceContext;
  class SourcePredicatePart2Context;
  class DestinationPredicatePart2Context;
  class EdgeReferenceContext;
  class All_differentPredicateContext;
  class SamePredicateContext;
  class Property_existsPredicateContext;
  class ValueExpressionContext;
  class ValueFunctionContext;
  class BooleanValueExpressionContext;
  class CharacterOrByteStringFunctionContext;
  class SubCharacterOrByteStringContext;
  class TrimSingleCharacterOrByteStringContext;
  class FoldCharacterStringContext;
  class TrimMultiCharacterCharacterStringContext;
  class NormalizeCharacterStringContext;
  class NodeReferenceValueExpressionContext;
  class EdgeReferenceValueExpressionContext;
  class AggregatingValueExpressionContext;
  class ValueExpressionPrimaryContext;
  class ParenthesizedValueExpressionContext;
  class NonParenthesizedValueExpressionPrimaryContext;
  class NonParenthesizedValueExpressionPrimarySpecialCaseContext;
  class UnsignedValueSpecificationContext;
  class NonNegativeIntegerSpecificationContext;
  class GeneralValueSpecificationContext;
  class DynamicParameterSpecificationContext;
  class LetValueExpressionContext;
  class ValueQueryExpressionContext;
  class CaseExpressionContext;
  class CaseAbbreviationContext;
  class CaseSpecificationContext;
  class SimpleCaseContext;
  class SearchedCaseContext;
  class SimpleWhenClauseContext;
  class SearchedWhenClauseContext;
  class ElseClauseContext;
  class CaseOperandContext;
  class WhenOperandListContext;
  class WhenOperandContext;
  class ResultContext;
  class ResultExpressionContext;
  class CastSpecificationContext;
  class CastOperandContext;
  class CastTargetContext;
  class AggregateFunctionContext;
  class GeneralSetFunctionContext;
  class BinarySetFunctionContext;
  class GeneralSetFunctionTypeContext;
  class SetQuantifierContext;
  class BinarySetFunctionTypeContext;
  class DependentValueExpressionContext;
  class IndependentValueExpressionContext;
  class Element_idFunctionContext;
  class BindingVariableReferenceContext;
  class PathValueExpressionContext;
  class PathValueConstructorContext;
  class PathValueConstructorByEnumerationContext;
  class PathElementListContext;
  class PathElementListStartContext;
  class PathElementListStepContext;
  class ListValueExpressionContext;
  class ListValueFunctionContext;
  class TrimListFunctionContext;
  class ElementsFunctionContext;
  class ListValueConstructorContext;
  class ListValueConstructorByEnumerationContext;
  class ListElementListContext;
  class ListElementContext;
  class RecordConstructorContext;
  class FieldsSpecificationContext;
  class FieldListContext;
  class FieldContext;
  class TruthValueContext;
  class NumericValueExpressionContext;
  class NumericValueFunctionContext;
  class LengthExpressionContext;
  class CardinalityExpressionContext;
  class CardinalityExpressionArgumentContext;
  class CharLengthExpressionContext;
  class ByteLengthExpressionContext;
  class PathLengthExpressionContext;
  class AbsoluteValueExpressionContext;
  class ModulusExpressionContext;
  class NumericValueExpressionDividendContext;
  class NumericValueExpressionDivisorContext;
  class TrigonometricFunctionContext;
  class TrigonometricFunctionNameContext;
  class GeneralLogarithmFunctionContext;
  class GeneralLogarithmBaseContext;
  class GeneralLogarithmArgumentContext;
  class CommonLogarithmContext;
  class NaturalLogarithmContext;
  class ExponentialFunctionContext;
  class PowerFunctionContext;
  class NumericValueExpressionBaseContext;
  class NumericValueExpressionExponentContext;
  class SquareRootContext;
  class FloorFunctionContext;
  class CeilingFunctionContext;
  class CharacterStringValueExpressionContext;
  class ByteStringValueExpressionContext;
  class TrimOperandsContext;
  class TrimCharacterOrByteStringSourceContext;
  class TrimSpecificationContext;
  class TrimCharacterOrByteStringContext;
  class NormalFormContext;
  class StringLengthContext;
  class DatetimeValueExpressionContext;
  class DatetimeValueFunctionContext;
  class DateFunctionContext;
  class TimeFunctionContext;
  class LocaltimeFunctionContext;
  class DatetimeFunctionContext;
  class LocaldatetimeFunctionContext;
  class DateFunctionParametersContext;
  class TimeFunctionParametersContext;
  class DatetimeFunctionParametersContext;
  class DurationValueExpressionContext;
  class DatetimeSubtractionContext;
  class DatetimeSubtractionParametersContext;
  class DatetimeValueExpression1Context;
  class DatetimeValueExpression2Context;
  class DurationValueFunctionContext;
  class DurationFunctionContext;
  class DurationFunctionParametersContext;
  class ObjectNameContext;
  class ObjectNameOrBindingVariableContext;
  class DirectoryNameContext;
  class SchemaNameContext;
  class GraphNameContext;
  class DelimitedGraphNameContext;
  class GraphTypeNameContext;
  class NodeTypeNameContext;
  class EdgeTypeNameContext;
  class BindingTableNameContext;
  class DelimitedBindingTableNameContext;
  class ProcedureNameContext;
  class LabelNameContext;
  class PropertyNameContext;
  class FieldNameContext;
  class ElementVariableContext;
  class PathVariableContext;
  class SubpathVariableContext;
  class BindingVariableContext;
  class UnsignedLiteralContext;
  class GeneralLiteralContext;
  class TemporalLiteralContext;
  class DateLiteralContext;
  class TimeLiteralContext;
  class DatetimeLiteralContext;
  class ListLiteralContext;
  class RecordLiteralContext;
  class IdentifierContext;
  class RegularIdentifierContext;
  class TimeZoneStringContext;
  class CharacterStringLiteralContext;
  class UnsignedNumericLiteralContext;
  class ExactNumericLiteralContext;
  class ApproximateNumericLiteralContext;
  class UnsignedIntegerContext;
  class UnsignedDecimalIntegerContext;
  class NullLiteralContext;
  class DateStringContext;
  class TimeStringContext;
  class DatetimeStringContext;
  class DurationLiteralContext;
  class DurationStringContext;
  class NodeSynonymContext;
  class EdgesSynonymContext;
  class EdgeSynonymContext;
  class NonReservedWordsContext; 

  class  GqlProgramContext : public antlr4::ParserRuleContext {
  public:
    GqlProgramContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ProgramActivityContext *programActivity();
    antlr4::tree::TerminalNode *EOF();
    SessionCloseCommandContext *sessionCloseCommand();

   
  };

  template<typename ContextT>
  GqlProgramContext* gqlProgram(ContextT* ctx) {
    GqlProgramContext *_localctx = _tracker.createInstance<GqlProgramContext>(_ctx, getState());
    enterRule(_localctx, 0, GQLParser::RuleGqlProgram);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1157);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1148);
        {
          auto childCtxHolder = ctx->EnterProgramActivity();
          programActivity(get_raw_pointer(childCtxHolder));
        }
        setState(1150);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::SESSION) {
          setState(1149);
          {
            auto childCtxHolder = ctx->EnterSessionCloseCommand();
            sessionCloseCommand(get_raw_pointer(childCtxHolder));
          }
        }
        setState(1152);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::EOF) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::EOF);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1154);
        {
          auto childCtxHolder = ctx->EnterSessionCloseCommand();
          sessionCloseCommand(get_raw_pointer(childCtxHolder));
        }
        setState(1155);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::EOF) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::EOF);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ProgramActivityContext : public antlr4::ParserRuleContext {
  public:
    ProgramActivityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SessionActivityContext *sessionActivity();
    TransactionActivityContext *transactionActivity();

   
  };

  template<typename ContextT>
  ProgramActivityContext* programActivity(ContextT* ctx) {
    ProgramActivityContext *_localctx = _tracker.createInstance<ProgramActivityContext>(_ctx, getState());
    enterRule(_localctx, 2, GQLParser::RuleProgramActivity);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1161);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::SESSION: {
          enterOuterAlt(_localctx, 1);
          setState(1159);
          {
            auto childCtxHolder = ctx->EnterSessionActivity();
            sessionActivity(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::AT:
        case GQLParser::CALL:
        case GQLParser::COMMIT:
        case GQLParser::CREATE:
        case GQLParser::DELETE:
        case GQLParser::DETACH:
        case GQLParser::DROP:
        case GQLParser::FILTER:
        case GQLParser::FINISH:
        case GQLParser::FOR:
        case GQLParser::INSERT:
        case GQLParser::LET:
        case GQLParser::LIMIT:
        case GQLParser::MATCH:
        case GQLParser::NODETACH:
        case GQLParser::OFFSET:
        case GQLParser::OPTIONAL:
        case GQLParser::ORDER:
        case GQLParser::REMOVE:
        case GQLParser::RETURN:
        case GQLParser::ROLLBACK:
        case GQLParser::SELECT:
        case GQLParser::SET:
        case GQLParser::SKIP_RESERVED_WORD:
        case GQLParser::START:
        case GQLParser::USE:
        case GQLParser::VALUE:
        case GQLParser::BINDING:
        case GQLParser::GRAPH:
        case GQLParser::PROPERTY:
        case GQLParser::TABLE:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(1160);
          {
            auto childCtxHolder = ctx->EnterTransactionActivity();
            transactionActivity(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SessionActivityContext : public antlr4::ParserRuleContext {
  public:
    SessionActivityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<SessionResetCommandContext *> sessionResetCommand();
    SessionResetCommandContext* sessionResetCommand(size_t i);
    std::vector<SessionSetCommandContext *> sessionSetCommand();
    SessionSetCommandContext* sessionSetCommand(size_t i);

   
  };

  template<typename ContextT>
  SessionActivityContext* sessionActivity(ContextT* ctx) {
    SessionActivityContext *_localctx = _tracker.createInstance<SessionActivityContext>(_ctx, getState());
    enterRule(_localctx, 4, GQLParser::RuleSessionActivity);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      setState(1179);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1164); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1163);
                  {
                    auto childCtxHolder = ctx->EnterSessionResetCommand();
                    sessionResetCommand(get_raw_pointer(childCtxHolder));
                  }
                  break;
                }

          default:
            throw antlr4::NoViableAltException(this);
          }
          setState(1166); 
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
        } while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1169); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1168);
                  {
                    auto childCtxHolder = ctx->EnterSessionSetCommand();
                    sessionSetCommand(get_raw_pointer(childCtxHolder));
                  }
                  break;
                }

          default:
            throw antlr4::NoViableAltException(this);
          }
          setState(1171); 
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx);
        } while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER);
        setState(1176);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx);
        while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1173);
            {
              auto childCtxHolder = ctx->EnterSessionResetCommand();
              sessionResetCommand(get_raw_pointer(childCtxHolder));
            } 
          }
          setState(1178);
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx);
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TransactionActivityContext : public antlr4::ParserRuleContext {
  public:
    TransactionActivityContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    StartTransactionCommandContext *startTransactionCommand();
    ProcedureSpecificationContext *procedureSpecification();
    EndTransactionCommandContext *endTransactionCommand();

   
  };

  template<typename ContextT>
  TransactionActivityContext* transactionActivity(ContextT* ctx) {
    TransactionActivityContext *_localctx = _tracker.createInstance<TransactionActivityContext>(_ctx, getState());
    enterRule(_localctx, 6, GQLParser::RuleTransactionActivity);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1193);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::START: {
          enterOuterAlt(_localctx, 1);
          setState(1181);
          {
            auto childCtxHolder = ctx->EnterStartTransactionCommand();
            startTransactionCommand(get_raw_pointer(childCtxHolder));
          }
          setState(1186);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (((((_la - 31) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 31)) & 3461332977278001153) != 0) || ((((_la - 100) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 100)) & 6342202976706233345) != 0) || ((((_la - 177) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 177)) & 351843721159689) != 0) || ((((_la - 278) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 278)) & 34493958145) != 0) || _la == GQLParser::LEFT_BRACE) {
            setState(1182);
            {
              auto childCtxHolder = ctx->EnterProcedureSpecification();
              procedureSpecification(get_raw_pointer(childCtxHolder));
            }
            setState(1184);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == GQLParser::COMMIT || _la == GQLParser::ROLLBACK) {
              setState(1183);
              {
                auto childCtxHolder = ctx->EnterEndTransactionCommand();
                endTransactionCommand(get_raw_pointer(childCtxHolder));
              }
            }
          }
          break;
        }

        case GQLParser::AT:
        case GQLParser::CALL:
        case GQLParser::CREATE:
        case GQLParser::DELETE:
        case GQLParser::DETACH:
        case GQLParser::DROP:
        case GQLParser::FILTER:
        case GQLParser::FINISH:
        case GQLParser::FOR:
        case GQLParser::INSERT:
        case GQLParser::LET:
        case GQLParser::LIMIT:
        case GQLParser::MATCH:
        case GQLParser::NODETACH:
        case GQLParser::OFFSET:
        case GQLParser::OPTIONAL:
        case GQLParser::ORDER:
        case GQLParser::REMOVE:
        case GQLParser::RETURN:
        case GQLParser::SELECT:
        case GQLParser::SET:
        case GQLParser::SKIP_RESERVED_WORD:
        case GQLParser::USE:
        case GQLParser::VALUE:
        case GQLParser::BINDING:
        case GQLParser::GRAPH:
        case GQLParser::PROPERTY:
        case GQLParser::TABLE:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(1188);
          {
            auto childCtxHolder = ctx->EnterProcedureSpecification();
            procedureSpecification(get_raw_pointer(childCtxHolder));
          }
          setState(1190);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::COMMIT || _la == GQLParser::ROLLBACK) {
            setState(1189);
            {
              auto childCtxHolder = ctx->EnterEndTransactionCommand();
              endTransactionCommand(get_raw_pointer(childCtxHolder));
            }
          }
          break;
        }

        case GQLParser::COMMIT:
        case GQLParser::ROLLBACK: {
          enterOuterAlt(_localctx, 3);
          setState(1192);
          {
            auto childCtxHolder = ctx->EnterEndTransactionCommand();
            endTransactionCommand(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EndTransactionCommandContext : public antlr4::ParserRuleContext {
  public:
    EndTransactionCommandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    RollbackCommandContext *rollbackCommand();
    CommitCommandContext *commitCommand();

   
  };

  template<typename ContextT>
  EndTransactionCommandContext* endTransactionCommand(ContextT* ctx) {
    EndTransactionCommandContext *_localctx = _tracker.createInstance<EndTransactionCommandContext>(_ctx, getState());
    enterRule(_localctx, 8, GQLParser::RuleEndTransactionCommand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1197);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ROLLBACK: {
          enterOuterAlt(_localctx, 1);
          setState(1195);
          {
            auto childCtxHolder = ctx->EnterRollbackCommand();
            rollbackCommand(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::COMMIT: {
          enterOuterAlt(_localctx, 2);
          setState(1196);
          {
            auto childCtxHolder = ctx->EnterCommitCommand();
            commitCommand(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SessionSetCommandContext : public antlr4::ParserRuleContext {
  public:
    SessionSetCommandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *SET();
    SessionSetSchemaClauseContext *sessionSetSchemaClause();
    SessionSetGraphClauseContext *sessionSetGraphClause();
    SessionSetTimeZoneClauseContext *sessionSetTimeZoneClause();
    SessionSetParameterClauseContext *sessionSetParameterClause();

   
  };

  template<typename ContextT>
  SessionSetCommandContext* sessionSetCommand(ContextT* ctx) {
    SessionSetCommandContext *_localctx = _tracker.createInstance<SessionSetCommandContext>(_ctx, getState());
    enterRule(_localctx, 10, GQLParser::RuleSessionSetCommand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1199);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SESSION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SESSION);
      setState(1200);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SET);
      setState(1205);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
      case 1: {
        setState(1201);
        {
          auto childCtxHolder = ctx->EnterSessionSetSchemaClause();
          sessionSetSchemaClause(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        setState(1202);
        {
          auto childCtxHolder = ctx->EnterSessionSetGraphClause();
          sessionSetGraphClause(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        setState(1203);
        {
          auto childCtxHolder = ctx->EnterSessionSetTimeZoneClause();
          sessionSetTimeZoneClause(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        setState(1204);
        {
          auto childCtxHolder = ctx->EnterSessionSetParameterClause();
          sessionSetParameterClause(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SessionSetSchemaClauseContext : public antlr4::ParserRuleContext {
  public:
    SessionSetSchemaClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SCHEMA();
    SchemaReferenceContext *schemaReference();

   
  };

  template<typename ContextT>
  SessionSetSchemaClauseContext* sessionSetSchemaClause(ContextT* ctx) {
    SessionSetSchemaClauseContext *_localctx = _tracker.createInstance<SessionSetSchemaClauseContext>(_ctx, getState());
    enterRule(_localctx, 12, GQLParser::RuleSessionSetSchemaClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1207);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SCHEMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SCHEMA);
      setState(1208);
      {
        auto childCtxHolder = ctx->EnterSchemaReference();
        schemaReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SessionSetGraphClauseContext : public antlr4::ParserRuleContext {
  public:
    SessionSetGraphClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GRAPH();
    GraphExpressionContext *graphExpression();
    antlr4::tree::TerminalNode *PROPERTY();

   
  };

  template<typename ContextT>
  SessionSetGraphClauseContext* sessionSetGraphClause(ContextT* ctx) {
    SessionSetGraphClauseContext *_localctx = _tracker.createInstance<SessionSetGraphClauseContext>(_ctx, getState());
    enterRule(_localctx, 14, GQLParser::RuleSessionSetGraphClause);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1211);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PROPERTY) {
        setState(1210);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
      }
      setState(1213);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GRAPH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GRAPH);
      setState(1214);
      {
        auto childCtxHolder = ctx->EnterGraphExpression();
        graphExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SessionSetTimeZoneClauseContext : public antlr4::ParserRuleContext {
  public:
    SessionSetTimeZoneClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *ZONE();
    SetTimeZoneValueContext *setTimeZoneValue();

   
  };

  template<typename ContextT>
  SessionSetTimeZoneClauseContext* sessionSetTimeZoneClause(ContextT* ctx) {
    SessionSetTimeZoneClauseContext *_localctx = _tracker.createInstance<SessionSetTimeZoneClauseContext>(_ctx, getState());
    enterRule(_localctx, 16, GQLParser::RuleSessionSetTimeZoneClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1216);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TIME) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TIME);
      setState(1217);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ZONE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ZONE);
      setState(1218);
      {
        auto childCtxHolder = ctx->EnterSetTimeZoneValue();
        setTimeZoneValue(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SetTimeZoneValueContext : public antlr4::ParserRuleContext {
  public:
    SetTimeZoneValueContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    TimeZoneStringContext *timeZoneString();

   
  };

  template<typename ContextT>
  SetTimeZoneValueContext* setTimeZoneValue(ContextT* ctx) {
    SetTimeZoneValueContext *_localctx = _tracker.createInstance<SetTimeZoneValueContext>(_ctx, getState());
    enterRule(_localctx, 18, GQLParser::RuleSetTimeZoneValue);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1220);
      {
        auto childCtxHolder = ctx->EnterTimeZoneString();
        timeZoneString(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SessionSetParameterClauseContext : public antlr4::ParserRuleContext {
  public:
    SessionSetParameterClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SessionSetGraphParameterClauseContext *sessionSetGraphParameterClause();
    SessionSetBindingTableParameterClauseContext *sessionSetBindingTableParameterClause();
    SessionSetValueParameterClauseContext *sessionSetValueParameterClause();

   
  };

  template<typename ContextT>
  SessionSetParameterClauseContext* sessionSetParameterClause(ContextT* ctx) {
    SessionSetParameterClauseContext *_localctx = _tracker.createInstance<SessionSetParameterClauseContext>(_ctx, getState());
    enterRule(_localctx, 20, GQLParser::RuleSessionSetParameterClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1225);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::GRAPH:
        case GQLParser::PROPERTY: {
          enterOuterAlt(_localctx, 1);
          setState(1222);
          {
            auto childCtxHolder = ctx->EnterSessionSetGraphParameterClause();
            sessionSetGraphParameterClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BINDING:
        case GQLParser::TABLE: {
          enterOuterAlt(_localctx, 2);
          setState(1223);
          {
            auto childCtxHolder = ctx->EnterSessionSetBindingTableParameterClause();
            sessionSetBindingTableParameterClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::VALUE: {
          enterOuterAlt(_localctx, 3);
          setState(1224);
          {
            auto childCtxHolder = ctx->EnterSessionSetValueParameterClause();
            sessionSetValueParameterClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SessionSetGraphParameterClauseContext : public antlr4::ParserRuleContext {
  public:
    SessionSetGraphParameterClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GRAPH();
    SessionSetParameterNameContext *sessionSetParameterName();
    OptTypedGraphInitializerContext *optTypedGraphInitializer();
    antlr4::tree::TerminalNode *PROPERTY();

   
  };

  template<typename ContextT>
  SessionSetGraphParameterClauseContext* sessionSetGraphParameterClause(ContextT* ctx) {
    SessionSetGraphParameterClauseContext *_localctx = _tracker.createInstance<SessionSetGraphParameterClauseContext>(_ctx, getState());
    enterRule(_localctx, 22, GQLParser::RuleSessionSetGraphParameterClause);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1228);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PROPERTY) {
        setState(1227);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
      }
      setState(1230);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GRAPH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GRAPH);
      setState(1231);
      {
        auto childCtxHolder = ctx->EnterSessionSetParameterName();
        sessionSetParameterName(get_raw_pointer(childCtxHolder));
      }
      setState(1232);
      {
        auto childCtxHolder = ctx->EnterOptTypedGraphInitializer();
        optTypedGraphInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SessionSetBindingTableParameterClauseContext : public antlr4::ParserRuleContext {
  public:
    SessionSetBindingTableParameterClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLE();
    SessionSetParameterNameContext *sessionSetParameterName();
    OptTypedBindingTableInitializerContext *optTypedBindingTableInitializer();
    antlr4::tree::TerminalNode *BINDING();

   
  };

  template<typename ContextT>
  SessionSetBindingTableParameterClauseContext* sessionSetBindingTableParameterClause(ContextT* ctx) {
    SessionSetBindingTableParameterClauseContext *_localctx = _tracker.createInstance<SessionSetBindingTableParameterClauseContext>(_ctx, getState());
    enterRule(_localctx, 24, GQLParser::RuleSessionSetBindingTableParameterClause);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1235);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::BINDING) {
        setState(1234);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::BINDING) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::BINDING);
      }
      setState(1237);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TABLE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TABLE);
      setState(1238);
      {
        auto childCtxHolder = ctx->EnterSessionSetParameterName();
        sessionSetParameterName(get_raw_pointer(childCtxHolder));
      }
      setState(1239);
      {
        auto childCtxHolder = ctx->EnterOptTypedBindingTableInitializer();
        optTypedBindingTableInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SessionSetValueParameterClauseContext : public antlr4::ParserRuleContext {
  public:
    SessionSetValueParameterClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VALUE();
    SessionSetParameterNameContext *sessionSetParameterName();
    OptTypedValueInitializerContext *optTypedValueInitializer();

   
  };

  template<typename ContextT>
  SessionSetValueParameterClauseContext* sessionSetValueParameterClause(ContextT* ctx) {
    SessionSetValueParameterClauseContext *_localctx = _tracker.createInstance<SessionSetValueParameterClauseContext>(_ctx, getState());
    enterRule(_localctx, 26, GQLParser::RuleSessionSetValueParameterClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1241);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::VALUE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::VALUE);
      setState(1242);
      {
        auto childCtxHolder = ctx->EnterSessionSetParameterName();
        sessionSetParameterName(get_raw_pointer(childCtxHolder));
      }
      setState(1243);
      {
        auto childCtxHolder = ctx->EnterOptTypedValueInitializer();
        optTypedValueInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SessionSetParameterNameContext : public antlr4::ParserRuleContext {
  public:
    SessionSetParameterNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SessionParameterSpecificationContext *sessionParameterSpecification();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *EXISTS();

   
  };

  template<typename ContextT>
  SessionSetParameterNameContext* sessionSetParameterName(ContextT* ctx) {
    SessionSetParameterNameContext *_localctx = _tracker.createInstance<SessionSetParameterNameContext>(_ctx, getState());
    enterRule(_localctx, 28, GQLParser::RuleSessionSetParameterName);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1248);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IF) {
        setState(1245);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::IF) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::IF);
        setState(1246);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
        setState(1247);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::EXISTS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::EXISTS);
      }
      setState(1250);
      {
        auto childCtxHolder = ctx->EnterSessionParameterSpecification();
        sessionParameterSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SessionResetCommandContext : public antlr4::ParserRuleContext {
  public:
    SessionResetCommandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *RESET();
    SessionResetArgumentsContext *sessionResetArguments();

   
  };

  template<typename ContextT>
  SessionResetCommandContext* sessionResetCommand(ContextT* ctx) {
    SessionResetCommandContext *_localctx = _tracker.createInstance<SessionResetCommandContext>(_ctx, getState());
    enterRule(_localctx, 30, GQLParser::RuleSessionResetCommand);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1252);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SESSION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SESSION);
      setState(1253);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RESET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RESET);
      setState(1255);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ALL

      || _la == GQLParser::CHARACTERISTICS || ((((_la - 164) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 164)) & 8796095119363) != 0) || ((((_la - 289) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 289)) & 274877972481) != 0)) {
        setState(1254);
        {
          auto childCtxHolder = ctx->EnterSessionResetArguments();
          sessionResetArguments(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SessionResetArgumentsContext : public antlr4::ParserRuleContext {
  public:
    SessionResetArgumentsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PARAMETERS();
    antlr4::tree::TerminalNode *CHARACTERISTICS();
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *SCHEMA();
    antlr4::tree::TerminalNode *GRAPH();
    antlr4::tree::TerminalNode *PROPERTY();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *ZONE();
    SessionParameterSpecificationContext *sessionParameterSpecification();
    antlr4::tree::TerminalNode *PARAMETER();

   
  };

  template<typename ContextT>
  SessionResetArgumentsContext* sessionResetArguments(ContextT* ctx) {
    SessionResetArgumentsContext *_localctx = _tracker.createInstance<SessionResetArgumentsContext>(_ctx, getState());
    enterRule(_localctx, 32, GQLParser::RuleSessionResetArguments);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1272);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ALL:
        case GQLParser::CHARACTERISTICS:
        case GQLParser::PARAMETERS: {
          enterOuterAlt(_localctx, 1);
          setState(1258);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::ALL) {
            setState(1257);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::ALL) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::ALL);
          }
          setState(1260);
          _la = _input->LA(1);
          if (!(_la == GQLParser::CHARACTERISTICS || _la == GQLParser::PARAMETERS)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            antlr4::Token * token = consume();
            ctx->OnToken(token);
          }
          break;
        }

        case GQLParser::SCHEMA: {
          enterOuterAlt(_localctx, 2);
          setState(1261);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::SCHEMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::SCHEMA);
          break;
        }

        case GQLParser::GRAPH:
        case GQLParser::PROPERTY: {
          enterOuterAlt(_localctx, 3);
          setState(1263);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::PROPERTY) {
            setState(1262);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PROPERTY) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PROPERTY);
          }
          setState(1265);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::GRAPH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::GRAPH);
          break;
        }

        case GQLParser::TIME: {
          enterOuterAlt(_localctx, 4);
          setState(1266);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(1267);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONE);
          break;
        }

        case GQLParser::PARAMETER:
        case GQLParser::GENERAL_PARAMETER_REFERENCE: {
          enterOuterAlt(_localctx, 5);
          setState(1269);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::PARAMETER) {
            setState(1268);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PARAMETER) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PARAMETER);
          }
          setState(1271);
          {
            auto childCtxHolder = ctx->EnterSessionParameterSpecification();
            sessionParameterSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SessionCloseCommandContext : public antlr4::ParserRuleContext {
  public:
    SessionCloseCommandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SESSION();
    antlr4::tree::TerminalNode *CLOSE();

   
  };

  template<typename ContextT>
  SessionCloseCommandContext* sessionCloseCommand(ContextT* ctx) {
    SessionCloseCommandContext *_localctx = _tracker.createInstance<SessionCloseCommandContext>(_ctx, getState());
    enterRule(_localctx, 34, GQLParser::RuleSessionCloseCommand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1274);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SESSION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SESSION);
      setState(1275);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CLOSE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CLOSE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SessionParameterSpecificationContext : public antlr4::ParserRuleContext {
  public:
    SessionParameterSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GENERAL_PARAMETER_REFERENCE();

   
  };

  template<typename ContextT>
  SessionParameterSpecificationContext* sessionParameterSpecification(ContextT* ctx) {
    SessionParameterSpecificationContext *_localctx = _tracker.createInstance<SessionParameterSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 36, GQLParser::RuleSessionParameterSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1277);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GENERAL_PARAMETER_REFERENCE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GENERAL_PARAMETER_REFERENCE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  StartTransactionCommandContext : public antlr4::ParserRuleContext {
  public:
    StartTransactionCommandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *START();
    antlr4::tree::TerminalNode *TRANSACTION();
    TransactionCharacteristicsContext *transactionCharacteristics();

   
  };

  template<typename ContextT>
  StartTransactionCommandContext* startTransactionCommand(ContextT* ctx) {
    StartTransactionCommandContext *_localctx = _tracker.createInstance<StartTransactionCommandContext>(_ctx, getState());
    enterRule(_localctx, 38, GQLParser::RuleStartTransactionCommand);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1279);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::START) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::START);
      setState(1280);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TRANSACTION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TRANSACTION);
      setState(1282);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::READ) {
        setState(1281);
        {
          auto childCtxHolder = ctx->EnterTransactionCharacteristics();
          transactionCharacteristics(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TransactionCharacteristicsContext : public antlr4::ParserRuleContext {
  public:
    TransactionCharacteristicsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<TransactionModeContext *> transactionMode();
    TransactionModeContext* transactionMode(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  TransactionCharacteristicsContext* transactionCharacteristics(ContextT* ctx) {
    TransactionCharacteristicsContext *_localctx = _tracker.createInstance<TransactionCharacteristicsContext>(_ctx, getState());
    enterRule(_localctx, 40, GQLParser::RuleTransactionCharacteristics);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1284);
      {
        auto childCtxHolder = ctx->EnterTransactionMode();
        transactionMode(get_raw_pointer(childCtxHolder));
      }
      setState(1289);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(1285);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(1286);
        {
          auto childCtxHolder = ctx->EnterTransactionMode();
          transactionMode(get_raw_pointer(childCtxHolder));
        }
        setState(1291);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TransactionModeContext : public antlr4::ParserRuleContext {
  public:
    TransactionModeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    TransactionAccessModeContext *transactionAccessMode();

   
  };

  template<typename ContextT>
  TransactionModeContext* transactionMode(ContextT* ctx) {
    TransactionModeContext *_localctx = _tracker.createInstance<TransactionModeContext>(_ctx, getState());
    enterRule(_localctx, 42, GQLParser::RuleTransactionMode);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1292);
      {
        auto childCtxHolder = ctx->EnterTransactionAccessMode();
        transactionAccessMode(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TransactionAccessModeContext : public antlr4::ParserRuleContext {
  public:
    TransactionAccessModeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *WRITE();

   
  };

  template<typename ContextT>
  TransactionAccessModeContext* transactionAccessMode(ContextT* ctx) {
    TransactionAccessModeContext *_localctx = _tracker.createInstance<TransactionAccessModeContext>(_ctx, getState());
    enterRule(_localctx, 44, GQLParser::RuleTransactionAccessMode);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1298);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1294);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::READ) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::READ);
        setState(1295);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::ONLY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::ONLY);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1296);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::READ) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::READ);
        setState(1297);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::WRITE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::WRITE);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  RollbackCommandContext : public antlr4::ParserRuleContext {
  public:
    RollbackCommandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ROLLBACK();

   
  };

  template<typename ContextT>
  RollbackCommandContext* rollbackCommand(ContextT* ctx) {
    RollbackCommandContext *_localctx = _tracker.createInstance<RollbackCommandContext>(_ctx, getState());
    enterRule(_localctx, 46, GQLParser::RuleRollbackCommand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1300);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ROLLBACK) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ROLLBACK);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CommitCommandContext : public antlr4::ParserRuleContext {
  public:
    CommitCommandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COMMIT();

   
  };

  template<typename ContextT>
  CommitCommandContext* commitCommand(ContextT* ctx) {
    CommitCommandContext *_localctx = _tracker.createInstance<CommitCommandContext>(_ctx, getState());
    enterRule(_localctx, 48, GQLParser::RuleCommitCommand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1302);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMIT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMIT);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NestedProcedureSpecificationContext : public antlr4::ParserRuleContext {
  public:
    NestedProcedureSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_BRACE();
    ProcedureSpecificationContext *procedureSpecification();
    antlr4::tree::TerminalNode *RIGHT_BRACE();

   
  };

  template<typename ContextT>
  NestedProcedureSpecificationContext* nestedProcedureSpecification(ContextT* ctx) {
    NestedProcedureSpecificationContext *_localctx = _tracker.createInstance<NestedProcedureSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 50, GQLParser::RuleNestedProcedureSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1304);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(1305);
      {
        auto childCtxHolder = ctx->EnterProcedureSpecification();
        procedureSpecification(get_raw_pointer(childCtxHolder));
      }
      setState(1306);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ProcedureSpecificationContext : public antlr4::ParserRuleContext {
  public:
    ProcedureSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ProcedureBodyContext *procedureBody();

   
  };

  template<typename ContextT>
  ProcedureSpecificationContext* procedureSpecification(ContextT* ctx) {
    ProcedureSpecificationContext *_localctx = _tracker.createInstance<ProcedureSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 52, GQLParser::RuleProcedureSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1308);
      {
        auto childCtxHolder = ctx->EnterProcedureBody();
        procedureBody(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NestedDataModifyingProcedureSpecificationContext : public antlr4::ParserRuleContext {
  public:
    NestedDataModifyingProcedureSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_BRACE();
    ProcedureBodyContext *procedureBody();
    antlr4::tree::TerminalNode *RIGHT_BRACE();

   
  };

  template<typename ContextT>
  NestedDataModifyingProcedureSpecificationContext* nestedDataModifyingProcedureSpecification(ContextT* ctx) {
    NestedDataModifyingProcedureSpecificationContext *_localctx = _tracker.createInstance<NestedDataModifyingProcedureSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 54, GQLParser::RuleNestedDataModifyingProcedureSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1310);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(1311);
      {
        auto childCtxHolder = ctx->EnterProcedureBody();
        procedureBody(get_raw_pointer(childCtxHolder));
      }
      setState(1312);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NestedQuerySpecificationContext : public antlr4::ParserRuleContext {
  public:
    NestedQuerySpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_BRACE();
    ProcedureBodyContext *procedureBody();
    antlr4::tree::TerminalNode *RIGHT_BRACE();

   
  };

  template<typename ContextT>
  NestedQuerySpecificationContext* nestedQuerySpecification(ContextT* ctx) {
    NestedQuerySpecificationContext *_localctx = _tracker.createInstance<NestedQuerySpecificationContext>(_ctx, getState());
    enterRule(_localctx, 56, GQLParser::RuleNestedQuerySpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1314);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(1315);
      {
        auto childCtxHolder = ctx->EnterProcedureBody();
        procedureBody(get_raw_pointer(childCtxHolder));
      }
      setState(1316);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ProcedureBodyContext : public antlr4::ParserRuleContext {
  public:
    ProcedureBodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    StatementBlockContext *statementBlock();
    AtSchemaClauseContext *atSchemaClause();
    BindingVariableDefinitionBlockContext *bindingVariableDefinitionBlock();

   
  };

  template<typename ContextT>
  ProcedureBodyContext* procedureBody(ContextT* ctx) {
    ProcedureBodyContext *_localctx = _tracker.createInstance<ProcedureBodyContext>(_ctx, getState());
    enterRule(_localctx, 58, GQLParser::RuleProcedureBody);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1319);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::AT) {
        setState(1318);
        {
          auto childCtxHolder = ctx->EnterAtSchemaClause();
          atSchemaClause(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1322);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::VALUE

      || _la == GQLParser::BINDING || ((((_la - 289) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 289)) & 16842753) != 0)) {
        setState(1321);
        {
          auto childCtxHolder = ctx->EnterBindingVariableDefinitionBlock();
          bindingVariableDefinitionBlock(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1324);
      {
        auto childCtxHolder = ctx->EnterStatementBlock();
        statementBlock(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BindingVariableDefinitionBlockContext : public antlr4::ParserRuleContext {
  public:
    BindingVariableDefinitionBlockContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<BindingVariableDefinitionContext *> bindingVariableDefinition();
    BindingVariableDefinitionContext* bindingVariableDefinition(size_t i);

   
  };

  template<typename ContextT>
  BindingVariableDefinitionBlockContext* bindingVariableDefinitionBlock(ContextT* ctx) {
    BindingVariableDefinitionBlockContext *_localctx = _tracker.createInstance<BindingVariableDefinitionBlockContext>(_ctx, getState());
    enterRule(_localctx, 60, GQLParser::RuleBindingVariableDefinitionBlock);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1327); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1326);
        {
          auto childCtxHolder = ctx->EnterBindingVariableDefinition();
          bindingVariableDefinition(get_raw_pointer(childCtxHolder));
        }
        setState(1329); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == GQLParser::VALUE

      || _la == GQLParser::BINDING || ((((_la - 289) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 289)) & 16842753) != 0));
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BindingVariableDefinitionContext : public antlr4::ParserRuleContext {
  public:
    BindingVariableDefinitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    GraphVariableDefinitionContext *graphVariableDefinition();
    BindingTableVariableDefinitionContext *bindingTableVariableDefinition();
    ValueVariableDefinitionContext *valueVariableDefinition();

   
  };

  template<typename ContextT>
  BindingVariableDefinitionContext* bindingVariableDefinition(ContextT* ctx) {
    BindingVariableDefinitionContext *_localctx = _tracker.createInstance<BindingVariableDefinitionContext>(_ctx, getState());
    enterRule(_localctx, 62, GQLParser::RuleBindingVariableDefinition);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1334);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::GRAPH:
        case GQLParser::PROPERTY: {
          enterOuterAlt(_localctx, 1);
          setState(1331);
          {
            auto childCtxHolder = ctx->EnterGraphVariableDefinition();
            graphVariableDefinition(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BINDING:
        case GQLParser::TABLE: {
          enterOuterAlt(_localctx, 2);
          setState(1332);
          {
            auto childCtxHolder = ctx->EnterBindingTableVariableDefinition();
            bindingTableVariableDefinition(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::VALUE: {
          enterOuterAlt(_localctx, 3);
          setState(1333);
          {
            auto childCtxHolder = ctx->EnterValueVariableDefinition();
            valueVariableDefinition(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  StatementBlockContext : public antlr4::ParserRuleContext {
  public:
    StatementBlockContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    StatementContext *statement();
    std::vector<NextStatementContext *> nextStatement();
    NextStatementContext* nextStatement(size_t i);

   
  };

  template<typename ContextT>
  StatementBlockContext* statementBlock(ContextT* ctx) {
    StatementBlockContext *_localctx = _tracker.createInstance<StatementBlockContext>(_ctx, getState());
    enterRule(_localctx, 64, GQLParser::RuleStatementBlock);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1336);
      {
        auto childCtxHolder = ctx->EnterStatement();
        statement(get_raw_pointer(childCtxHolder));
      }
      setState(1340);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::NEXT) {
        setState(1337);
        {
          auto childCtxHolder = ctx->EnterNextStatement();
          nextStatement(get_raw_pointer(childCtxHolder));
        }
        setState(1342);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  StatementContext : public antlr4::ParserRuleContext {
  public:
    StatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    LinearCatalogModifyingStatementContext *linearCatalogModifyingStatement();
    LinearDataModifyingStatementContext *linearDataModifyingStatement();
    CompositeQueryStatementContext *compositeQueryStatement();

   
  };

  template<typename ContextT>
  StatementContext* statement(ContextT* ctx) {
    StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
    enterRule(_localctx, 66, GQLParser::RuleStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1346);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1343);
        {
          auto childCtxHolder = ctx->EnterLinearCatalogModifyingStatement();
          linearCatalogModifyingStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1344);
        {
          auto childCtxHolder = ctx->EnterLinearDataModifyingStatement();
          linearDataModifyingStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1345);
        {
          auto childCtxHolder = ctx->EnterCompositeQueryStatement();
          compositeQueryStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NextStatementContext : public antlr4::ParserRuleContext {
  public:
    NextStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NEXT();
    StatementContext *statement();
    YieldClauseContext *yieldClause();

   
  };

  template<typename ContextT>
  NextStatementContext* nextStatement(ContextT* ctx) {
    NextStatementContext *_localctx = _tracker.createInstance<NextStatementContext>(_ctx, getState());
    enterRule(_localctx, 68, GQLParser::RuleNextStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1348);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NEXT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NEXT);
      setState(1350);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::YIELD) {
        setState(1349);
        {
          auto childCtxHolder = ctx->EnterYieldClause();
          yieldClause(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1352);
      {
        auto childCtxHolder = ctx->EnterStatement();
        statement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphVariableDefinitionContext : public antlr4::ParserRuleContext {
  public:
    GraphVariableDefinitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GRAPH();
    BindingVariableContext *bindingVariable();
    OptTypedGraphInitializerContext *optTypedGraphInitializer();
    antlr4::tree::TerminalNode *PROPERTY();

   
  };

  template<typename ContextT>
  GraphVariableDefinitionContext* graphVariableDefinition(ContextT* ctx) {
    GraphVariableDefinitionContext *_localctx = _tracker.createInstance<GraphVariableDefinitionContext>(_ctx, getState());
    enterRule(_localctx, 70, GQLParser::RuleGraphVariableDefinition);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1355);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PROPERTY) {
        setState(1354);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
      }
      setState(1357);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GRAPH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GRAPH);
      setState(1358);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
      setState(1359);
      {
        auto childCtxHolder = ctx->EnterOptTypedGraphInitializer();
        optTypedGraphInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  OptTypedGraphInitializerContext : public antlr4::ParserRuleContext {
  public:
    OptTypedGraphInitializerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    GraphInitializerContext *graphInitializer();
    GraphReferenceValueTypeContext *graphReferenceValueType();
    TypedContext *typed();

   
  };

  template<typename ContextT>
  OptTypedGraphInitializerContext* optTypedGraphInitializer(ContextT* ctx) {
    OptTypedGraphInitializerContext *_localctx = _tracker.createInstance<OptTypedGraphInitializerContext>(_ctx, getState());
    enterRule(_localctx, 72, GQLParser::RuleOptTypedGraphInitializer);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1365);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ANY || _la == GQLParser::TYPED || ((((_la - 289) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 289)) & 8796093087745) != 0)) {
        setState(1362);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
          setState(1361);
          {
            auto childCtxHolder = ctx->EnterTyped();
            typed(get_raw_pointer(childCtxHolder));
          }
        }
        setState(1364);
        {
          auto childCtxHolder = ctx->EnterGraphReferenceValueType();
          graphReferenceValueType(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1367);
      {
        auto childCtxHolder = ctx->EnterGraphInitializer();
        graphInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphInitializerContext : public antlr4::ParserRuleContext {
  public:
    GraphInitializerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EQUALS_OPERATOR();
    GraphExpressionContext *graphExpression();

   
  };

  template<typename ContextT>
  GraphInitializerContext* graphInitializer(ContextT* ctx) {
    GraphInitializerContext *_localctx = _tracker.createInstance<GraphInitializerContext>(_ctx, getState());
    enterRule(_localctx, 74, GQLParser::RuleGraphInitializer);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1369);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EQUALS_OPERATOR);
      setState(1370);
      {
        auto childCtxHolder = ctx->EnterGraphExpression();
        graphExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BindingTableVariableDefinitionContext : public antlr4::ParserRuleContext {
  public:
    BindingTableVariableDefinitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLE();
    BindingVariableContext *bindingVariable();
    OptTypedBindingTableInitializerContext *optTypedBindingTableInitializer();
    antlr4::tree::TerminalNode *BINDING();

   
  };

  template<typename ContextT>
  BindingTableVariableDefinitionContext* bindingTableVariableDefinition(ContextT* ctx) {
    BindingTableVariableDefinitionContext *_localctx = _tracker.createInstance<BindingTableVariableDefinitionContext>(_ctx, getState());
    enterRule(_localctx, 76, GQLParser::RuleBindingTableVariableDefinition);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1373);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::BINDING) {
        setState(1372);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::BINDING) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::BINDING);
      }
      setState(1375);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TABLE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TABLE);
      setState(1376);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
      setState(1377);
      {
        auto childCtxHolder = ctx->EnterOptTypedBindingTableInitializer();
        optTypedBindingTableInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  OptTypedBindingTableInitializerContext : public antlr4::ParserRuleContext {
  public:
    OptTypedBindingTableInitializerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BindingTableInitializerContext *bindingTableInitializer();
    BindingTableReferenceValueTypeContext *bindingTableReferenceValueType();
    TypedContext *typed();

   
  };

  template<typename ContextT>
  OptTypedBindingTableInitializerContext* optTypedBindingTableInitializer(ContextT* ctx) {
    OptTypedBindingTableInitializerContext *_localctx = _tracker.createInstance<OptTypedBindingTableInitializerContext>(_ctx, getState());
    enterRule(_localctx, 78, GQLParser::RuleOptTypedBindingTableInitializer);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1383);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::TYPED || ((((_la - 278) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 278)) & 18014432869220353) != 0)) {
        setState(1380);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
          setState(1379);
          {
            auto childCtxHolder = ctx->EnterTyped();
            typed(get_raw_pointer(childCtxHolder));
          }
        }
        setState(1382);
        {
          auto childCtxHolder = ctx->EnterBindingTableReferenceValueType();
          bindingTableReferenceValueType(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1385);
      {
        auto childCtxHolder = ctx->EnterBindingTableInitializer();
        bindingTableInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BindingTableInitializerContext : public antlr4::ParserRuleContext {
  public:
    BindingTableInitializerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EQUALS_OPERATOR();
    BindingTableExpressionContext *bindingTableExpression();

   
  };

  template<typename ContextT>
  BindingTableInitializerContext* bindingTableInitializer(ContextT* ctx) {
    BindingTableInitializerContext *_localctx = _tracker.createInstance<BindingTableInitializerContext>(_ctx, getState());
    enterRule(_localctx, 80, GQLParser::RuleBindingTableInitializer);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1387);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EQUALS_OPERATOR);
      setState(1388);
      {
        auto childCtxHolder = ctx->EnterBindingTableExpression();
        bindingTableExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ValueVariableDefinitionContext : public antlr4::ParserRuleContext {
  public:
    ValueVariableDefinitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VALUE();
    BindingVariableContext *bindingVariable();
    OptTypedValueInitializerContext *optTypedValueInitializer();

   
  };

  template<typename ContextT>
  ValueVariableDefinitionContext* valueVariableDefinition(ContextT* ctx) {
    ValueVariableDefinitionContext *_localctx = _tracker.createInstance<ValueVariableDefinitionContext>(_ctx, getState());
    enterRule(_localctx, 82, GQLParser::RuleValueVariableDefinition);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1390);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::VALUE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::VALUE);
      setState(1391);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
      setState(1392);
      {
        auto childCtxHolder = ctx->EnterOptTypedValueInitializer();
        optTypedValueInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  OptTypedValueInitializerContext : public antlr4::ParserRuleContext {
  public:
    OptTypedValueInitializerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueInitializerContext *valueInitializer();
    ValueTypeContext *valueType();
    TypedContext *typed();

   
  };

  template<typename ContextT>
  OptTypedValueInitializerContext* optTypedValueInitializer(ContextT* ctx) {
    OptTypedValueInitializerContext *_localctx = _tracker.createInstance<OptTypedValueInitializerContext>(_ctx, getState());
    enterRule(_localctx, 84, GQLParser::RuleOptTypedValueInitializer);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1398);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 1135228676472832) != 0) || ((((_la - 70) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 70)) & -9187345434035607527) != 0) || ((((_la - 135) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 135)) & 6989589922362163201) != 0) || ((((_la - 202) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 202)) & 8645246561) != 0) || ((((_la - 278) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 278)) & 18021030618466401) != 0) || _la == GQLParser::LEFT_BRACE

      || _la == GQLParser::LEFT_PAREN) {
        setState(1395);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
          setState(1394);
          {
            auto childCtxHolder = ctx->EnterTyped();
            typed(get_raw_pointer(childCtxHolder));
          }
        }
        setState(1397);
        {
          auto childCtxHolder = ctx->EnterValueType();
          valueType(0, get_raw_pointer(childCtxHolder));
        }
      }
      setState(1400);
      {
        auto childCtxHolder = ctx->EnterValueInitializer();
        valueInitializer(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ValueInitializerContext : public antlr4::ParserRuleContext {
  public:
    ValueInitializerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EQUALS_OPERATOR();
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  ValueInitializerContext* valueInitializer(ContextT* ctx) {
    ValueInitializerContext *_localctx = _tracker.createInstance<ValueInitializerContext>(_ctx, getState());
    enterRule(_localctx, 86, GQLParser::RuleValueInitializer);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1402);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EQUALS_OPERATOR);
      setState(1403);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphExpressionContext : public antlr4::ParserRuleContext {
  public:
    GraphExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    GraphReferenceContext *graphReference();
    ObjectExpressionPrimaryContext *objectExpressionPrimary();
    ObjectNameOrBindingVariableContext *objectNameOrBindingVariable();
    CurrentGraphContext *currentGraph();

   
  };

  template<typename ContextT>
  GraphExpressionContext* graphExpression(ContextT* ctx) {
    GraphExpressionContext *_localctx = _tracker.createInstance<GraphExpressionContext>(_ctx, getState());
    enterRule(_localctx, 88, GQLParser::RuleGraphExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1409);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1405);
        {
          auto childCtxHolder = ctx->EnterGraphReference();
          graphReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1406);
        {
          auto childCtxHolder = ctx->EnterObjectExpressionPrimary();
          objectExpressionPrimary(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1407);
        {
          auto childCtxHolder = ctx->EnterObjectNameOrBindingVariable();
          objectNameOrBindingVariable(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(1408);
        {
          auto childCtxHolder = ctx->EnterCurrentGraph();
          currentGraph(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CurrentGraphContext : public antlr4::ParserRuleContext {
  public:
    CurrentGraphContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CURRENT_PROPERTY_GRAPH();
    antlr4::tree::TerminalNode *CURRENT_GRAPH();

   
  };

  template<typename ContextT>
  CurrentGraphContext* currentGraph(ContextT* ctx) {
    CurrentGraphContext *_localctx = _tracker.createInstance<CurrentGraphContext>(_ctx, getState());
    enterRule(_localctx, 90, GQLParser::RuleCurrentGraph);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1411);
      _la = _input->LA(1);
      if (!(_la == GQLParser::CURRENT_GRAPH

      || _la == GQLParser::CURRENT_PROPERTY_GRAPH)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BindingTableExpressionContext : public antlr4::ParserRuleContext {
  public:
    BindingTableExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NestedBindingTableQuerySpecificationContext *nestedBindingTableQuerySpecification();
    BindingTableReferenceContext *bindingTableReference();
    ObjectExpressionPrimaryContext *objectExpressionPrimary();
    ObjectNameOrBindingVariableContext *objectNameOrBindingVariable();

   
  };

  template<typename ContextT>
  BindingTableExpressionContext* bindingTableExpression(ContextT* ctx) {
    BindingTableExpressionContext *_localctx = _tracker.createInstance<BindingTableExpressionContext>(_ctx, getState());
    enterRule(_localctx, 92, GQLParser::RuleBindingTableExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1417);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1413);
        {
          auto childCtxHolder = ctx->EnterNestedBindingTableQuerySpecification();
          nestedBindingTableQuerySpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1414);
        {
          auto childCtxHolder = ctx->EnterBindingTableReference();
          bindingTableReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1415);
        {
          auto childCtxHolder = ctx->EnterObjectExpressionPrimary();
          objectExpressionPrimary(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(1416);
        {
          auto childCtxHolder = ctx->EnterObjectNameOrBindingVariable();
          objectNameOrBindingVariable(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NestedBindingTableQuerySpecificationContext : public antlr4::ParserRuleContext {
  public:
    NestedBindingTableQuerySpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NestedQuerySpecificationContext *nestedQuerySpecification();

   
  };

  template<typename ContextT>
  NestedBindingTableQuerySpecificationContext* nestedBindingTableQuerySpecification(ContextT* ctx) {
    NestedBindingTableQuerySpecificationContext *_localctx = _tracker.createInstance<NestedBindingTableQuerySpecificationContext>(_ctx, getState());
    enterRule(_localctx, 94, GQLParser::RuleNestedBindingTableQuerySpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1419);
      {
        auto childCtxHolder = ctx->EnterNestedQuerySpecification();
        nestedQuerySpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ObjectExpressionPrimaryContext : public antlr4::ParserRuleContext {
  public:
    ObjectExpressionPrimaryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VARIABLE();
    ValueExpressionPrimaryContext *valueExpressionPrimary();
    ParenthesizedValueExpressionContext *parenthesizedValueExpression();
    NonParenthesizedValueExpressionPrimarySpecialCaseContext *nonParenthesizedValueExpressionPrimarySpecialCase();

   
  };

  template<typename ContextT>
  ObjectExpressionPrimaryContext* objectExpressionPrimary(ContextT* ctx) {
    ObjectExpressionPrimaryContext *_localctx = _tracker.createInstance<ObjectExpressionPrimaryContext>(_ctx, getState());
    enterRule(_localctx, 96, GQLParser::RuleObjectExpressionPrimary);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1425);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1421);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::VARIABLE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::VARIABLE);
        setState(1422);
        {
          auto childCtxHolder = ctx->EnterValueExpressionPrimary();
          valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1423);
        {
          auto childCtxHolder = ctx->EnterParenthesizedValueExpression();
          parenthesizedValueExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1424);
        {
          auto childCtxHolder = ctx->EnterNonParenthesizedValueExpressionPrimarySpecialCase();
          nonParenthesizedValueExpressionPrimarySpecialCase(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LinearCatalogModifyingStatementContext : public antlr4::ParserRuleContext {
  public:
    LinearCatalogModifyingStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<SimpleCatalogModifyingStatementContext *> simpleCatalogModifyingStatement();
    SimpleCatalogModifyingStatementContext* simpleCatalogModifyingStatement(size_t i);

   
  };

  template<typename ContextT>
  LinearCatalogModifyingStatementContext* linearCatalogModifyingStatement(ContextT* ctx) {
    LinearCatalogModifyingStatementContext *_localctx = _tracker.createInstance<LinearCatalogModifyingStatementContext>(_ctx, getState());
    enterRule(_localctx, 98, GQLParser::RuleLinearCatalogModifyingStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1428); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1427);
        {
          auto childCtxHolder = ctx->EnterSimpleCatalogModifyingStatement();
          simpleCatalogModifyingStatement(get_raw_pointer(childCtxHolder));
        }
        setState(1430); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (((((_la - 44) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 44)) & 274878431233) != 0) || _la == GQLParser::OPTIONAL);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimpleCatalogModifyingStatementContext : public antlr4::ParserRuleContext {
  public:
    SimpleCatalogModifyingStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PrimitiveCatalogModifyingStatementContext *primitiveCatalogModifyingStatement();
    CallCatalogModifyingProcedureStatementContext *callCatalogModifyingProcedureStatement();

   
  };

  template<typename ContextT>
  SimpleCatalogModifyingStatementContext* simpleCatalogModifyingStatement(ContextT* ctx) {
    SimpleCatalogModifyingStatementContext *_localctx = _tracker.createInstance<SimpleCatalogModifyingStatementContext>(_ctx, getState());
    enterRule(_localctx, 100, GQLParser::RuleSimpleCatalogModifyingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1434);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CREATE:
        case GQLParser::DROP: {
          enterOuterAlt(_localctx, 1);
          setState(1432);
          {
            auto childCtxHolder = ctx->EnterPrimitiveCatalogModifyingStatement();
            primitiveCatalogModifyingStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CALL:
        case GQLParser::OPTIONAL: {
          enterOuterAlt(_localctx, 2);
          setState(1433);
          {
            auto childCtxHolder = ctx->EnterCallCatalogModifyingProcedureStatement();
            callCatalogModifyingProcedureStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PrimitiveCatalogModifyingStatementContext : public antlr4::ParserRuleContext {
  public:
    PrimitiveCatalogModifyingStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CreateSchemaStatementContext *createSchemaStatement();
    DropSchemaStatementContext *dropSchemaStatement();
    CreateGraphStatementContext *createGraphStatement();
    DropGraphStatementContext *dropGraphStatement();
    CreateGraphTypeStatementContext *createGraphTypeStatement();
    DropGraphTypeStatementContext *dropGraphTypeStatement();

   
  };

  template<typename ContextT>
  PrimitiveCatalogModifyingStatementContext* primitiveCatalogModifyingStatement(ContextT* ctx) {
    PrimitiveCatalogModifyingStatementContext *_localctx = _tracker.createInstance<PrimitiveCatalogModifyingStatementContext>(_ctx, getState());
    enterRule(_localctx, 102, GQLParser::RulePrimitiveCatalogModifyingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1442);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1436);
        {
          auto childCtxHolder = ctx->EnterCreateSchemaStatement();
          createSchemaStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1437);
        {
          auto childCtxHolder = ctx->EnterDropSchemaStatement();
          dropSchemaStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1438);
        {
          auto childCtxHolder = ctx->EnterCreateGraphStatement();
          createGraphStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(1439);
        {
          auto childCtxHolder = ctx->EnterDropGraphStatement();
          dropGraphStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(1440);
        {
          auto childCtxHolder = ctx->EnterCreateGraphTypeStatement();
          createGraphTypeStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(1441);
        {
          auto childCtxHolder = ctx->EnterDropGraphTypeStatement();
          dropGraphTypeStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CreateSchemaStatementContext : public antlr4::ParserRuleContext {
  public:
    CreateSchemaStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    antlr4::tree::TerminalNode *SCHEMA();
    CatalogSchemaParentAndNameContext *catalogSchemaParentAndName();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *EXISTS();

   
  };

  template<typename ContextT>
  CreateSchemaStatementContext* createSchemaStatement(ContextT* ctx) {
    CreateSchemaStatementContext *_localctx = _tracker.createInstance<CreateSchemaStatementContext>(_ctx, getState());
    enterRule(_localctx, 104, GQLParser::RuleCreateSchemaStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1444);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CREATE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CREATE);
      setState(1445);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SCHEMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SCHEMA);
      setState(1449);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IF) {
        setState(1446);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::IF) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::IF);
        setState(1447);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
        setState(1448);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::EXISTS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::EXISTS);
      }
      setState(1451);
      {
        auto childCtxHolder = ctx->EnterCatalogSchemaParentAndName();
        catalogSchemaParentAndName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DropSchemaStatementContext : public antlr4::ParserRuleContext {
  public:
    DropSchemaStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *SCHEMA();
    CatalogSchemaParentAndNameContext *catalogSchemaParentAndName();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *EXISTS();

   
  };

  template<typename ContextT>
  DropSchemaStatementContext* dropSchemaStatement(ContextT* ctx) {
    DropSchemaStatementContext *_localctx = _tracker.createInstance<DropSchemaStatementContext>(_ctx, getState());
    enterRule(_localctx, 106, GQLParser::RuleDropSchemaStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1453);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DROP) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DROP);
      setState(1454);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SCHEMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SCHEMA);
      setState(1457);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IF) {
        setState(1455);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::IF) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::IF);
        setState(1456);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::EXISTS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::EXISTS);
      }
      setState(1459);
      {
        auto childCtxHolder = ctx->EnterCatalogSchemaParentAndName();
        catalogSchemaParentAndName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CreateGraphStatementContext : public antlr4::ParserRuleContext {
  public:
    CreateGraphStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    CatalogGraphParentAndNameContext *catalogGraphParentAndName();
    antlr4::tree::TerminalNode *GRAPH();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    OpenGraphTypeContext *openGraphType();
    OfGraphTypeContext *ofGraphType();
    GraphSourceContext *graphSource();
    antlr4::tree::TerminalNode *PROPERTY();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *EXISTS();

   
  };

  template<typename ContextT>
  CreateGraphStatementContext* createGraphStatement(ContextT* ctx) {
    CreateGraphStatementContext *_localctx = _tracker.createInstance<CreateGraphStatementContext>(_ctx, getState());
    enterRule(_localctx, 108, GQLParser::RuleCreateGraphStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1461);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CREATE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CREATE);
      setState(1477);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::GRAPH:
        case GQLParser::PROPERTY: {
          setState(1463);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::PROPERTY) {
            setState(1462);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PROPERTY) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PROPERTY);
          }
          setState(1465);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::GRAPH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::GRAPH);
          setState(1469);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::IF) {
            setState(1466);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::IF) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::IF);
            setState(1467);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::NOT) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::NOT);
            setState(1468);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::EXISTS) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::EXISTS);
          }
          break;
        }

        case GQLParser::OR: {
          setState(1471);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::OR) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::OR);
          setState(1472);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::REPLACE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::REPLACE);
          setState(1474);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::PROPERTY) {
            setState(1473);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PROPERTY) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PROPERTY);
          }
          setState(1476);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::GRAPH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::GRAPH);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
      setState(1479);
      {
        auto childCtxHolder = ctx->EnterCatalogGraphParentAndName();
        catalogGraphParentAndName(get_raw_pointer(childCtxHolder));
      }
      setState(1482);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
      case 1: {
        setState(1480);
        {
          auto childCtxHolder = ctx->EnterOpenGraphType();
          openGraphType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        setState(1481);
        {
          auto childCtxHolder = ctx->EnterOfGraphType();
          ofGraphType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(1485);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::AS) {
        setState(1484);
        {
          auto childCtxHolder = ctx->EnterGraphSource();
          graphSource(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  OpenGraphTypeContext : public antlr4::ParserRuleContext {
  public:
    OpenGraphTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ANY();
    TypedContext *typed();
    antlr4::tree::TerminalNode *GRAPH();
    antlr4::tree::TerminalNode *PROPERTY();

   
  };

  template<typename ContextT>
  OpenGraphTypeContext* openGraphType(ContextT* ctx) {
    OpenGraphTypeContext *_localctx = _tracker.createInstance<OpenGraphTypeContext>(_ctx, getState());
    enterRule(_localctx, 110, GQLParser::RuleOpenGraphType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1488);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
        setState(1487);
        {
          auto childCtxHolder = ctx->EnterTyped();
          typed(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1490);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ANY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ANY);
      setState(1495);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::GRAPH

      || _la == GQLParser::PROPERTY) {
        setState(1492);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::PROPERTY) {
          setState(1491);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::PROPERTY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::PROPERTY);
        }
        setState(1494);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::GRAPH) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::GRAPH);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  OfGraphTypeContext : public antlr4::ParserRuleContext {
  public:
    OfGraphTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    GraphTypeLikeGraphContext *graphTypeLikeGraph();
    GraphTypeReferenceContext *graphTypeReference();
    TypedContext *typed();
    NestedGraphTypeSpecificationContext *nestedGraphTypeSpecification();
    antlr4::tree::TerminalNode *GRAPH();
    antlr4::tree::TerminalNode *PROPERTY();

   
  };

  template<typename ContextT>
  OfGraphTypeContext* ofGraphType(ContextT* ctx) {
    OfGraphTypeContext *_localctx = _tracker.createInstance<OfGraphTypeContext>(_ctx, getState());
    enterRule(_localctx, 112, GQLParser::RuleOfGraphType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1512);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1497);
        {
          auto childCtxHolder = ctx->EnterGraphTypeLikeGraph();
          graphTypeLikeGraph(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1499);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
          setState(1498);
          {
            auto childCtxHolder = ctx->EnterTyped();
            typed(get_raw_pointer(childCtxHolder));
          }
        }
        setState(1501);
        {
          auto childCtxHolder = ctx->EnterGraphTypeReference();
          graphTypeReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1503);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
          setState(1502);
          {
            auto childCtxHolder = ctx->EnterTyped();
            typed(get_raw_pointer(childCtxHolder));
          }
        }
        setState(1509);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::GRAPH

        || _la == GQLParser::PROPERTY) {
          setState(1506);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::PROPERTY) {
            setState(1505);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PROPERTY) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PROPERTY);
          }
          setState(1508);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::GRAPH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::GRAPH);
        }
        setState(1511);
        {
          auto childCtxHolder = ctx->EnterNestedGraphTypeSpecification();
          nestedGraphTypeSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphTypeLikeGraphContext : public antlr4::ParserRuleContext {
  public:
    GraphTypeLikeGraphContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LIKE();
    GraphExpressionContext *graphExpression();

   
  };

  template<typename ContextT>
  GraphTypeLikeGraphContext* graphTypeLikeGraph(ContextT* ctx) {
    GraphTypeLikeGraphContext *_localctx = _tracker.createInstance<GraphTypeLikeGraphContext>(_ctx, getState());
    enterRule(_localctx, 114, GQLParser::RuleGraphTypeLikeGraph);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1514);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LIKE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LIKE);
      setState(1515);
      {
        auto childCtxHolder = ctx->EnterGraphExpression();
        graphExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphSourceContext : public antlr4::ParserRuleContext {
  public:
    GraphSourceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AS();
    antlr4::tree::TerminalNode *COPY();
    antlr4::tree::TerminalNode *OF();
    GraphExpressionContext *graphExpression();

   
  };

  template<typename ContextT>
  GraphSourceContext* graphSource(ContextT* ctx) {
    GraphSourceContext *_localctx = _tracker.createInstance<GraphSourceContext>(_ctx, getState());
    enterRule(_localctx, 116, GQLParser::RuleGraphSource);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1517);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::AS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::AS);
      setState(1518);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COPY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COPY);
      setState(1519);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::OF) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::OF);
      setState(1520);
      {
        auto childCtxHolder = ctx->EnterGraphExpression();
        graphExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DropGraphStatementContext : public antlr4::ParserRuleContext {
  public:
    DropGraphStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *GRAPH();
    CatalogGraphParentAndNameContext *catalogGraphParentAndName();
    antlr4::tree::TerminalNode *PROPERTY();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *EXISTS();

   
  };

  template<typename ContextT>
  DropGraphStatementContext* dropGraphStatement(ContextT* ctx) {
    DropGraphStatementContext *_localctx = _tracker.createInstance<DropGraphStatementContext>(_ctx, getState());
    enterRule(_localctx, 118, GQLParser::RuleDropGraphStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1522);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DROP) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DROP);
      setState(1524);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PROPERTY) {
        setState(1523);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
      }
      setState(1526);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GRAPH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GRAPH);
      setState(1529);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IF) {
        setState(1527);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::IF) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::IF);
        setState(1528);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::EXISTS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::EXISTS);
      }
      setState(1531);
      {
        auto childCtxHolder = ctx->EnterCatalogGraphParentAndName();
        catalogGraphParentAndName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CreateGraphTypeStatementContext : public antlr4::ParserRuleContext {
  public:
    CreateGraphTypeStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CREATE();
    CatalogGraphTypeParentAndNameContext *catalogGraphTypeParentAndName();
    GraphTypeSourceContext *graphTypeSource();
    antlr4::tree::TerminalNode *GRAPH();
    antlr4::tree::TerminalNode *TYPE();
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *REPLACE();
    antlr4::tree::TerminalNode *PROPERTY();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *EXISTS();

   
  };

  template<typename ContextT>
  CreateGraphTypeStatementContext* createGraphTypeStatement(ContextT* ctx) {
    CreateGraphTypeStatementContext *_localctx = _tracker.createInstance<CreateGraphTypeStatementContext>(_ctx, getState());
    enterRule(_localctx, 120, GQLParser::RuleCreateGraphTypeStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1533);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CREATE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CREATE);
      setState(1551);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::GRAPH:
        case GQLParser::PROPERTY: {
          setState(1535);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::PROPERTY) {
            setState(1534);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PROPERTY) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PROPERTY);
          }
          setState(1537);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::GRAPH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::GRAPH);
          setState(1538);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TYPE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TYPE);
          setState(1542);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::IF) {
            setState(1539);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::IF) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::IF);
            setState(1540);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::NOT) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::NOT);
            setState(1541);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::EXISTS) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::EXISTS);
          }
          break;
        }

        case GQLParser::OR: {
          setState(1544);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::OR) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::OR);
          setState(1545);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::REPLACE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::REPLACE);
          setState(1547);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::PROPERTY) {
            setState(1546);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PROPERTY) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PROPERTY);
          }
          setState(1549);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::GRAPH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::GRAPH);
          setState(1550);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TYPE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TYPE);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
      setState(1553);
      {
        auto childCtxHolder = ctx->EnterCatalogGraphTypeParentAndName();
        catalogGraphTypeParentAndName(get_raw_pointer(childCtxHolder));
      }
      setState(1554);
      {
        auto childCtxHolder = ctx->EnterGraphTypeSource();
        graphTypeSource(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphTypeSourceContext : public antlr4::ParserRuleContext {
  public:
    GraphTypeSourceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CopyOfGraphTypeContext *copyOfGraphType();
    antlr4::tree::TerminalNode *AS();
    GraphTypeLikeGraphContext *graphTypeLikeGraph();
    NestedGraphTypeSpecificationContext *nestedGraphTypeSpecification();

   
  };

  template<typename ContextT>
  GraphTypeSourceContext* graphTypeSource(ContextT* ctx) {
    GraphTypeSourceContext *_localctx = _tracker.createInstance<GraphTypeSourceContext>(_ctx, getState());
    enterRule(_localctx, 122, GQLParser::RuleGraphTypeSource);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1565);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1557);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::AS) {
          setState(1556);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::AS) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::AS);
        }
        setState(1559);
        {
          auto childCtxHolder = ctx->EnterCopyOfGraphType();
          copyOfGraphType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1560);
        {
          auto childCtxHolder = ctx->EnterGraphTypeLikeGraph();
          graphTypeLikeGraph(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1562);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::AS) {
          setState(1561);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::AS) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::AS);
        }
        setState(1564);
        {
          auto childCtxHolder = ctx->EnterNestedGraphTypeSpecification();
          nestedGraphTypeSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CopyOfGraphTypeContext : public antlr4::ParserRuleContext {
  public:
    CopyOfGraphTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COPY();
    antlr4::tree::TerminalNode *OF();
    GraphTypeReferenceContext *graphTypeReference();

   
  };

  template<typename ContextT>
  CopyOfGraphTypeContext* copyOfGraphType(ContextT* ctx) {
    CopyOfGraphTypeContext *_localctx = _tracker.createInstance<CopyOfGraphTypeContext>(_ctx, getState());
    enterRule(_localctx, 124, GQLParser::RuleCopyOfGraphType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1567);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COPY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COPY);
      setState(1568);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::OF) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::OF);
      setState(1569);
      {
        auto childCtxHolder = ctx->EnterGraphTypeReference();
        graphTypeReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DropGraphTypeStatementContext : public antlr4::ParserRuleContext {
  public:
    DropGraphTypeStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DROP();
    antlr4::tree::TerminalNode *GRAPH();
    antlr4::tree::TerminalNode *TYPE();
    CatalogGraphTypeParentAndNameContext *catalogGraphTypeParentAndName();
    antlr4::tree::TerminalNode *PROPERTY();
    antlr4::tree::TerminalNode *IF();
    antlr4::tree::TerminalNode *EXISTS();

   
  };

  template<typename ContextT>
  DropGraphTypeStatementContext* dropGraphTypeStatement(ContextT* ctx) {
    DropGraphTypeStatementContext *_localctx = _tracker.createInstance<DropGraphTypeStatementContext>(_ctx, getState());
    enterRule(_localctx, 126, GQLParser::RuleDropGraphTypeStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1571);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DROP) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DROP);
      setState(1573);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PROPERTY) {
        setState(1572);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
      }
      setState(1575);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GRAPH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GRAPH);
      setState(1576);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TYPE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TYPE);
      setState(1579);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IF) {
        setState(1577);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::IF) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::IF);
        setState(1578);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::EXISTS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::EXISTS);
      }
      setState(1581);
      {
        auto childCtxHolder = ctx->EnterCatalogGraphTypeParentAndName();
        catalogGraphTypeParentAndName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CallCatalogModifyingProcedureStatementContext : public antlr4::ParserRuleContext {
  public:
    CallCatalogModifyingProcedureStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CallProcedureStatementContext *callProcedureStatement();

   
  };

  template<typename ContextT>
  CallCatalogModifyingProcedureStatementContext* callCatalogModifyingProcedureStatement(ContextT* ctx) {
    CallCatalogModifyingProcedureStatementContext *_localctx = _tracker.createInstance<CallCatalogModifyingProcedureStatementContext>(_ctx, getState());
    enterRule(_localctx, 128, GQLParser::RuleCallCatalogModifyingProcedureStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1583);
      {
        auto childCtxHolder = ctx->EnterCallProcedureStatement();
        callProcedureStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LinearDataModifyingStatementContext : public antlr4::ParserRuleContext {
  public:
    LinearDataModifyingStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    FocusedLinearDataModifyingStatementContext *focusedLinearDataModifyingStatement();
    AmbientLinearDataModifyingStatementContext *ambientLinearDataModifyingStatement();

   
  };

  template<typename ContextT>
  LinearDataModifyingStatementContext* linearDataModifyingStatement(ContextT* ctx) {
    LinearDataModifyingStatementContext *_localctx = _tracker.createInstance<LinearDataModifyingStatementContext>(_ctx, getState());
    enterRule(_localctx, 130, GQLParser::RuleLinearDataModifyingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1587);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::USE: {
          enterOuterAlt(_localctx, 1);
          setState(1585);
          {
            auto childCtxHolder = ctx->EnterFocusedLinearDataModifyingStatement();
            focusedLinearDataModifyingStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CALL:
        case GQLParser::DELETE:
        case GQLParser::DETACH:
        case GQLParser::FILTER:
        case GQLParser::FOR:
        case GQLParser::INSERT:
        case GQLParser::LET:
        case GQLParser::LIMIT:
        case GQLParser::MATCH:
        case GQLParser::NODETACH:
        case GQLParser::OFFSET:
        case GQLParser::OPTIONAL:
        case GQLParser::ORDER:
        case GQLParser::REMOVE:
        case GQLParser::SET:
        case GQLParser::SKIP_RESERVED_WORD:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(1586);
          {
            auto childCtxHolder = ctx->EnterAmbientLinearDataModifyingStatement();
            ambientLinearDataModifyingStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FocusedLinearDataModifyingStatementContext : public antlr4::ParserRuleContext {
  public:
    FocusedLinearDataModifyingStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    FocusedLinearDataModifyingStatementBodyContext *focusedLinearDataModifyingStatementBody();
    FocusedNestedDataModifyingProcedureSpecificationContext *focusedNestedDataModifyingProcedureSpecification();

   
  };

  template<typename ContextT>
  FocusedLinearDataModifyingStatementContext* focusedLinearDataModifyingStatement(ContextT* ctx) {
    FocusedLinearDataModifyingStatementContext *_localctx = _tracker.createInstance<FocusedLinearDataModifyingStatementContext>(_ctx, getState());
    enterRule(_localctx, 132, GQLParser::RuleFocusedLinearDataModifyingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1591);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1589);
        {
          auto childCtxHolder = ctx->EnterFocusedLinearDataModifyingStatementBody();
          focusedLinearDataModifyingStatementBody(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1590);
        {
          auto childCtxHolder = ctx->EnterFocusedNestedDataModifyingProcedureSpecification();
          focusedNestedDataModifyingProcedureSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FocusedLinearDataModifyingStatementBodyContext : public antlr4::ParserRuleContext {
  public:
    FocusedLinearDataModifyingStatementBodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UseGraphClauseContext *useGraphClause();
    SimpleLinearDataAccessingStatementContext *simpleLinearDataAccessingStatement();
    PrimitiveResultStatementContext *primitiveResultStatement();

   
  };

  template<typename ContextT>
  FocusedLinearDataModifyingStatementBodyContext* focusedLinearDataModifyingStatementBody(ContextT* ctx) {
    FocusedLinearDataModifyingStatementBodyContext *_localctx = _tracker.createInstance<FocusedLinearDataModifyingStatementBodyContext>(_ctx, getState());
    enterRule(_localctx, 134, GQLParser::RuleFocusedLinearDataModifyingStatementBody);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1593);
      {
        auto childCtxHolder = ctx->EnterUseGraphClause();
        useGraphClause(get_raw_pointer(childCtxHolder));
      }
      setState(1594);
      {
        auto childCtxHolder = ctx->EnterSimpleLinearDataAccessingStatement();
        simpleLinearDataAccessingStatement(get_raw_pointer(childCtxHolder));
      }
      setState(1596);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::FINISH || _la == GQLParser::RETURN) {
        setState(1595);
        {
          auto childCtxHolder = ctx->EnterPrimitiveResultStatement();
          primitiveResultStatement(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FocusedNestedDataModifyingProcedureSpecificationContext : public antlr4::ParserRuleContext {
  public:
    FocusedNestedDataModifyingProcedureSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UseGraphClauseContext *useGraphClause();
    NestedDataModifyingProcedureSpecificationContext *nestedDataModifyingProcedureSpecification();

   
  };

  template<typename ContextT>
  FocusedNestedDataModifyingProcedureSpecificationContext* focusedNestedDataModifyingProcedureSpecification(ContextT* ctx) {
    FocusedNestedDataModifyingProcedureSpecificationContext *_localctx = _tracker.createInstance<FocusedNestedDataModifyingProcedureSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 136, GQLParser::RuleFocusedNestedDataModifyingProcedureSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1598);
      {
        auto childCtxHolder = ctx->EnterUseGraphClause();
        useGraphClause(get_raw_pointer(childCtxHolder));
      }
      setState(1599);
      {
        auto childCtxHolder = ctx->EnterNestedDataModifyingProcedureSpecification();
        nestedDataModifyingProcedureSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  AmbientLinearDataModifyingStatementContext : public antlr4::ParserRuleContext {
  public:
    AmbientLinearDataModifyingStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    AmbientLinearDataModifyingStatementBodyContext *ambientLinearDataModifyingStatementBody();
    NestedDataModifyingProcedureSpecificationContext *nestedDataModifyingProcedureSpecification();

   
  };

  template<typename ContextT>
  AmbientLinearDataModifyingStatementContext* ambientLinearDataModifyingStatement(ContextT* ctx) {
    AmbientLinearDataModifyingStatementContext *_localctx = _tracker.createInstance<AmbientLinearDataModifyingStatementContext>(_ctx, getState());
    enterRule(_localctx, 138, GQLParser::RuleAmbientLinearDataModifyingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1603);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CALL:
        case GQLParser::DELETE:
        case GQLParser::DETACH:
        case GQLParser::FILTER:
        case GQLParser::FOR:
        case GQLParser::INSERT:
        case GQLParser::LET:
        case GQLParser::LIMIT:
        case GQLParser::MATCH:
        case GQLParser::NODETACH:
        case GQLParser::OFFSET:
        case GQLParser::OPTIONAL:
        case GQLParser::ORDER:
        case GQLParser::REMOVE:
        case GQLParser::SET:
        case GQLParser::SKIP_RESERVED_WORD: {
          enterOuterAlt(_localctx, 1);
          setState(1601);
          {
            auto childCtxHolder = ctx->EnterAmbientLinearDataModifyingStatementBody();
            ambientLinearDataModifyingStatementBody(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(1602);
          {
            auto childCtxHolder = ctx->EnterNestedDataModifyingProcedureSpecification();
            nestedDataModifyingProcedureSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  AmbientLinearDataModifyingStatementBodyContext : public antlr4::ParserRuleContext {
  public:
    AmbientLinearDataModifyingStatementBodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SimpleLinearDataAccessingStatementContext *simpleLinearDataAccessingStatement();
    PrimitiveResultStatementContext *primitiveResultStatement();

   
  };

  template<typename ContextT>
  AmbientLinearDataModifyingStatementBodyContext* ambientLinearDataModifyingStatementBody(ContextT* ctx) {
    AmbientLinearDataModifyingStatementBodyContext *_localctx = _tracker.createInstance<AmbientLinearDataModifyingStatementBodyContext>(_ctx, getState());
    enterRule(_localctx, 140, GQLParser::RuleAmbientLinearDataModifyingStatementBody);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1605);
      {
        auto childCtxHolder = ctx->EnterSimpleLinearDataAccessingStatement();
        simpleLinearDataAccessingStatement(get_raw_pointer(childCtxHolder));
      }
      setState(1607);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::FINISH || _la == GQLParser::RETURN) {
        setState(1606);
        {
          auto childCtxHolder = ctx->EnterPrimitiveResultStatement();
          primitiveResultStatement(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimpleLinearDataAccessingStatementContext : public antlr4::ParserRuleContext {
  public:
    SimpleLinearDataAccessingStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<SimpleDataAccessingStatementContext *> simpleDataAccessingStatement();
    SimpleDataAccessingStatementContext* simpleDataAccessingStatement(size_t i);

   
  };

  template<typename ContextT>
  SimpleLinearDataAccessingStatementContext* simpleLinearDataAccessingStatement(ContextT* ctx) {
    SimpleLinearDataAccessingStatementContext *_localctx = _tracker.createInstance<SimpleLinearDataAccessingStatementContext>(_ctx, getState());
    enterRule(_localctx, 142, GQLParser::RuleSimpleLinearDataAccessingStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1610); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1609);
        {
          auto childCtxHolder = ctx->EnterSimpleDataAccessingStatement();
          simpleDataAccessingStatement(get_raw_pointer(childCtxHolder));
        }
        setState(1612); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == GQLParser::CALL || ((((_la - 76) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 76)) & 90072009744089097) != 0) || ((((_la - 143) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 143)) & 4644354296316033) != 0));
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimpleDataAccessingStatementContext : public antlr4::ParserRuleContext {
  public:
    SimpleDataAccessingStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SimpleQueryStatementContext *simpleQueryStatement();
    SimpleDataModifyingStatementContext *simpleDataModifyingStatement();

   
  };

  template<typename ContextT>
  SimpleDataAccessingStatementContext* simpleDataAccessingStatement(ContextT* ctx) {
    SimpleDataAccessingStatementContext *_localctx = _tracker.createInstance<SimpleDataAccessingStatementContext>(_ctx, getState());
    enterRule(_localctx, 144, GQLParser::RuleSimpleDataAccessingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1616);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1614);
        {
          auto childCtxHolder = ctx->EnterSimpleQueryStatement();
          simpleQueryStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1615);
        {
          auto childCtxHolder = ctx->EnterSimpleDataModifyingStatement();
          simpleDataModifyingStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimpleDataModifyingStatementContext : public antlr4::ParserRuleContext {
  public:
    SimpleDataModifyingStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PrimitiveDataModifyingStatementContext *primitiveDataModifyingStatement();
    CallDataModifyingProcedureStatementContext *callDataModifyingProcedureStatement();

   
  };

  template<typename ContextT>
  SimpleDataModifyingStatementContext* simpleDataModifyingStatement(ContextT* ctx) {
    SimpleDataModifyingStatementContext *_localctx = _tracker.createInstance<SimpleDataModifyingStatementContext>(_ctx, getState());
    enterRule(_localctx, 146, GQLParser::RuleSimpleDataModifyingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1620);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::DELETE:
        case GQLParser::DETACH:
        case GQLParser::INSERT:
        case GQLParser::NODETACH:
        case GQLParser::REMOVE:
        case GQLParser::SET: {
          enterOuterAlt(_localctx, 1);
          setState(1618);
          {
            auto childCtxHolder = ctx->EnterPrimitiveDataModifyingStatement();
            primitiveDataModifyingStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CALL:
        case GQLParser::OPTIONAL: {
          enterOuterAlt(_localctx, 2);
          setState(1619);
          {
            auto childCtxHolder = ctx->EnterCallDataModifyingProcedureStatement();
            callDataModifyingProcedureStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PrimitiveDataModifyingStatementContext : public antlr4::ParserRuleContext {
  public:
    PrimitiveDataModifyingStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    InsertStatementContext *insertStatement();
    SetStatementContext *setStatement();
    RemoveStatementContext *removeStatement();
    DeleteStatementContext *deleteStatement();

   
  };

  template<typename ContextT>
  PrimitiveDataModifyingStatementContext* primitiveDataModifyingStatement(ContextT* ctx) {
    PrimitiveDataModifyingStatementContext *_localctx = _tracker.createInstance<PrimitiveDataModifyingStatementContext>(_ctx, getState());
    enterRule(_localctx, 148, GQLParser::RulePrimitiveDataModifyingStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1626);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::INSERT: {
          enterOuterAlt(_localctx, 1);
          setState(1622);
          {
            auto childCtxHolder = ctx->EnterInsertStatement();
            insertStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::SET: {
          enterOuterAlt(_localctx, 2);
          setState(1623);
          {
            auto childCtxHolder = ctx->EnterSetStatement();
            setStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::REMOVE: {
          enterOuterAlt(_localctx, 3);
          setState(1624);
          {
            auto childCtxHolder = ctx->EnterRemoveStatement();
            removeStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DELETE:
        case GQLParser::DETACH:
        case GQLParser::NODETACH: {
          enterOuterAlt(_localctx, 4);
          setState(1625);
          {
            auto childCtxHolder = ctx->EnterDeleteStatement();
            deleteStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  InsertStatementContext : public antlr4::ParserRuleContext {
  public:
    InsertStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INSERT();
    InsertGraphPatternContext *insertGraphPattern();

   
  };

  template<typename ContextT>
  InsertStatementContext* insertStatement(ContextT* ctx) {
    InsertStatementContext *_localctx = _tracker.createInstance<InsertStatementContext>(_ctx, getState());
    enterRule(_localctx, 150, GQLParser::RuleInsertStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1628);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::INSERT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::INSERT);
      setState(1629);
      {
        auto childCtxHolder = ctx->EnterInsertGraphPattern();
        insertGraphPattern(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SetStatementContext : public antlr4::ParserRuleContext {
  public:
    SetStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SET();
    SetItemListContext *setItemList();

   
  };

  template<typename ContextT>
  SetStatementContext* setStatement(ContextT* ctx) {
    SetStatementContext *_localctx = _tracker.createInstance<SetStatementContext>(_ctx, getState());
    enterRule(_localctx, 152, GQLParser::RuleSetStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1631);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SET);
      setState(1632);
      {
        auto childCtxHolder = ctx->EnterSetItemList();
        setItemList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SetItemListContext : public antlr4::ParserRuleContext {
  public:
    SetItemListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<SetItemContext *> setItem();
    SetItemContext* setItem(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  SetItemListContext* setItemList(ContextT* ctx) {
    SetItemListContext *_localctx = _tracker.createInstance<SetItemListContext>(_ctx, getState());
    enterRule(_localctx, 154, GQLParser::RuleSetItemList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1634);
      {
        auto childCtxHolder = ctx->EnterSetItem();
        setItem(get_raw_pointer(childCtxHolder));
      }
      setState(1639);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(1635);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(1636);
        {
          auto childCtxHolder = ctx->EnterSetItem();
          setItem(get_raw_pointer(childCtxHolder));
        }
        setState(1641);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SetItemContext : public antlr4::ParserRuleContext {
  public:
    SetItemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SetPropertyItemContext *setPropertyItem();
    SetAllPropertiesItemContext *setAllPropertiesItem();
    SetLabelItemContext *setLabelItem();

   
  };

  template<typename ContextT>
  SetItemContext* setItem(ContextT* ctx) {
    SetItemContext *_localctx = _tracker.createInstance<SetItemContext>(_ctx, getState());
    enterRule(_localctx, 156, GQLParser::RuleSetItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1645);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1642);
        {
          auto childCtxHolder = ctx->EnterSetPropertyItem();
          setPropertyItem(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1643);
        {
          auto childCtxHolder = ctx->EnterSetAllPropertiesItem();
          setAllPropertiesItem(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1644);
        {
          auto childCtxHolder = ctx->EnterSetLabelItem();
          setLabelItem(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SetPropertyItemContext : public antlr4::ParserRuleContext {
  public:
    SetPropertyItemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BindingVariableReferenceContext *bindingVariableReference();
    antlr4::tree::TerminalNode *PERIOD();
    PropertyNameContext *propertyName();
    antlr4::tree::TerminalNode *EQUALS_OPERATOR();
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  SetPropertyItemContext* setPropertyItem(ContextT* ctx) {
    SetPropertyItemContext *_localctx = _tracker.createInstance<SetPropertyItemContext>(_ctx, getState());
    enterRule(_localctx, 158, GQLParser::RuleSetPropertyItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1647);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(1648);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::PERIOD) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::PERIOD);
      setState(1649);
      {
        auto childCtxHolder = ctx->EnterPropertyName();
        propertyName(get_raw_pointer(childCtxHolder));
      }
      setState(1650);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EQUALS_OPERATOR);
      setState(1651);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SetAllPropertiesItemContext : public antlr4::ParserRuleContext {
  public:
    SetAllPropertiesItemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BindingVariableReferenceContext *bindingVariableReference();
    antlr4::tree::TerminalNode *EQUALS_OPERATOR();
    antlr4::tree::TerminalNode *LEFT_BRACE();
    antlr4::tree::TerminalNode *RIGHT_BRACE();
    PropertyKeyValuePairListContext *propertyKeyValuePairList();

   
  };

  template<typename ContextT>
  SetAllPropertiesItemContext* setAllPropertiesItem(ContextT* ctx) {
    SetAllPropertiesItemContext *_localctx = _tracker.createInstance<SetAllPropertiesItemContext>(_ctx, getState());
    enterRule(_localctx, 160, GQLParser::RuleSetAllPropertiesItem);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1653);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(1654);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EQUALS_OPERATOR);
      setState(1655);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(1657);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE

      || _la == GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0)) {
        setState(1656);
        {
          auto childCtxHolder = ctx->EnterPropertyKeyValuePairList();
          propertyKeyValuePairList(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1659);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SetLabelItemContext : public antlr4::ParserRuleContext {
  public:
    SetLabelItemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BindingVariableReferenceContext *bindingVariableReference();
    IsOrColonContext *isOrColon();
    LabelNameContext *labelName();

   
  };

  template<typename ContextT>
  SetLabelItemContext* setLabelItem(ContextT* ctx) {
    SetLabelItemContext *_localctx = _tracker.createInstance<SetLabelItemContext>(_ctx, getState());
    enterRule(_localctx, 162, GQLParser::RuleSetLabelItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1661);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(1662);
      {
        auto childCtxHolder = ctx->EnterIsOrColon();
        isOrColon(get_raw_pointer(childCtxHolder));
      }
      setState(1663);
      {
        auto childCtxHolder = ctx->EnterLabelName();
        labelName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  RemoveStatementContext : public antlr4::ParserRuleContext {
  public:
    RemoveStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REMOVE();
    RemoveItemListContext *removeItemList();

   
  };

  template<typename ContextT>
  RemoveStatementContext* removeStatement(ContextT* ctx) {
    RemoveStatementContext *_localctx = _tracker.createInstance<RemoveStatementContext>(_ctx, getState());
    enterRule(_localctx, 164, GQLParser::RuleRemoveStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1665);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::REMOVE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::REMOVE);
      setState(1666);
      {
        auto childCtxHolder = ctx->EnterRemoveItemList();
        removeItemList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  RemoveItemListContext : public antlr4::ParserRuleContext {
  public:
    RemoveItemListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<RemoveItemContext *> removeItem();
    RemoveItemContext* removeItem(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  RemoveItemListContext* removeItemList(ContextT* ctx) {
    RemoveItemListContext *_localctx = _tracker.createInstance<RemoveItemListContext>(_ctx, getState());
    enterRule(_localctx, 166, GQLParser::RuleRemoveItemList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1668);
      {
        auto childCtxHolder = ctx->EnterRemoveItem();
        removeItem(get_raw_pointer(childCtxHolder));
      }
      setState(1673);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(1669);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(1670);
        {
          auto childCtxHolder = ctx->EnterRemoveItem();
          removeItem(get_raw_pointer(childCtxHolder));
        }
        setState(1675);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  RemoveItemContext : public antlr4::ParserRuleContext {
  public:
    RemoveItemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    RemovePropertyItemContext *removePropertyItem();
    RemoveLabelItemContext *removeLabelItem();

   
  };

  template<typename ContextT>
  RemoveItemContext* removeItem(ContextT* ctx) {
    RemoveItemContext *_localctx = _tracker.createInstance<RemoveItemContext>(_ctx, getState());
    enterRule(_localctx, 168, GQLParser::RuleRemoveItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1678);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1676);
        {
          auto childCtxHolder = ctx->EnterRemovePropertyItem();
          removePropertyItem(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1677);
        {
          auto childCtxHolder = ctx->EnterRemoveLabelItem();
          removeLabelItem(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  RemovePropertyItemContext : public antlr4::ParserRuleContext {
  public:
    RemovePropertyItemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BindingVariableReferenceContext *bindingVariableReference();
    antlr4::tree::TerminalNode *PERIOD();
    PropertyNameContext *propertyName();

   
  };

  template<typename ContextT>
  RemovePropertyItemContext* removePropertyItem(ContextT* ctx) {
    RemovePropertyItemContext *_localctx = _tracker.createInstance<RemovePropertyItemContext>(_ctx, getState());
    enterRule(_localctx, 170, GQLParser::RuleRemovePropertyItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1680);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(1681);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::PERIOD) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::PERIOD);
      setState(1682);
      {
        auto childCtxHolder = ctx->EnterPropertyName();
        propertyName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  RemoveLabelItemContext : public antlr4::ParserRuleContext {
  public:
    RemoveLabelItemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BindingVariableReferenceContext *bindingVariableReference();
    IsOrColonContext *isOrColon();
    LabelNameContext *labelName();

   
  };

  template<typename ContextT>
  RemoveLabelItemContext* removeLabelItem(ContextT* ctx) {
    RemoveLabelItemContext *_localctx = _tracker.createInstance<RemoveLabelItemContext>(_ctx, getState());
    enterRule(_localctx, 172, GQLParser::RuleRemoveLabelItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1684);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(1685);
      {
        auto childCtxHolder = ctx->EnterIsOrColon();
        isOrColon(get_raw_pointer(childCtxHolder));
      }
      setState(1686);
      {
        auto childCtxHolder = ctx->EnterLabelName();
        labelName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DeleteStatementContext : public antlr4::ParserRuleContext {
  public:
    DeleteStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DELETE();
    DeleteItemListContext *deleteItemList();
    antlr4::tree::TerminalNode *DETACH();
    antlr4::tree::TerminalNode *NODETACH();

   
  };

  template<typename ContextT>
  DeleteStatementContext* deleteStatement(ContextT* ctx) {
    DeleteStatementContext *_localctx = _tracker.createInstance<DeleteStatementContext>(_ctx, getState());
    enterRule(_localctx, 174, GQLParser::RuleDeleteStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1689);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::DETACH || _la == GQLParser::NODETACH) {
        setState(1688);
        _la = _input->LA(1);
        if (!(_la == GQLParser::DETACH || _la == GQLParser::NODETACH)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          antlr4::Token * token = consume();
          ctx->OnToken(token);
        }
      }
      setState(1691);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DELETE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DELETE);
      setState(1692);
      {
        auto childCtxHolder = ctx->EnterDeleteItemList();
        deleteItemList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DeleteItemListContext : public antlr4::ParserRuleContext {
  public:
    DeleteItemListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<DeleteItemContext *> deleteItem();
    DeleteItemContext* deleteItem(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  DeleteItemListContext* deleteItemList(ContextT* ctx) {
    DeleteItemListContext *_localctx = _tracker.createInstance<DeleteItemListContext>(_ctx, getState());
    enterRule(_localctx, 176, GQLParser::RuleDeleteItemList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1694);
      {
        auto childCtxHolder = ctx->EnterDeleteItem();
        deleteItem(get_raw_pointer(childCtxHolder));
      }
      setState(1699);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(1695);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(1696);
        {
          auto childCtxHolder = ctx->EnterDeleteItem();
          deleteItem(get_raw_pointer(childCtxHolder));
        }
        setState(1701);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DeleteItemContext : public antlr4::ParserRuleContext {
  public:
    DeleteItemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  DeleteItemContext* deleteItem(ContextT* ctx) {
    DeleteItemContext *_localctx = _tracker.createInstance<DeleteItemContext>(_ctx, getState());
    enterRule(_localctx, 178, GQLParser::RuleDeleteItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1702);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CallDataModifyingProcedureStatementContext : public antlr4::ParserRuleContext {
  public:
    CallDataModifyingProcedureStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CallProcedureStatementContext *callProcedureStatement();

   
  };

  template<typename ContextT>
  CallDataModifyingProcedureStatementContext* callDataModifyingProcedureStatement(ContextT* ctx) {
    CallDataModifyingProcedureStatementContext *_localctx = _tracker.createInstance<CallDataModifyingProcedureStatementContext>(_ctx, getState());
    enterRule(_localctx, 180, GQLParser::RuleCallDataModifyingProcedureStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1704);
      {
        auto childCtxHolder = ctx->EnterCallProcedureStatement();
        callProcedureStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CompositeQueryStatementContext : public antlr4::ParserRuleContext {
  public:
    CompositeQueryStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CompositeQueryExpressionContext *compositeQueryExpression();

   
  };

  template<typename ContextT>
  CompositeQueryStatementContext* compositeQueryStatement(ContextT* ctx) {
    CompositeQueryStatementContext *_localctx = _tracker.createInstance<CompositeQueryStatementContext>(_ctx, getState());
    enterRule(_localctx, 182, GQLParser::RuleCompositeQueryStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1706);
      {
        auto childCtxHolder = ctx->EnterCompositeQueryExpression();
        compositeQueryExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CompositeQueryExpressionContext : public antlr4::ParserRuleContext {
  public:
    CompositeQueryExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CompositeQueryPrimaryContext *compositeQueryPrimary();
    CompositeQueryExpressionContext *compositeQueryExpression();
    QueryConjunctionContext *queryConjunction();

   
  };


  template<typename ContextT>
  CompositeQueryExpressionContext* compositeQueryExpression(ContextT* ctx) {
     return compositeQueryExpression(0, ctx);
  }

  template<typename ContextT>
  CompositeQueryExpressionContext* compositeQueryExpression(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    GQLParser::CompositeQueryExpressionContext *_localctx = _tracker.createInstance<CompositeQueryExpressionContext>(_ctx, parentState);
    GQLParser::CompositeQueryExpressionContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 184;
    enterRecursionRule(_localctx, 184, GQLParser::RuleCompositeQueryExpression, precedence);

      

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(1709);
      {
        auto childCtxHolder = ctx->EnterCompositeQueryPrimary();
        compositeQueryPrimary(get_raw_pointer(childCtxHolder));
      }
      _ctx->stop = _input->LT(-1);
      setState(1717);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          _localctx = _tracker.createInstance<CompositeQueryExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleCompositeQueryExpression);
          ctx->PushCompositeQueryExpression();
          setState(1711);

          if (!(precpred(_ctx, 2))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(1712);
          {
            auto childCtxHolder = ctx->EnterQueryConjunction();
            queryConjunction(get_raw_pointer(childCtxHolder));
          }
          setState(1713);
          {
            auto childCtxHolder = ctx->EnterCompositeQueryPrimary();
            compositeQueryPrimary(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(1719);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }

  class  QueryConjunctionContext : public antlr4::ParserRuleContext {
  public:
    QueryConjunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SetOperatorContext *setOperator();
    antlr4::tree::TerminalNode *OTHERWISE();

   
  };

  template<typename ContextT>
  QueryConjunctionContext* queryConjunction(ContextT* ctx) {
    QueryConjunctionContext *_localctx = _tracker.createInstance<QueryConjunctionContext>(_ctx, getState());
    enterRule(_localctx, 186, GQLParser::RuleQueryConjunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1722);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::EXCEPT:
        case GQLParser::INTERSECT:
        case GQLParser::UNION: {
          enterOuterAlt(_localctx, 1);
          setState(1720);
          {
            auto childCtxHolder = ctx->EnterSetOperator();
            setOperator(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::OTHERWISE: {
          enterOuterAlt(_localctx, 2);
          setState(1721);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::OTHERWISE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::OTHERWISE);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SetOperatorContext : public antlr4::ParserRuleContext {
  public:
    SetOperatorContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNION();
    SetQuantifierContext *setQuantifier();
    antlr4::tree::TerminalNode *EXCEPT();
    antlr4::tree::TerminalNode *INTERSECT();

   
  };

  template<typename ContextT>
  SetOperatorContext* setOperator(ContextT* ctx) {
    SetOperatorContext *_localctx = _tracker.createInstance<SetOperatorContext>(_ctx, getState());
    enterRule(_localctx, 188, GQLParser::RuleSetOperator);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1736);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::UNION: {
          enterOuterAlt(_localctx, 1);
          setState(1724);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UNION) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UNION);
          setState(1726);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::ALL

          || _la == GQLParser::DISTINCT) {
            setState(1725);
            {
              auto childCtxHolder = ctx->EnterSetQuantifier();
              setQuantifier(get_raw_pointer(childCtxHolder));
            }
          }
          break;
        }

        case GQLParser::EXCEPT: {
          enterOuterAlt(_localctx, 2);
          setState(1728);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::EXCEPT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::EXCEPT);
          setState(1730);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::ALL

          || _la == GQLParser::DISTINCT) {
            setState(1729);
            {
              auto childCtxHolder = ctx->EnterSetQuantifier();
              setQuantifier(get_raw_pointer(childCtxHolder));
            }
          }
          break;
        }

        case GQLParser::INTERSECT: {
          enterOuterAlt(_localctx, 3);
          setState(1732);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTERSECT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTERSECT);
          setState(1734);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::ALL

          || _la == GQLParser::DISTINCT) {
            setState(1733);
            {
              auto childCtxHolder = ctx->EnterSetQuantifier();
              setQuantifier(get_raw_pointer(childCtxHolder));
            }
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CompositeQueryPrimaryContext : public antlr4::ParserRuleContext {
  public:
    CompositeQueryPrimaryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    LinearQueryStatementContext *linearQueryStatement();

   
  };

  template<typename ContextT>
  CompositeQueryPrimaryContext* compositeQueryPrimary(ContextT* ctx) {
    CompositeQueryPrimaryContext *_localctx = _tracker.createInstance<CompositeQueryPrimaryContext>(_ctx, getState());
    enterRule(_localctx, 190, GQLParser::RuleCompositeQueryPrimary);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1738);
      {
        auto childCtxHolder = ctx->EnterLinearQueryStatement();
        linearQueryStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LinearQueryStatementContext : public antlr4::ParserRuleContext {
  public:
    LinearQueryStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    FocusedLinearQueryStatementContext *focusedLinearQueryStatement();
    AmbientLinearQueryStatementContext *ambientLinearQueryStatement();

   
  };

  template<typename ContextT>
  LinearQueryStatementContext* linearQueryStatement(ContextT* ctx) {
    LinearQueryStatementContext *_localctx = _tracker.createInstance<LinearQueryStatementContext>(_ctx, getState());
    enterRule(_localctx, 192, GQLParser::RuleLinearQueryStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1742);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::SELECT:
        case GQLParser::USE: {
          enterOuterAlt(_localctx, 1);
          setState(1740);
          {
            auto childCtxHolder = ctx->EnterFocusedLinearQueryStatement();
            focusedLinearQueryStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CALL:
        case GQLParser::FILTER:
        case GQLParser::FINISH:
        case GQLParser::FOR:
        case GQLParser::LET:
        case GQLParser::LIMIT:
        case GQLParser::MATCH:
        case GQLParser::OFFSET:
        case GQLParser::OPTIONAL:
        case GQLParser::ORDER:
        case GQLParser::RETURN:
        case GQLParser::SKIP_RESERVED_WORD:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(1741);
          {
            auto childCtxHolder = ctx->EnterAmbientLinearQueryStatement();
            ambientLinearQueryStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FocusedLinearQueryStatementContext : public antlr4::ParserRuleContext {
  public:
    FocusedLinearQueryStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    FocusedLinearQueryAndPrimitiveResultStatementPartContext *focusedLinearQueryAndPrimitiveResultStatementPart();
    std::vector<FocusedLinearQueryStatementPartContext *> focusedLinearQueryStatementPart();
    FocusedLinearQueryStatementPartContext* focusedLinearQueryStatementPart(size_t i);
    FocusedPrimitiveResultStatementContext *focusedPrimitiveResultStatement();
    FocusedNestedQuerySpecificationContext *focusedNestedQuerySpecification();
    SelectStatementContext *selectStatement();

   
  };

  template<typename ContextT>
  FocusedLinearQueryStatementContext* focusedLinearQueryStatement(ContextT* ctx) {
    FocusedLinearQueryStatementContext *_localctx = _tracker.createInstance<FocusedLinearQueryStatementContext>(_ctx, getState());
    enterRule(_localctx, 194, GQLParser::RuleFocusedLinearQueryStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      setState(1754);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1747);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx);
        while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(1744);
            {
              auto childCtxHolder = ctx->EnterFocusedLinearQueryStatementPart();
              focusedLinearQueryStatementPart(get_raw_pointer(childCtxHolder));
            } 
          }
          setState(1749);
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx);
        }
        setState(1750);
        {
          auto childCtxHolder = ctx->EnterFocusedLinearQueryAndPrimitiveResultStatementPart();
          focusedLinearQueryAndPrimitiveResultStatementPart(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1751);
        {
          auto childCtxHolder = ctx->EnterFocusedPrimitiveResultStatement();
          focusedPrimitiveResultStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1752);
        {
          auto childCtxHolder = ctx->EnterFocusedNestedQuerySpecification();
          focusedNestedQuerySpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(1753);
        {
          auto childCtxHolder = ctx->EnterSelectStatement();
          selectStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FocusedLinearQueryStatementPartContext : public antlr4::ParserRuleContext {
  public:
    FocusedLinearQueryStatementPartContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UseGraphClauseContext *useGraphClause();
    SimpleLinearQueryStatementContext *simpleLinearQueryStatement();

   
  };

  template<typename ContextT>
  FocusedLinearQueryStatementPartContext* focusedLinearQueryStatementPart(ContextT* ctx) {
    FocusedLinearQueryStatementPartContext *_localctx = _tracker.createInstance<FocusedLinearQueryStatementPartContext>(_ctx, getState());
    enterRule(_localctx, 196, GQLParser::RuleFocusedLinearQueryStatementPart);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1756);
      {
        auto childCtxHolder = ctx->EnterUseGraphClause();
        useGraphClause(get_raw_pointer(childCtxHolder));
      }
      setState(1757);
      {
        auto childCtxHolder = ctx->EnterSimpleLinearQueryStatement();
        simpleLinearQueryStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FocusedLinearQueryAndPrimitiveResultStatementPartContext : public antlr4::ParserRuleContext {
  public:
    FocusedLinearQueryAndPrimitiveResultStatementPartContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UseGraphClauseContext *useGraphClause();
    SimpleLinearQueryStatementContext *simpleLinearQueryStatement();
    PrimitiveResultStatementContext *primitiveResultStatement();

   
  };

  template<typename ContextT>
  FocusedLinearQueryAndPrimitiveResultStatementPartContext* focusedLinearQueryAndPrimitiveResultStatementPart(ContextT* ctx) {
    FocusedLinearQueryAndPrimitiveResultStatementPartContext *_localctx = _tracker.createInstance<FocusedLinearQueryAndPrimitiveResultStatementPartContext>(_ctx, getState());
    enterRule(_localctx, 198, GQLParser::RuleFocusedLinearQueryAndPrimitiveResultStatementPart);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1759);
      {
        auto childCtxHolder = ctx->EnterUseGraphClause();
        useGraphClause(get_raw_pointer(childCtxHolder));
      }
      setState(1760);
      {
        auto childCtxHolder = ctx->EnterSimpleLinearQueryStatement();
        simpleLinearQueryStatement(get_raw_pointer(childCtxHolder));
      }
      setState(1761);
      {
        auto childCtxHolder = ctx->EnterPrimitiveResultStatement();
        primitiveResultStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FocusedPrimitiveResultStatementContext : public antlr4::ParserRuleContext {
  public:
    FocusedPrimitiveResultStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UseGraphClauseContext *useGraphClause();
    PrimitiveResultStatementContext *primitiveResultStatement();

   
  };

  template<typename ContextT>
  FocusedPrimitiveResultStatementContext* focusedPrimitiveResultStatement(ContextT* ctx) {
    FocusedPrimitiveResultStatementContext *_localctx = _tracker.createInstance<FocusedPrimitiveResultStatementContext>(_ctx, getState());
    enterRule(_localctx, 200, GQLParser::RuleFocusedPrimitiveResultStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1763);
      {
        auto childCtxHolder = ctx->EnterUseGraphClause();
        useGraphClause(get_raw_pointer(childCtxHolder));
      }
      setState(1764);
      {
        auto childCtxHolder = ctx->EnterPrimitiveResultStatement();
        primitiveResultStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FocusedNestedQuerySpecificationContext : public antlr4::ParserRuleContext {
  public:
    FocusedNestedQuerySpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UseGraphClauseContext *useGraphClause();
    NestedQuerySpecificationContext *nestedQuerySpecification();

   
  };

  template<typename ContextT>
  FocusedNestedQuerySpecificationContext* focusedNestedQuerySpecification(ContextT* ctx) {
    FocusedNestedQuerySpecificationContext *_localctx = _tracker.createInstance<FocusedNestedQuerySpecificationContext>(_ctx, getState());
    enterRule(_localctx, 202, GQLParser::RuleFocusedNestedQuerySpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1766);
      {
        auto childCtxHolder = ctx->EnterUseGraphClause();
        useGraphClause(get_raw_pointer(childCtxHolder));
      }
      setState(1767);
      {
        auto childCtxHolder = ctx->EnterNestedQuerySpecification();
        nestedQuerySpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  AmbientLinearQueryStatementContext : public antlr4::ParserRuleContext {
  public:
    AmbientLinearQueryStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PrimitiveResultStatementContext *primitiveResultStatement();
    SimpleLinearQueryStatementContext *simpleLinearQueryStatement();
    NestedQuerySpecificationContext *nestedQuerySpecification();

   
  };

  template<typename ContextT>
  AmbientLinearQueryStatementContext* ambientLinearQueryStatement(ContextT* ctx) {
    AmbientLinearQueryStatementContext *_localctx = _tracker.createInstance<AmbientLinearQueryStatementContext>(_ctx, getState());
    enterRule(_localctx, 204, GQLParser::RuleAmbientLinearQueryStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1774);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CALL:
        case GQLParser::FILTER:
        case GQLParser::FINISH:
        case GQLParser::FOR:
        case GQLParser::LET:
        case GQLParser::LIMIT:
        case GQLParser::MATCH:
        case GQLParser::OFFSET:
        case GQLParser::OPTIONAL:
        case GQLParser::ORDER:
        case GQLParser::RETURN:
        case GQLParser::SKIP_RESERVED_WORD: {
          enterOuterAlt(_localctx, 1);
          setState(1770);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::CALL || ((((_la - 91) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 91)) & 4506348406440449) != 0) || ((((_la - 159) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 159)) & 68719476747) != 0)) {
            setState(1769);
            {
              auto childCtxHolder = ctx->EnterSimpleLinearQueryStatement();
              simpleLinearQueryStatement(get_raw_pointer(childCtxHolder));
            }
          }
          setState(1772);
          {
            auto childCtxHolder = ctx->EnterPrimitiveResultStatement();
            primitiveResultStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(1773);
          {
            auto childCtxHolder = ctx->EnterNestedQuerySpecification();
            nestedQuerySpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimpleLinearQueryStatementContext : public antlr4::ParserRuleContext {
  public:
    SimpleLinearQueryStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<SimpleQueryStatementContext *> simpleQueryStatement();
    SimpleQueryStatementContext* simpleQueryStatement(size_t i);

   
  };

  template<typename ContextT>
  SimpleLinearQueryStatementContext* simpleLinearQueryStatement(ContextT* ctx) {
    SimpleLinearQueryStatementContext *_localctx = _tracker.createInstance<SimpleLinearQueryStatementContext>(_ctx, getState());
    enterRule(_localctx, 206, GQLParser::RuleSimpleLinearQueryStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1777); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1776);
        {
          auto childCtxHolder = ctx->EnterSimpleQueryStatement();
          simpleQueryStatement(get_raw_pointer(childCtxHolder));
        }
        setState(1779); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == GQLParser::CALL || ((((_la - 91) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 91)) & 4506348406440449) != 0) || ((((_la - 159) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 159)) & 68719476747) != 0));
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimpleQueryStatementContext : public antlr4::ParserRuleContext {
  public:
    SimpleQueryStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PrimitiveQueryStatementContext *primitiveQueryStatement();
    CallQueryStatementContext *callQueryStatement();

   
  };

  template<typename ContextT>
  SimpleQueryStatementContext* simpleQueryStatement(ContextT* ctx) {
    SimpleQueryStatementContext *_localctx = _tracker.createInstance<SimpleQueryStatementContext>(_ctx, getState());
    enterRule(_localctx, 208, GQLParser::RuleSimpleQueryStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1783);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1781);
        {
          auto childCtxHolder = ctx->EnterPrimitiveQueryStatement();
          primitiveQueryStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1782);
        {
          auto childCtxHolder = ctx->EnterCallQueryStatement();
          callQueryStatement(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PrimitiveQueryStatementContext : public antlr4::ParserRuleContext {
  public:
    PrimitiveQueryStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    MatchStatementContext *matchStatement();
    LetStatementContext *letStatement();
    ForStatementContext *forStatement();
    FilterStatementContext *filterStatement();
    OrderByAndPageStatementContext *orderByAndPageStatement();

   
  };

  template<typename ContextT>
  PrimitiveQueryStatementContext* primitiveQueryStatement(ContextT* ctx) {
    PrimitiveQueryStatementContext *_localctx = _tracker.createInstance<PrimitiveQueryStatementContext>(_ctx, getState());
    enterRule(_localctx, 210, GQLParser::RulePrimitiveQueryStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1790);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::MATCH:
        case GQLParser::OPTIONAL: {
          enterOuterAlt(_localctx, 1);
          setState(1785);
          {
            auto childCtxHolder = ctx->EnterMatchStatement();
            matchStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LET: {
          enterOuterAlt(_localctx, 2);
          setState(1786);
          {
            auto childCtxHolder = ctx->EnterLetStatement();
            letStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::FOR: {
          enterOuterAlt(_localctx, 3);
          setState(1787);
          {
            auto childCtxHolder = ctx->EnterForStatement();
            forStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::FILTER: {
          enterOuterAlt(_localctx, 4);
          setState(1788);
          {
            auto childCtxHolder = ctx->EnterFilterStatement();
            filterStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LIMIT:
        case GQLParser::OFFSET:
        case GQLParser::ORDER:
        case GQLParser::SKIP_RESERVED_WORD: {
          enterOuterAlt(_localctx, 5);
          setState(1789);
          {
            auto childCtxHolder = ctx->EnterOrderByAndPageStatement();
            orderByAndPageStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  MatchStatementContext : public antlr4::ParserRuleContext {
  public:
    MatchStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SimpleMatchStatementContext *simpleMatchStatement();
    OptionalMatchStatementContext *optionalMatchStatement();

   
  };

  template<typename ContextT>
  MatchStatementContext* matchStatement(ContextT* ctx) {
    MatchStatementContext *_localctx = _tracker.createInstance<MatchStatementContext>(_ctx, getState());
    enterRule(_localctx, 212, GQLParser::RuleMatchStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1794);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::MATCH: {
          enterOuterAlt(_localctx, 1);
          setState(1792);
          {
            auto childCtxHolder = ctx->EnterSimpleMatchStatement();
            simpleMatchStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::OPTIONAL: {
          enterOuterAlt(_localctx, 2);
          setState(1793);
          {
            auto childCtxHolder = ctx->EnterOptionalMatchStatement();
            optionalMatchStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimpleMatchStatementContext : public antlr4::ParserRuleContext {
  public:
    SimpleMatchStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MATCH();
    GraphPatternBindingTableContext *graphPatternBindingTable();

   
  };

  template<typename ContextT>
  SimpleMatchStatementContext* simpleMatchStatement(ContextT* ctx) {
    SimpleMatchStatementContext *_localctx = _tracker.createInstance<SimpleMatchStatementContext>(_ctx, getState());
    enterRule(_localctx, 214, GQLParser::RuleSimpleMatchStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1796);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MATCH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MATCH);
      setState(1797);
      {
        auto childCtxHolder = ctx->EnterGraphPatternBindingTable();
        graphPatternBindingTable(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  OptionalMatchStatementContext : public antlr4::ParserRuleContext {
  public:
    OptionalMatchStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OPTIONAL();
    OptionalOperandContext *optionalOperand();

   
  };

  template<typename ContextT>
  OptionalMatchStatementContext* optionalMatchStatement(ContextT* ctx) {
    OptionalMatchStatementContext *_localctx = _tracker.createInstance<OptionalMatchStatementContext>(_ctx, getState());
    enterRule(_localctx, 216, GQLParser::RuleOptionalMatchStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1799);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::OPTIONAL) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::OPTIONAL);
      setState(1800);
      {
        auto childCtxHolder = ctx->EnterOptionalOperand();
        optionalOperand(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  OptionalOperandContext : public antlr4::ParserRuleContext {
  public:
    OptionalOperandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SimpleMatchStatementContext *simpleMatchStatement();
    antlr4::tree::TerminalNode *LEFT_BRACE();
    MatchStatementBlockContext *matchStatementBlock();
    antlr4::tree::TerminalNode *RIGHT_BRACE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  OptionalOperandContext* optionalOperand(ContextT* ctx) {
    OptionalOperandContext *_localctx = _tracker.createInstance<OptionalOperandContext>(_ctx, getState());
    enterRule(_localctx, 218, GQLParser::RuleOptionalOperand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1811);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::MATCH: {
          enterOuterAlt(_localctx, 1);
          setState(1802);
          {
            auto childCtxHolder = ctx->EnterSimpleMatchStatement();
            simpleMatchStatement(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(1803);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_BRACE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_BRACE);
          setState(1804);
          {
            auto childCtxHolder = ctx->EnterMatchStatementBlock();
            matchStatementBlock(get_raw_pointer(childCtxHolder));
          }
          setState(1805);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_BRACE);
          break;
        }

        case GQLParser::LEFT_PAREN: {
          enterOuterAlt(_localctx, 3);
          setState(1807);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(1808);
          {
            auto childCtxHolder = ctx->EnterMatchStatementBlock();
            matchStatementBlock(get_raw_pointer(childCtxHolder));
          }
          setState(1809);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  MatchStatementBlockContext : public antlr4::ParserRuleContext {
  public:
    MatchStatementBlockContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<MatchStatementContext *> matchStatement();
    MatchStatementContext* matchStatement(size_t i);

   
  };

  template<typename ContextT>
  MatchStatementBlockContext* matchStatementBlock(ContextT* ctx) {
    MatchStatementBlockContext *_localctx = _tracker.createInstance<MatchStatementBlockContext>(_ctx, getState());
    enterRule(_localctx, 220, GQLParser::RuleMatchStatementBlock);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1814); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1813);
        {
          auto childCtxHolder = ctx->EnterMatchStatement();
          matchStatement(get_raw_pointer(childCtxHolder));
        }
        setState(1816); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == GQLParser::MATCH

      || _la == GQLParser::OPTIONAL);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CallQueryStatementContext : public antlr4::ParserRuleContext {
  public:
    CallQueryStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CallProcedureStatementContext *callProcedureStatement();

   
  };

  template<typename ContextT>
  CallQueryStatementContext* callQueryStatement(ContextT* ctx) {
    CallQueryStatementContext *_localctx = _tracker.createInstance<CallQueryStatementContext>(_ctx, getState());
    enterRule(_localctx, 222, GQLParser::RuleCallQueryStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1818);
      {
        auto childCtxHolder = ctx->EnterCallProcedureStatement();
        callProcedureStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FilterStatementContext : public antlr4::ParserRuleContext {
  public:
    FilterStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FILTER();
    WhereClauseContext *whereClause();
    SearchConditionContext *searchCondition();

   
  };

  template<typename ContextT>
  FilterStatementContext* filterStatement(ContextT* ctx) {
    FilterStatementContext *_localctx = _tracker.createInstance<FilterStatementContext>(_ctx, getState());
    enterRule(_localctx, 224, GQLParser::RuleFilterStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1820);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::FILTER) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::FILTER);
      setState(1823);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::WHERE: {
          setState(1821);
          {
            auto childCtxHolder = ctx->EnterWhereClause();
            whereClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BOOLEAN_LITERAL:
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::BYTE_STRING_LITERAL:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER:
        case GQLParser::ABS:
        case GQLParser::ACOS:
        case GQLParser::ALL_DIFFERENT:
        case GQLParser::ARRAY:
        case GQLParser::ASIN:
        case GQLParser::ATAN:
        case GQLParser::AVG:
        case GQLParser::BTRIM:
        case GQLParser::BYTE_LENGTH:
        case GQLParser::CARDINALITY:
        case GQLParser::CASE:
        case GQLParser::CAST:
        case GQLParser::CEIL:
        case GQLParser::CEILING:
        case GQLParser::CHAR_LENGTH:
        case GQLParser::CHARACTER_LENGTH:
        case GQLParser::COALESCE:
        case GQLParser::COLLECT_LIST:
        case GQLParser::COS:
        case GQLParser::COSH:
        case GQLParser::COT:
        case GQLParser::COUNT:
        case GQLParser::CURRENT_DATE:
        case GQLParser::CURRENT_TIME:
        case GQLParser::CURRENT_TIMESTAMP:
        case GQLParser::DATE:
        case GQLParser::DATETIME:
        case GQLParser::DEGREES:
        case GQLParser::DURATION:
        case GQLParser::DURATION_BETWEEN:
        case GQLParser::ELEMENT_ID:
        case GQLParser::EXISTS:
        case GQLParser::EXP:
        case GQLParser::FLOOR:
        case GQLParser::GROUP:
        case GQLParser::LEFT:
        case GQLParser::LET:
        case GQLParser::LIST:
        case GQLParser::LN:
        case GQLParser::LOCAL_DATETIME:
        case GQLParser::LOCAL_TIME:
        case GQLParser::LOCAL_TIMESTAMP:
        case GQLParser::LOG_KW:
        case GQLParser::LOG10:
        case GQLParser::LOWER:
        case GQLParser::LTRIM:
        case GQLParser::MAX:
        case GQLParser::MIN:
        case GQLParser::MOD:
        case GQLParser::NORMALIZE:
        case GQLParser::NOT:
        case GQLParser::NULL_KW:
        case GQLParser::NULLIF:
        case GQLParser::OCTET_LENGTH:
        case GQLParser::PATH:
        case GQLParser::PATH_LENGTH:
        case GQLParser::PERCENTILE_CONT:
        case GQLParser::PERCENTILE_DISC:
        case GQLParser::POWER:
        case GQLParser::PROPERTY_EXISTS:
        case GQLParser::RADIANS:
        case GQLParser::RECORD:
        case GQLParser::RIGHT:
        case GQLParser::RTRIM:
        case GQLParser::SAME:
        case GQLParser::SESSION_USER:
        case GQLParser::SIN:
        case GQLParser::SINH:
        case GQLParser::SIZE:
        case GQLParser::SQRT:
        case GQLParser::STDDEV_POP:
        case GQLParser::STDDEV_SAMP:
        case GQLParser::SUM:
        case GQLParser::TAN:
        case GQLParser::TANH:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::TRIM:
        case GQLParser::UPPER:
        case GQLParser::VALUE:
        case GQLParser::ZONED_DATETIME:
        case GQLParser::ZONED_TIME:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER:
        case GQLParser::GENERAL_PARAMETER_REFERENCE:
        case GQLParser::LEFT_BRACE:
        case GQLParser::LEFT_BRACKET:
        case GQLParser::LEFT_PAREN:
        case GQLParser::MINUS_SIGN:
        case GQLParser::PLUS_SIGN: {
          setState(1822);
          {
            auto childCtxHolder = ctx->EnterSearchCondition();
            searchCondition(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LetStatementContext : public antlr4::ParserRuleContext {
  public:
    LetStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LET();
    LetVariableDefinitionListContext *letVariableDefinitionList();

   
  };

  template<typename ContextT>
  LetStatementContext* letStatement(ContextT* ctx) {
    LetStatementContext *_localctx = _tracker.createInstance<LetStatementContext>(_ctx, getState());
    enterRule(_localctx, 226, GQLParser::RuleLetStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1825);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LET);
      setState(1826);
      {
        auto childCtxHolder = ctx->EnterLetVariableDefinitionList();
        letVariableDefinitionList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LetVariableDefinitionListContext : public antlr4::ParserRuleContext {
  public:
    LetVariableDefinitionListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<LetVariableDefinitionContext *> letVariableDefinition();
    LetVariableDefinitionContext* letVariableDefinition(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  LetVariableDefinitionListContext* letVariableDefinitionList(ContextT* ctx) {
    LetVariableDefinitionListContext *_localctx = _tracker.createInstance<LetVariableDefinitionListContext>(_ctx, getState());
    enterRule(_localctx, 228, GQLParser::RuleLetVariableDefinitionList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1828);
      {
        auto childCtxHolder = ctx->EnterLetVariableDefinition();
        letVariableDefinition(get_raw_pointer(childCtxHolder));
      }
      setState(1833);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(1829);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(1830);
        {
          auto childCtxHolder = ctx->EnterLetVariableDefinition();
          letVariableDefinition(get_raw_pointer(childCtxHolder));
        }
        setState(1835);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LetVariableDefinitionContext : public antlr4::ParserRuleContext {
  public:
    LetVariableDefinitionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueVariableDefinitionContext *valueVariableDefinition();
    BindingVariableContext *bindingVariable();
    antlr4::tree::TerminalNode *EQUALS_OPERATOR();
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  LetVariableDefinitionContext* letVariableDefinition(ContextT* ctx) {
    LetVariableDefinitionContext *_localctx = _tracker.createInstance<LetVariableDefinitionContext>(_ctx, getState());
    enterRule(_localctx, 230, GQLParser::RuleLetVariableDefinition);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1841);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::VALUE: {
          enterOuterAlt(_localctx, 1);
          setState(1836);
          {
            auto childCtxHolder = ctx->EnterValueVariableDefinition();
            valueVariableDefinition(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 2);
          setState(1837);
          {
            auto childCtxHolder = ctx->EnterBindingVariable();
            bindingVariable(get_raw_pointer(childCtxHolder));
          }
          setState(1838);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::EQUALS_OPERATOR);
          setState(1839);
          {
            auto childCtxHolder = ctx->EnterValueExpression();
            valueExpression(0, get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ForStatementContext : public antlr4::ParserRuleContext {
  public:
    ForStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FOR();
    ForItemContext *forItem();
    ForOrdinalityOrOffsetContext *forOrdinalityOrOffset();

   
  };

  template<typename ContextT>
  ForStatementContext* forStatement(ContextT* ctx) {
    ForStatementContext *_localctx = _tracker.createInstance<ForStatementContext>(_ctx, getState());
    enterRule(_localctx, 232, GQLParser::RuleForStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1843);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::FOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::FOR);
      setState(1844);
      {
        auto childCtxHolder = ctx->EnterForItem();
        forItem(get_raw_pointer(childCtxHolder));
      }
      setState(1846);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::WITH) {
        setState(1845);
        {
          auto childCtxHolder = ctx->EnterForOrdinalityOrOffset();
          forOrdinalityOrOffset(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ForItemContext : public antlr4::ParserRuleContext {
  public:
    ForItemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ForItemAliasContext *forItemAlias();
    ForItemSourceContext *forItemSource();

   
  };

  template<typename ContextT>
  ForItemContext* forItem(ContextT* ctx) {
    ForItemContext *_localctx = _tracker.createInstance<ForItemContext>(_ctx, getState());
    enterRule(_localctx, 234, GQLParser::RuleForItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1848);
      {
        auto childCtxHolder = ctx->EnterForItemAlias();
        forItemAlias(get_raw_pointer(childCtxHolder));
      }
      setState(1849);
      {
        auto childCtxHolder = ctx->EnterForItemSource();
        forItemSource(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ForItemAliasContext : public antlr4::ParserRuleContext {
  public:
    ForItemAliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BindingVariableContext *bindingVariable();
    antlr4::tree::TerminalNode *IN();

   
  };

  template<typename ContextT>
  ForItemAliasContext* forItemAlias(ContextT* ctx) {
    ForItemAliasContext *_localctx = _tracker.createInstance<ForItemAliasContext>(_ctx, getState());
    enterRule(_localctx, 236, GQLParser::RuleForItemAlias);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1851);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
      setState(1852);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ForItemSourceContext : public antlr4::ParserRuleContext {
  public:
    ForItemSourceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  ForItemSourceContext* forItemSource(ContextT* ctx) {
    ForItemSourceContext *_localctx = _tracker.createInstance<ForItemSourceContext>(_ctx, getState());
    enterRule(_localctx, 238, GQLParser::RuleForItemSource);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1854);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ForOrdinalityOrOffsetContext : public antlr4::ParserRuleContext {
  public:
    ForOrdinalityOrOffsetContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WITH();
    BindingVariableContext *bindingVariable();
    antlr4::tree::TerminalNode *ORDINALITY();
    antlr4::tree::TerminalNode *OFFSET();

   
  };

  template<typename ContextT>
  ForOrdinalityOrOffsetContext* forOrdinalityOrOffset(ContextT* ctx) {
    ForOrdinalityOrOffsetContext *_localctx = _tracker.createInstance<ForOrdinalityOrOffsetContext>(_ctx, getState());
    enterRule(_localctx, 240, GQLParser::RuleForOrdinalityOrOffset);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1856);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::WITH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::WITH);
      setState(1857);
      _la = _input->LA(1);
      if (!(_la == GQLParser::OFFSET || _la == GQLParser::ORDINALITY)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(1858);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  OrderByAndPageStatementContext : public antlr4::ParserRuleContext {
  public:
    OrderByAndPageStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    OrderByClauseContext *orderByClause();
    OffsetClauseContext *offsetClause();
    LimitClauseContext *limitClause();

   
  };

  template<typename ContextT>
  OrderByAndPageStatementContext* orderByAndPageStatement(ContextT* ctx) {
    OrderByAndPageStatementContext *_localctx = _tracker.createInstance<OrderByAndPageStatementContext>(_ctx, getState());
    enterRule(_localctx, 242, GQLParser::RuleOrderByAndPageStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1872);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ORDER: {
          enterOuterAlt(_localctx, 1);
          setState(1860);
          {
            auto childCtxHolder = ctx->EnterOrderByClause();
            orderByClause(get_raw_pointer(childCtxHolder));
          }
          setState(1862);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx)) {
          case 1: {
            setState(1861);
            {
              auto childCtxHolder = ctx->EnterOffsetClause();
              offsetClause(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          setState(1865);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx)) {
          case 1: {
            setState(1864);
            {
              auto childCtxHolder = ctx->EnterLimitClause();
              limitClause(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::OFFSET:
        case GQLParser::SKIP_RESERVED_WORD: {
          enterOuterAlt(_localctx, 2);
          setState(1867);
          {
            auto childCtxHolder = ctx->EnterOffsetClause();
            offsetClause(get_raw_pointer(childCtxHolder));
          }
          setState(1869);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
          case 1: {
            setState(1868);
            {
              auto childCtxHolder = ctx->EnterLimitClause();
              limitClause(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::LIMIT: {
          enterOuterAlt(_localctx, 3);
          setState(1871);
          {
            auto childCtxHolder = ctx->EnterLimitClause();
            limitClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PrimitiveResultStatementContext : public antlr4::ParserRuleContext {
  public:
    PrimitiveResultStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ReturnStatementContext *returnStatement();
    OrderByAndPageStatementContext *orderByAndPageStatement();
    antlr4::tree::TerminalNode *FINISH();

   
  };

  template<typename ContextT>
  PrimitiveResultStatementContext* primitiveResultStatement(ContextT* ctx) {
    PrimitiveResultStatementContext *_localctx = _tracker.createInstance<PrimitiveResultStatementContext>(_ctx, getState());
    enterRule(_localctx, 244, GQLParser::RulePrimitiveResultStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1879);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::RETURN: {
          enterOuterAlt(_localctx, 1);
          setState(1874);
          {
            auto childCtxHolder = ctx->EnterReturnStatement();
            returnStatement(get_raw_pointer(childCtxHolder));
          }
          setState(1876);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
          case 1: {
            setState(1875);
            {
              auto childCtxHolder = ctx->EnterOrderByAndPageStatement();
              orderByAndPageStatement(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::FINISH: {
          enterOuterAlt(_localctx, 2);
          setState(1878);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::FINISH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::FINISH);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ReturnStatementContext : public antlr4::ParserRuleContext {
  public:
    ReturnStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RETURN();
    ReturnStatementBodyContext *returnStatementBody();

   
  };

  template<typename ContextT>
  ReturnStatementContext* returnStatement(ContextT* ctx) {
    ReturnStatementContext *_localctx = _tracker.createInstance<ReturnStatementContext>(_ctx, getState());
    enterRule(_localctx, 246, GQLParser::RuleReturnStatement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1881);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RETURN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RETURN);
      setState(1882);
      {
        auto childCtxHolder = ctx->EnterReturnStatementBody();
        returnStatementBody(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ReturnStatementBodyContext : public antlr4::ParserRuleContext {
  public:
    ReturnStatementBodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ASTERISK();
    ReturnItemListContext *returnItemList();
    SetQuantifierContext *setQuantifier();
    GroupByClauseContext *groupByClause();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *BINDINGS();

   
  };

  template<typename ContextT>
  ReturnStatementBodyContext* returnStatementBody(ContextT* ctx) {
    ReturnStatementBodyContext *_localctx = _tracker.createInstance<ReturnStatementBodyContext>(_ctx, getState());
    enterRule(_localctx, 248, GQLParser::RuleReturnStatementBody);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1896);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1885);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::ALL

        || _la == GQLParser::DISTINCT) {
          setState(1884);
          {
            auto childCtxHolder = ctx->EnterSetQuantifier();
            setQuantifier(get_raw_pointer(childCtxHolder));
          }
        }
        setState(1889);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case GQLParser::ASTERISK: {
            setState(1887);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::ASTERISK) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::ASTERISK);
            break;
          }

          case GQLParser::BOOLEAN_LITERAL:
          case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
          case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
          case GQLParser::BYTE_STRING_LITERAL:
          case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX:
          case GQLParser::UNSIGNED_DECIMAL_INTEGER:
          case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
          case GQLParser::UNSIGNED_OCTAL_INTEGER:
          case GQLParser::UNSIGNED_BINARY_INTEGER:
          case GQLParser::ABS:
          case GQLParser::ACOS:
          case GQLParser::ALL_DIFFERENT:
          case GQLParser::ARRAY:
          case GQLParser::ASIN:
          case GQLParser::ATAN:
          case GQLParser::AVG:
          case GQLParser::BTRIM:
          case GQLParser::BYTE_LENGTH:
          case GQLParser::CARDINALITY:
          case GQLParser::CASE:
          case GQLParser::CAST:
          case GQLParser::CEIL:
          case GQLParser::CEILING:
          case GQLParser::CHAR_LENGTH:
          case GQLParser::CHARACTER_LENGTH:
          case GQLParser::COALESCE:
          case GQLParser::COLLECT_LIST:
          case GQLParser::COS:
          case GQLParser::COSH:
          case GQLParser::COT:
          case GQLParser::COUNT:
          case GQLParser::CURRENT_DATE:
          case GQLParser::CURRENT_TIME:
          case GQLParser::CURRENT_TIMESTAMP:
          case GQLParser::DATE:
          case GQLParser::DATETIME:
          case GQLParser::DEGREES:
          case GQLParser::DURATION:
          case GQLParser::DURATION_BETWEEN:
          case GQLParser::ELEMENT_ID:
          case GQLParser::EXISTS:
          case GQLParser::EXP:
          case GQLParser::FLOOR:
          case GQLParser::GROUP:
          case GQLParser::LEFT:
          case GQLParser::LET:
          case GQLParser::LIST:
          case GQLParser::LN:
          case GQLParser::LOCAL_DATETIME:
          case GQLParser::LOCAL_TIME:
          case GQLParser::LOCAL_TIMESTAMP:
          case GQLParser::LOG_KW:
          case GQLParser::LOG10:
          case GQLParser::LOWER:
          case GQLParser::LTRIM:
          case GQLParser::MAX:
          case GQLParser::MIN:
          case GQLParser::MOD:
          case GQLParser::NORMALIZE:
          case GQLParser::NOT:
          case GQLParser::NULL_KW:
          case GQLParser::NULLIF:
          case GQLParser::OCTET_LENGTH:
          case GQLParser::PATH:
          case GQLParser::PATH_LENGTH:
          case GQLParser::PERCENTILE_CONT:
          case GQLParser::PERCENTILE_DISC:
          case GQLParser::POWER:
          case GQLParser::PROPERTY_EXISTS:
          case GQLParser::RADIANS:
          case GQLParser::RECORD:
          case GQLParser::RIGHT:
          case GQLParser::RTRIM:
          case GQLParser::SAME:
          case GQLParser::SESSION_USER:
          case GQLParser::SIN:
          case GQLParser::SINH:
          case GQLParser::SIZE:
          case GQLParser::SQRT:
          case GQLParser::STDDEV_POP:
          case GQLParser::STDDEV_SAMP:
          case GQLParser::SUM:
          case GQLParser::TAN:
          case GQLParser::TANH:
          case GQLParser::TIME:
          case GQLParser::TIMESTAMP:
          case GQLParser::TRIM:
          case GQLParser::UPPER:
          case GQLParser::VALUE:
          case GQLParser::ZONED_DATETIME:
          case GQLParser::ZONED_TIME:
          case GQLParser::ACYCLIC:
          case GQLParser::BINDING:
          case GQLParser::BINDINGS:
          case GQLParser::CONNECTING:
          case GQLParser::DESTINATION:
          case GQLParser::DIFFERENT:
          case GQLParser::DIRECTED:
          case GQLParser::EDGE:
          case GQLParser::EDGES:
          case GQLParser::ELEMENT:
          case GQLParser::ELEMENTS:
          case GQLParser::FIRST:
          case GQLParser::GRAPH:
          case GQLParser::GROUPS:
          case GQLParser::KEEP:
          case GQLParser::LABEL:
          case GQLParser::LABELED:
          case GQLParser::LABELS:
          case GQLParser::LAST:
          case GQLParser::NFC:
          case GQLParser::NFD:
          case GQLParser::NFKC:
          case GQLParser::NFKD:
          case GQLParser::NO:
          case GQLParser::NODE:
          case GQLParser::NORMALIZED:
          case GQLParser::ONLY:
          case GQLParser::ORDINALITY:
          case GQLParser::PROPERTY:
          case GQLParser::READ:
          case GQLParser::RELATIONSHIP:
          case GQLParser::RELATIONSHIPS:
          case GQLParser::REPEATABLE:
          case GQLParser::SHORTEST:
          case GQLParser::SIMPLE:
          case GQLParser::SOURCE:
          case GQLParser::TABLE:
          case GQLParser::TEMP:
          case GQLParser::TO:
          case GQLParser::TRAIL:
          case GQLParser::TRANSACTION:
          case GQLParser::UNDIRECTED:
          case GQLParser::VERTEX:
          case GQLParser::WALK:
          case GQLParser::WITHOUT:
          case GQLParser::WRITE:
          case GQLParser::ZONE:
          case GQLParser::REGULAR_IDENTIFIER:
          case GQLParser::GENERAL_PARAMETER_REFERENCE:
          case GQLParser::LEFT_BRACE:
          case GQLParser::LEFT_BRACKET:
          case GQLParser::LEFT_PAREN:
          case GQLParser::MINUS_SIGN:
          case GQLParser::PLUS_SIGN: {
            setState(1888);
            {
              auto childCtxHolder = ctx->EnterReturnItemList();
              returnItemList(get_raw_pointer(childCtxHolder));
            }
            break;
          }

        default:
          throw antlr4::NoViableAltException(this);
        }
        setState(1892);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx)) {
        case 1: {
          setState(1891);
          {
            auto childCtxHolder = ctx->EnterGroupByClause();
            groupByClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1894);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NO) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NO);
        setState(1895);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::BINDINGS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::BINDINGS);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ReturnItemListContext : public antlr4::ParserRuleContext {
  public:
    ReturnItemListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ReturnItemContext *> returnItem();
    ReturnItemContext* returnItem(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  ReturnItemListContext* returnItemList(ContextT* ctx) {
    ReturnItemListContext *_localctx = _tracker.createInstance<ReturnItemListContext>(_ctx, getState());
    enterRule(_localctx, 250, GQLParser::RuleReturnItemList);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(1898);
      {
        auto childCtxHolder = ctx->EnterReturnItem();
        returnItem(get_raw_pointer(childCtxHolder));
      }
      setState(1903);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1899);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COMMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COMMA);
          setState(1900);
          {
            auto childCtxHolder = ctx->EnterReturnItem();
            returnItem(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(1905);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ReturnItemContext : public antlr4::ParserRuleContext {
  public:
    ReturnItemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    AggregatingValueExpressionContext *aggregatingValueExpression();
    ReturnItemAliasContext *returnItemAlias();

   
  };

  template<typename ContextT>
  ReturnItemContext* returnItem(ContextT* ctx) {
    ReturnItemContext *_localctx = _tracker.createInstance<ReturnItemContext>(_ctx, getState());
    enterRule(_localctx, 252, GQLParser::RuleReturnItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1906);
      {
        auto childCtxHolder = ctx->EnterAggregatingValueExpression();
        aggregatingValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(1908);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {
      case 1: {
        setState(1907);
        {
          auto childCtxHolder = ctx->EnterReturnItemAlias();
          returnItemAlias(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ReturnItemAliasContext : public antlr4::ParserRuleContext {
  public:
    ReturnItemAliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AS();
    IdentifierContext *identifier();

   
  };

  template<typename ContextT>
  ReturnItemAliasContext* returnItemAlias(ContextT* ctx) {
    ReturnItemAliasContext *_localctx = _tracker.createInstance<ReturnItemAliasContext>(_ctx, getState());
    enterRule(_localctx, 254, GQLParser::RuleReturnItemAlias);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1910);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::AS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::AS);
      setState(1911);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SelectStatementContext : public antlr4::ParserRuleContext {
  public:
    SelectStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SELECT();
    antlr4::tree::TerminalNode *ASTERISK();
    SelectItemListContext *selectItemList();
    SetQuantifierContext *setQuantifier();
    SelectStatementBodyContext *selectStatementBody();
    WhereClauseContext *whereClause();
    GroupByClauseContext *groupByClause();
    HavingClauseContext *havingClause();
    OrderByClauseContext *orderByClause();
    OffsetClauseContext *offsetClause();
    LimitClauseContext *limitClause();

   
  };

  template<typename ContextT>
  SelectStatementContext* selectStatement(ContextT* ctx) {
    SelectStatementContext *_localctx = _tracker.createInstance<SelectStatementContext>(_ctx, getState());
    enterRule(_localctx, 256, GQLParser::RuleSelectStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1913);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SELECT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SELECT);
      setState(1915);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ALL

      || _la == GQLParser::DISTINCT) {
        setState(1914);
        {
          auto childCtxHolder = ctx->EnterSetQuantifier();
          setQuantifier(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1919);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ASTERISK: {
          setState(1917);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ASTERISK) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ASTERISK);
          break;
        }

        case GQLParser::BOOLEAN_LITERAL:
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::BYTE_STRING_LITERAL:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER:
        case GQLParser::ABS:
        case GQLParser::ACOS:
        case GQLParser::ALL_DIFFERENT:
        case GQLParser::ARRAY:
        case GQLParser::ASIN:
        case GQLParser::ATAN:
        case GQLParser::AVG:
        case GQLParser::BTRIM:
        case GQLParser::BYTE_LENGTH:
        case GQLParser::CARDINALITY:
        case GQLParser::CASE:
        case GQLParser::CAST:
        case GQLParser::CEIL:
        case GQLParser::CEILING:
        case GQLParser::CHAR_LENGTH:
        case GQLParser::CHARACTER_LENGTH:
        case GQLParser::COALESCE:
        case GQLParser::COLLECT_LIST:
        case GQLParser::COS:
        case GQLParser::COSH:
        case GQLParser::COT:
        case GQLParser::COUNT:
        case GQLParser::CURRENT_DATE:
        case GQLParser::CURRENT_TIME:
        case GQLParser::CURRENT_TIMESTAMP:
        case GQLParser::DATE:
        case GQLParser::DATETIME:
        case GQLParser::DEGREES:
        case GQLParser::DURATION:
        case GQLParser::DURATION_BETWEEN:
        case GQLParser::ELEMENT_ID:
        case GQLParser::EXISTS:
        case GQLParser::EXP:
        case GQLParser::FLOOR:
        case GQLParser::GROUP:
        case GQLParser::LEFT:
        case GQLParser::LET:
        case GQLParser::LIST:
        case GQLParser::LN:
        case GQLParser::LOCAL_DATETIME:
        case GQLParser::LOCAL_TIME:
        case GQLParser::LOCAL_TIMESTAMP:
        case GQLParser::LOG_KW:
        case GQLParser::LOG10:
        case GQLParser::LOWER:
        case GQLParser::LTRIM:
        case GQLParser::MAX:
        case GQLParser::MIN:
        case GQLParser::MOD:
        case GQLParser::NORMALIZE:
        case GQLParser::NOT:
        case GQLParser::NULL_KW:
        case GQLParser::NULLIF:
        case GQLParser::OCTET_LENGTH:
        case GQLParser::PATH:
        case GQLParser::PATH_LENGTH:
        case GQLParser::PERCENTILE_CONT:
        case GQLParser::PERCENTILE_DISC:
        case GQLParser::POWER:
        case GQLParser::PROPERTY_EXISTS:
        case GQLParser::RADIANS:
        case GQLParser::RECORD:
        case GQLParser::RIGHT:
        case GQLParser::RTRIM:
        case GQLParser::SAME:
        case GQLParser::SESSION_USER:
        case GQLParser::SIN:
        case GQLParser::SINH:
        case GQLParser::SIZE:
        case GQLParser::SQRT:
        case GQLParser::STDDEV_POP:
        case GQLParser::STDDEV_SAMP:
        case GQLParser::SUM:
        case GQLParser::TAN:
        case GQLParser::TANH:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::TRIM:
        case GQLParser::UPPER:
        case GQLParser::VALUE:
        case GQLParser::ZONED_DATETIME:
        case GQLParser::ZONED_TIME:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER:
        case GQLParser::GENERAL_PARAMETER_REFERENCE:
        case GQLParser::LEFT_BRACE:
        case GQLParser::LEFT_BRACKET:
        case GQLParser::LEFT_PAREN:
        case GQLParser::MINUS_SIGN:
        case GQLParser::PLUS_SIGN: {
          setState(1918);
          {
            auto childCtxHolder = ctx->EnterSelectItemList();
            selectItemList(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
      setState(1940);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx)) {
      case 1: {
        setState(1921);
        {
          auto childCtxHolder = ctx->EnterSelectStatementBody();
          selectStatementBody(get_raw_pointer(childCtxHolder));
        }
        setState(1923);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 125, _ctx)) {
        case 1: {
          setState(1922);
          {
            auto childCtxHolder = ctx->EnterWhereClause();
            whereClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        setState(1926);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
        case 1: {
          setState(1925);
          {
            auto childCtxHolder = ctx->EnterGroupByClause();
            groupByClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        setState(1929);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx)) {
        case 1: {
          setState(1928);
          {
            auto childCtxHolder = ctx->EnterHavingClause();
            havingClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        setState(1932);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx)) {
        case 1: {
          setState(1931);
          {
            auto childCtxHolder = ctx->EnterOrderByClause();
            orderByClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        setState(1935);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx)) {
        case 1: {
          setState(1934);
          {
            auto childCtxHolder = ctx->EnterOffsetClause();
            offsetClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        setState(1938);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx)) {
        case 1: {
          setState(1937);
          {
            auto childCtxHolder = ctx->EnterLimitClause();
            limitClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SelectItemListContext : public antlr4::ParserRuleContext {
  public:
    SelectItemListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<SelectItemContext *> selectItem();
    SelectItemContext* selectItem(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  SelectItemListContext* selectItemList(ContextT* ctx) {
    SelectItemListContext *_localctx = _tracker.createInstance<SelectItemListContext>(_ctx, getState());
    enterRule(_localctx, 258, GQLParser::RuleSelectItemList);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(1942);
      {
        auto childCtxHolder = ctx->EnterSelectItem();
        selectItem(get_raw_pointer(childCtxHolder));
      }
      setState(1947);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1943);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COMMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COMMA);
          setState(1944);
          {
            auto childCtxHolder = ctx->EnterSelectItem();
            selectItem(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(1949);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SelectItemContext : public antlr4::ParserRuleContext {
  public:
    SelectItemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    AggregatingValueExpressionContext *aggregatingValueExpression();
    SelectItemAliasContext *selectItemAlias();

   
  };

  template<typename ContextT>
  SelectItemContext* selectItem(ContextT* ctx) {
    SelectItemContext *_localctx = _tracker.createInstance<SelectItemContext>(_ctx, getState());
    enterRule(_localctx, 260, GQLParser::RuleSelectItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1950);
      {
        auto childCtxHolder = ctx->EnterAggregatingValueExpression();
        aggregatingValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(1952);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx)) {
      case 1: {
        setState(1951);
        {
          auto childCtxHolder = ctx->EnterSelectItemAlias();
          selectItemAlias(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SelectItemAliasContext : public antlr4::ParserRuleContext {
  public:
    SelectItemAliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AS();
    IdentifierContext *identifier();

   
  };

  template<typename ContextT>
  SelectItemAliasContext* selectItemAlias(ContextT* ctx) {
    SelectItemAliasContext *_localctx = _tracker.createInstance<SelectItemAliasContext>(_ctx, getState());
    enterRule(_localctx, 262, GQLParser::RuleSelectItemAlias);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1954);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::AS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::AS);
      setState(1955);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  HavingClauseContext : public antlr4::ParserRuleContext {
  public:
    HavingClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *HAVING();
    SearchConditionContext *searchCondition();

   
  };

  template<typename ContextT>
  HavingClauseContext* havingClause(ContextT* ctx) {
    HavingClauseContext *_localctx = _tracker.createInstance<HavingClauseContext>(_ctx, getState());
    enterRule(_localctx, 264, GQLParser::RuleHavingClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1957);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::HAVING) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::HAVING);
      setState(1958);
      {
        auto childCtxHolder = ctx->EnterSearchCondition();
        searchCondition(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SelectStatementBodyContext : public antlr4::ParserRuleContext {
  public:
    SelectStatementBodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FROM();
    SelectGraphMatchListContext *selectGraphMatchList();
    SelectQuerySpecificationContext *selectQuerySpecification();

   
  };

  template<typename ContextT>
  SelectStatementBodyContext* selectStatementBody(ContextT* ctx) {
    SelectStatementBodyContext *_localctx = _tracker.createInstance<SelectStatementBodyContext>(_ctx, getState());
    enterRule(_localctx, 266, GQLParser::RuleSelectStatementBody);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1960);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::FROM) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::FROM);
      setState(1963);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx)) {
      case 1: {
        setState(1961);
        {
          auto childCtxHolder = ctx->EnterSelectGraphMatchList();
          selectGraphMatchList(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        setState(1962);
        {
          auto childCtxHolder = ctx->EnterSelectQuerySpecification();
          selectQuerySpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SelectGraphMatchListContext : public antlr4::ParserRuleContext {
  public:
    SelectGraphMatchListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<SelectGraphMatchContext *> selectGraphMatch();
    SelectGraphMatchContext* selectGraphMatch(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  SelectGraphMatchListContext* selectGraphMatchList(ContextT* ctx) {
    SelectGraphMatchListContext *_localctx = _tracker.createInstance<SelectGraphMatchListContext>(_ctx, getState());
    enterRule(_localctx, 268, GQLParser::RuleSelectGraphMatchList);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(1965);
      {
        auto childCtxHolder = ctx->EnterSelectGraphMatch();
        selectGraphMatch(get_raw_pointer(childCtxHolder));
      }
      setState(1970);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 135, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(1966);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COMMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COMMA);
          setState(1967);
          {
            auto childCtxHolder = ctx->EnterSelectGraphMatch();
            selectGraphMatch(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(1972);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 135, _ctx);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SelectGraphMatchContext : public antlr4::ParserRuleContext {
  public:
    SelectGraphMatchContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    GraphExpressionContext *graphExpression();
    MatchStatementContext *matchStatement();

   
  };

  template<typename ContextT>
  SelectGraphMatchContext* selectGraphMatch(ContextT* ctx) {
    SelectGraphMatchContext *_localctx = _tracker.createInstance<SelectGraphMatchContext>(_ctx, getState());
    enterRule(_localctx, 270, GQLParser::RuleSelectGraphMatch);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1973);
      {
        auto childCtxHolder = ctx->EnterGraphExpression();
        graphExpression(get_raw_pointer(childCtxHolder));
      }
      setState(1974);
      {
        auto childCtxHolder = ctx->EnterMatchStatement();
        matchStatement(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SelectQuerySpecificationContext : public antlr4::ParserRuleContext {
  public:
    SelectQuerySpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NestedQuerySpecificationContext *nestedQuerySpecification();
    GraphExpressionContext *graphExpression();

   
  };

  template<typename ContextT>
  SelectQuerySpecificationContext* selectQuerySpecification(ContextT* ctx) {
    SelectQuerySpecificationContext *_localctx = _tracker.createInstance<SelectQuerySpecificationContext>(_ctx, getState());
    enterRule(_localctx, 272, GQLParser::RuleSelectQuerySpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1980);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1976);
        {
          auto childCtxHolder = ctx->EnterNestedQuerySpecification();
          nestedQuerySpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1977);
        {
          auto childCtxHolder = ctx->EnterGraphExpression();
          graphExpression(get_raw_pointer(childCtxHolder));
        }
        setState(1978);
        {
          auto childCtxHolder = ctx->EnterNestedQuerySpecification();
          nestedQuerySpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CallProcedureStatementContext : public antlr4::ParserRuleContext {
  public:
    CallProcedureStatementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CALL();
    ProcedureCallContext *procedureCall();
    antlr4::tree::TerminalNode *OPTIONAL();

   
  };

  template<typename ContextT>
  CallProcedureStatementContext* callProcedureStatement(ContextT* ctx) {
    CallProcedureStatementContext *_localctx = _tracker.createInstance<CallProcedureStatementContext>(_ctx, getState());
    enterRule(_localctx, 274, GQLParser::RuleCallProcedureStatement);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1983);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::OPTIONAL) {
        setState(1982);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::OPTIONAL) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::OPTIONAL);
      }
      setState(1985);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CALL) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CALL);
      setState(1986);
      {
        auto childCtxHolder = ctx->EnterProcedureCall();
        procedureCall(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ProcedureCallContext : public antlr4::ParserRuleContext {
  public:
    ProcedureCallContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    InlineProcedureCallContext *inlineProcedureCall();
    NamedProcedureCallContext *namedProcedureCall();

   
  };

  template<typename ContextT>
  ProcedureCallContext* procedureCall(ContextT* ctx) {
    ProcedureCallContext *_localctx = _tracker.createInstance<ProcedureCallContext>(_ctx, getState());
    enterRule(_localctx, 276, GQLParser::RuleProcedureCall);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(1990);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LEFT_BRACE:
        case GQLParser::LEFT_PAREN: {
          enterOuterAlt(_localctx, 1);
          setState(1988);
          {
            auto childCtxHolder = ctx->EnterInlineProcedureCall();
            inlineProcedureCall(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::CURRENT_SCHEMA:
        case GQLParser::HOME_SCHEMA:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER:
        case GQLParser::SUBSTITUTED_PARAMETER_REFERENCE:
        case GQLParser::DOUBLE_PERIOD:
        case GQLParser::PERIOD:
        case GQLParser::SOLIDUS: {
          enterOuterAlt(_localctx, 2);
          setState(1989);
          {
            auto childCtxHolder = ctx->EnterNamedProcedureCall();
            namedProcedureCall(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  InlineProcedureCallContext : public antlr4::ParserRuleContext {
  public:
    InlineProcedureCallContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NestedProcedureSpecificationContext *nestedProcedureSpecification();
    VariableScopeClauseContext *variableScopeClause();

   
  };

  template<typename ContextT>
  InlineProcedureCallContext* inlineProcedureCall(ContextT* ctx) {
    InlineProcedureCallContext *_localctx = _tracker.createInstance<InlineProcedureCallContext>(_ctx, getState());
    enterRule(_localctx, 278, GQLParser::RuleInlineProcedureCall);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1993);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::LEFT_PAREN) {
        setState(1992);
        {
          auto childCtxHolder = ctx->EnterVariableScopeClause();
          variableScopeClause(get_raw_pointer(childCtxHolder));
        }
      }
      setState(1995);
      {
        auto childCtxHolder = ctx->EnterNestedProcedureSpecification();
        nestedProcedureSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  VariableScopeClauseContext : public antlr4::ParserRuleContext {
  public:
    VariableScopeClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    BindingVariableReferenceListContext *bindingVariableReferenceList();

   
  };

  template<typename ContextT>
  VariableScopeClauseContext* variableScopeClause(ContextT* ctx) {
    VariableScopeClauseContext *_localctx = _tracker.createInstance<VariableScopeClauseContext>(_ctx, getState());
    enterRule(_localctx, 280, GQLParser::RuleVariableScopeClause);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(1997);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(1999);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0)) {
        setState(1998);
        {
          auto childCtxHolder = ctx->EnterBindingVariableReferenceList();
          bindingVariableReferenceList(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2001);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BindingVariableReferenceListContext : public antlr4::ParserRuleContext {
  public:
    BindingVariableReferenceListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<BindingVariableReferenceContext *> bindingVariableReference();
    BindingVariableReferenceContext* bindingVariableReference(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  BindingVariableReferenceListContext* bindingVariableReferenceList(ContextT* ctx) {
    BindingVariableReferenceListContext *_localctx = _tracker.createInstance<BindingVariableReferenceListContext>(_ctx, getState());
    enterRule(_localctx, 282, GQLParser::RuleBindingVariableReferenceList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2003);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(2008);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(2004);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(2005);
        {
          auto childCtxHolder = ctx->EnterBindingVariableReference();
          bindingVariableReference(get_raw_pointer(childCtxHolder));
        }
        setState(2010);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NamedProcedureCallContext : public antlr4::ParserRuleContext {
  public:
    NamedProcedureCallContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ProcedureReferenceContext *procedureReference();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    ProcedureArgumentListContext *procedureArgumentList();
    YieldClauseContext *yieldClause();

   
  };

  template<typename ContextT>
  NamedProcedureCallContext* namedProcedureCall(ContextT* ctx) {
    NamedProcedureCallContext *_localctx = _tracker.createInstance<NamedProcedureCallContext>(_ctx, getState());
    enterRule(_localctx, 284, GQLParser::RuleNamedProcedureCall);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2011);
      {
        auto childCtxHolder = ctx->EnterProcedureReference();
        procedureReference(get_raw_pointer(childCtxHolder));
      }
      setState(2012);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(2014);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8762849302180528028) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 309341980913) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 129)) & -8011702113698201677) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & 26393111092643) != 0) || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 1686650837008383) != 0) || ((((_la - 369) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 369)) & 151) != 0)) {
        setState(2013);
        {
          auto childCtxHolder = ctx->EnterProcedureArgumentList();
          procedureArgumentList(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2016);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
      setState(2018);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::YIELD) {
        setState(2017);
        {
          auto childCtxHolder = ctx->EnterYieldClause();
          yieldClause(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ProcedureArgumentListContext : public antlr4::ParserRuleContext {
  public:
    ProcedureArgumentListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ProcedureArgumentContext *> procedureArgument();
    ProcedureArgumentContext* procedureArgument(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  ProcedureArgumentListContext* procedureArgumentList(ContextT* ctx) {
    ProcedureArgumentListContext *_localctx = _tracker.createInstance<ProcedureArgumentListContext>(_ctx, getState());
    enterRule(_localctx, 286, GQLParser::RuleProcedureArgumentList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2020);
      {
        auto childCtxHolder = ctx->EnterProcedureArgument();
        procedureArgument(get_raw_pointer(childCtxHolder));
      }
      setState(2025);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(2021);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(2022);
        {
          auto childCtxHolder = ctx->EnterProcedureArgument();
          procedureArgument(get_raw_pointer(childCtxHolder));
        }
        setState(2027);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ProcedureArgumentContext : public antlr4::ParserRuleContext {
  public:
    ProcedureArgumentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  ProcedureArgumentContext* procedureArgument(ContextT* ctx) {
    ProcedureArgumentContext *_localctx = _tracker.createInstance<ProcedureArgumentContext>(_ctx, getState());
    enterRule(_localctx, 288, GQLParser::RuleProcedureArgument);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2028);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  AtSchemaClauseContext : public antlr4::ParserRuleContext {
  public:
    AtSchemaClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AT();
    SchemaReferenceContext *schemaReference();

   
  };

  template<typename ContextT>
  AtSchemaClauseContext* atSchemaClause(ContextT* ctx) {
    AtSchemaClauseContext *_localctx = _tracker.createInstance<AtSchemaClauseContext>(_ctx, getState());
    enterRule(_localctx, 290, GQLParser::RuleAtSchemaClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2030);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::AT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::AT);
      setState(2031);
      {
        auto childCtxHolder = ctx->EnterSchemaReference();
        schemaReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  UseGraphClauseContext : public antlr4::ParserRuleContext {
  public:
    UseGraphClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *USE();
    GraphExpressionContext *graphExpression();

   
  };

  template<typename ContextT>
  UseGraphClauseContext* useGraphClause(ContextT* ctx) {
    UseGraphClauseContext *_localctx = _tracker.createInstance<UseGraphClauseContext>(_ctx, getState());
    enterRule(_localctx, 292, GQLParser::RuleUseGraphClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2033);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::USE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::USE);
      setState(2034);
      {
        auto childCtxHolder = ctx->EnterGraphExpression();
        graphExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphPatternBindingTableContext : public antlr4::ParserRuleContext {
  public:
    GraphPatternBindingTableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    GraphPatternContext *graphPattern();
    GraphPatternYieldClauseContext *graphPatternYieldClause();

   
  };

  template<typename ContextT>
  GraphPatternBindingTableContext* graphPatternBindingTable(ContextT* ctx) {
    GraphPatternBindingTableContext *_localctx = _tracker.createInstance<GraphPatternBindingTableContext>(_ctx, getState());
    enterRule(_localctx, 294, GQLParser::RuleGraphPatternBindingTable);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2036);
      {
        auto childCtxHolder = ctx->EnterGraphPattern();
        graphPattern(get_raw_pointer(childCtxHolder));
      }
      setState(2038);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx)) {
      case 1: {
        setState(2037);
        {
          auto childCtxHolder = ctx->EnterGraphPatternYieldClause();
          graphPatternYieldClause(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphPatternYieldClauseContext : public antlr4::ParserRuleContext {
  public:
    GraphPatternYieldClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *YIELD();
    GraphPatternYieldItemListContext *graphPatternYieldItemList();

   
  };

  template<typename ContextT>
  GraphPatternYieldClauseContext* graphPatternYieldClause(ContextT* ctx) {
    GraphPatternYieldClauseContext *_localctx = _tracker.createInstance<GraphPatternYieldClauseContext>(_ctx, getState());
    enterRule(_localctx, 296, GQLParser::RuleGraphPatternYieldClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2040);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::YIELD) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::YIELD);
      setState(2041);
      {
        auto childCtxHolder = ctx->EnterGraphPatternYieldItemList();
        graphPatternYieldItemList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphPatternYieldItemListContext : public antlr4::ParserRuleContext {
  public:
    GraphPatternYieldItemListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<GraphPatternYieldItemContext *> graphPatternYieldItem();
    GraphPatternYieldItemContext* graphPatternYieldItem(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *BINDINGS();

   
  };

  template<typename ContextT>
  GraphPatternYieldItemListContext* graphPatternYieldItemList(ContextT* ctx) {
    GraphPatternYieldItemListContext *_localctx = _tracker.createInstance<GraphPatternYieldItemListContext>(_ctx, getState());
    enterRule(_localctx, 298, GQLParser::RuleGraphPatternYieldItemList);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      setState(2053);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 147, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2043);
        {
          auto childCtxHolder = ctx->EnterGraphPatternYieldItem();
          graphPatternYieldItem(get_raw_pointer(childCtxHolder));
        }
        setState(2048);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx);
        while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2044);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::COMMA) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::COMMA);
            setState(2045);
            {
              auto childCtxHolder = ctx->EnterGraphPatternYieldItem();
              graphPatternYieldItem(get_raw_pointer(childCtxHolder));
            } 
          }
          setState(2050);
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx);
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2051);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NO) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NO);
        setState(2052);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::BINDINGS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::BINDINGS);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphPatternYieldItemContext : public antlr4::ParserRuleContext {
  public:
    GraphPatternYieldItemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BindingVariableReferenceContext *bindingVariableReference();

   
  };

  template<typename ContextT>
  GraphPatternYieldItemContext* graphPatternYieldItem(ContextT* ctx) {
    GraphPatternYieldItemContext *_localctx = _tracker.createInstance<GraphPatternYieldItemContext>(_ctx, getState());
    enterRule(_localctx, 300, GQLParser::RuleGraphPatternYieldItem);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2055);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphPatternContext : public antlr4::ParserRuleContext {
  public:
    GraphPatternContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PathPatternListContext *pathPatternList();
    MatchModeContext *matchMode();
    KeepClauseContext *keepClause();
    GraphPatternWhereClauseContext *graphPatternWhereClause();

   
  };

  template<typename ContextT>
  GraphPatternContext* graphPattern(ContextT* ctx) {
    GraphPatternContext *_localctx = _tracker.createInstance<GraphPatternContext>(_ctx, getState());
    enterRule(_localctx, 302, GQLParser::RuleGraphPattern);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2058);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx)) {
      case 1: {
        setState(2057);
        {
          auto childCtxHolder = ctx->EnterMatchMode();
          matchMode(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2060);
      {
        auto childCtxHolder = ctx->EnterPathPatternList();
        pathPatternList(get_raw_pointer(childCtxHolder));
      }
      setState(2062);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx)) {
      case 1: {
        setState(2061);
        {
          auto childCtxHolder = ctx->EnterKeepClause();
          keepClause(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2065);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx)) {
      case 1: {
        setState(2064);
        {
          auto childCtxHolder = ctx->EnterGraphPatternWhereClause();
          graphPatternWhereClause(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  MatchModeContext : public antlr4::ParserRuleContext {
  public:
    MatchModeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    RepeatableElementsMatchModeContext *repeatableElementsMatchMode();
    DifferentEdgesMatchModeContext *differentEdgesMatchMode();

   
  };

  template<typename ContextT>
  MatchModeContext* matchMode(ContextT* ctx) {
    MatchModeContext *_localctx = _tracker.createInstance<MatchModeContext>(_ctx, getState());
    enterRule(_localctx, 304, GQLParser::RuleMatchMode);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2069);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::REPEATABLE: {
          enterOuterAlt(_localctx, 1);
          setState(2067);
          {
            auto childCtxHolder = ctx->EnterRepeatableElementsMatchMode();
            repeatableElementsMatchMode(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DIFFERENT: {
          enterOuterAlt(_localctx, 2);
          setState(2068);
          {
            auto childCtxHolder = ctx->EnterDifferentEdgesMatchMode();
            differentEdgesMatchMode(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  RepeatableElementsMatchModeContext : public antlr4::ParserRuleContext {
  public:
    RepeatableElementsMatchModeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REPEATABLE();
    ElementBindingsOrElementsContext *elementBindingsOrElements();

   
  };

  template<typename ContextT>
  RepeatableElementsMatchModeContext* repeatableElementsMatchMode(ContextT* ctx) {
    RepeatableElementsMatchModeContext *_localctx = _tracker.createInstance<RepeatableElementsMatchModeContext>(_ctx, getState());
    enterRule(_localctx, 306, GQLParser::RuleRepeatableElementsMatchMode);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2071);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::REPEATABLE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::REPEATABLE);
      setState(2072);
      {
        auto childCtxHolder = ctx->EnterElementBindingsOrElements();
        elementBindingsOrElements(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DifferentEdgesMatchModeContext : public antlr4::ParserRuleContext {
  public:
    DifferentEdgesMatchModeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DIFFERENT();
    EdgeBindingsOrEdgesContext *edgeBindingsOrEdges();

   
  };

  template<typename ContextT>
  DifferentEdgesMatchModeContext* differentEdgesMatchMode(ContextT* ctx) {
    DifferentEdgesMatchModeContext *_localctx = _tracker.createInstance<DifferentEdgesMatchModeContext>(_ctx, getState());
    enterRule(_localctx, 308, GQLParser::RuleDifferentEdgesMatchMode);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2074);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DIFFERENT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DIFFERENT);
      setState(2075);
      {
        auto childCtxHolder = ctx->EnterEdgeBindingsOrEdges();
        edgeBindingsOrEdges(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ElementBindingsOrElementsContext : public antlr4::ParserRuleContext {
  public:
    ElementBindingsOrElementsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELEMENT();
    antlr4::tree::TerminalNode *BINDINGS();
    antlr4::tree::TerminalNode *ELEMENTS();

   
  };

  template<typename ContextT>
  ElementBindingsOrElementsContext* elementBindingsOrElements(ContextT* ctx) {
    ElementBindingsOrElementsContext *_localctx = _tracker.createInstance<ElementBindingsOrElementsContext>(_ctx, getState());
    enterRule(_localctx, 310, GQLParser::RuleElementBindingsOrElements);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2082);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ELEMENT: {
          enterOuterAlt(_localctx, 1);
          setState(2077);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ELEMENT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ELEMENT);
          setState(2079);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx)) {
          case 1: {
            setState(2078);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::BINDINGS) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::BINDINGS);
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::ELEMENTS: {
          enterOuterAlt(_localctx, 2);
          setState(2081);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ELEMENTS) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ELEMENTS);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeBindingsOrEdgesContext : public antlr4::ParserRuleContext {
  public:
    EdgeBindingsOrEdgesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    EdgeSynonymContext *edgeSynonym();
    antlr4::tree::TerminalNode *BINDINGS();
    EdgesSynonymContext *edgesSynonym();

   
  };

  template<typename ContextT>
  EdgeBindingsOrEdgesContext* edgeBindingsOrEdges(ContextT* ctx) {
    EdgeBindingsOrEdgesContext *_localctx = _tracker.createInstance<EdgeBindingsOrEdgesContext>(_ctx, getState());
    enterRule(_localctx, 312, GQLParser::RuleEdgeBindingsOrEdges);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2089);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::EDGE:
        case GQLParser::RELATIONSHIP: {
          enterOuterAlt(_localctx, 1);
          setState(2084);
          {
            auto childCtxHolder = ctx->EnterEdgeSynonym();
            edgeSynonym(get_raw_pointer(childCtxHolder));
          }
          setState(2086);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
          case 1: {
            setState(2085);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::BINDINGS) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::BINDINGS);
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::EDGES:
        case GQLParser::RELATIONSHIPS: {
          enterOuterAlt(_localctx, 2);
          setState(2088);
          {
            auto childCtxHolder = ctx->EnterEdgesSynonym();
            edgesSynonym(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathPatternListContext : public antlr4::ParserRuleContext {
  public:
    PathPatternListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<PathPatternContext *> pathPattern();
    PathPatternContext* pathPattern(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  PathPatternListContext* pathPatternList(ContextT* ctx) {
    PathPatternListContext *_localctx = _tracker.createInstance<PathPatternListContext>(_ctx, getState());
    enterRule(_localctx, 314, GQLParser::RulePathPatternList);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(2091);
      {
        auto childCtxHolder = ctx->EnterPathPattern();
        pathPattern(get_raw_pointer(childCtxHolder));
      }
      setState(2096);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2092);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COMMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COMMA);
          setState(2093);
          {
            auto childCtxHolder = ctx->EnterPathPattern();
            pathPattern(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(2098);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathPatternContext : public antlr4::ParserRuleContext {
  public:
    PathPatternContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PathPatternExpressionContext *pathPatternExpression();
    PathVariableDeclarationContext *pathVariableDeclaration();
    PathPatternPrefixContext *pathPatternPrefix();

   
  };

  template<typename ContextT>
  PathPatternContext* pathPattern(ContextT* ctx) {
    PathPatternContext *_localctx = _tracker.createInstance<PathPatternContext>(_ctx, getState());
    enterRule(_localctx, 316, GQLParser::RulePathPattern);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2100);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx)) {
      case 1: {
        setState(2099);
        {
          auto childCtxHolder = ctx->EnterPathVariableDeclaration();
          pathVariableDeclaration(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2103);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ALL

      || _la == GQLParser::ANY || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 18167711662081) != 0)) {
        setState(2102);
        {
          auto childCtxHolder = ctx->EnterPathPatternPrefix();
          pathPatternPrefix(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2105);
      {
        auto childCtxHolder = ctx->EnterPathPatternExpression();
        pathPatternExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathVariableDeclarationContext : public antlr4::ParserRuleContext {
  public:
    PathVariableDeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PathVariableContext *pathVariable();
    antlr4::tree::TerminalNode *EQUALS_OPERATOR();

   
  };

  template<typename ContextT>
  PathVariableDeclarationContext* pathVariableDeclaration(ContextT* ctx) {
    PathVariableDeclarationContext *_localctx = _tracker.createInstance<PathVariableDeclarationContext>(_ctx, getState());
    enterRule(_localctx, 318, GQLParser::RulePathVariableDeclaration);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2107);
      {
        auto childCtxHolder = ctx->EnterPathVariable();
        pathVariable(get_raw_pointer(childCtxHolder));
      }
      setState(2108);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EQUALS_OPERATOR);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  KeepClauseContext : public antlr4::ParserRuleContext {
  public:
    KeepClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *KEEP();
    PathPatternPrefixContext *pathPatternPrefix();

   
  };

  template<typename ContextT>
  KeepClauseContext* keepClause(ContextT* ctx) {
    KeepClauseContext *_localctx = _tracker.createInstance<KeepClauseContext>(_ctx, getState());
    enterRule(_localctx, 320, GQLParser::RuleKeepClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2110);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::KEEP) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::KEEP);
      setState(2111);
      {
        auto childCtxHolder = ctx->EnterPathPatternPrefix();
        pathPatternPrefix(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphPatternWhereClauseContext : public antlr4::ParserRuleContext {
  public:
    GraphPatternWhereClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHERE();
    SearchConditionContext *searchCondition();

   
  };

  template<typename ContextT>
  GraphPatternWhereClauseContext* graphPatternWhereClause(ContextT* ctx) {
    GraphPatternWhereClauseContext *_localctx = _tracker.createInstance<GraphPatternWhereClauseContext>(_ctx, getState());
    enterRule(_localctx, 322, GQLParser::RuleGraphPatternWhereClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2113);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::WHERE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::WHERE);
      setState(2114);
      {
        auto childCtxHolder = ctx->EnterSearchCondition();
        searchCondition(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  InsertGraphPatternContext : public antlr4::ParserRuleContext {
  public:
    InsertGraphPatternContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    InsertPathPatternListContext *insertPathPatternList();

   
  };

  template<typename ContextT>
  InsertGraphPatternContext* insertGraphPattern(ContextT* ctx) {
    InsertGraphPatternContext *_localctx = _tracker.createInstance<InsertGraphPatternContext>(_ctx, getState());
    enterRule(_localctx, 324, GQLParser::RuleInsertGraphPattern);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2116);
      {
        auto childCtxHolder = ctx->EnterInsertPathPatternList();
        insertPathPatternList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  InsertPathPatternListContext : public antlr4::ParserRuleContext {
  public:
    InsertPathPatternListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<InsertPathPatternContext *> insertPathPattern();
    InsertPathPatternContext* insertPathPattern(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  InsertPathPatternListContext* insertPathPatternList(ContextT* ctx) {
    InsertPathPatternListContext *_localctx = _tracker.createInstance<InsertPathPatternListContext>(_ctx, getState());
    enterRule(_localctx, 326, GQLParser::RuleInsertPathPatternList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2118);
      {
        auto childCtxHolder = ctx->EnterInsertPathPattern();
        insertPathPattern(get_raw_pointer(childCtxHolder));
      }
      setState(2123);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(2119);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(2120);
        {
          auto childCtxHolder = ctx->EnterInsertPathPattern();
          insertPathPattern(get_raw_pointer(childCtxHolder));
        }
        setState(2125);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  InsertPathPatternContext : public antlr4::ParserRuleContext {
  public:
    InsertPathPatternContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<InsertNodePatternContext *> insertNodePattern();
    InsertNodePatternContext* insertNodePattern(size_t i);
    std::vector<InsertEdgePatternContext *> insertEdgePattern();
    InsertEdgePatternContext* insertEdgePattern(size_t i);

   
  };

  template<typename ContextT>
  InsertPathPatternContext* insertPathPattern(ContextT* ctx) {
    InsertPathPatternContext *_localctx = _tracker.createInstance<InsertPathPatternContext>(_ctx, getState());
    enterRule(_localctx, 328, GQLParser::RuleInsertPathPattern);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2126);
      {
        auto childCtxHolder = ctx->EnterInsertNodePattern();
        insertNodePattern(get_raw_pointer(childCtxHolder));
      }
      setState(2132);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 338) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 338)) & 131137) != 0)) {
        setState(2127);
        {
          auto childCtxHolder = ctx->EnterInsertEdgePattern();
          insertEdgePattern(get_raw_pointer(childCtxHolder));
        }
        setState(2128);
        {
          auto childCtxHolder = ctx->EnterInsertNodePattern();
          insertNodePattern(get_raw_pointer(childCtxHolder));
        }
        setState(2134);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  InsertNodePatternContext : public antlr4::ParserRuleContext {
  public:
    InsertNodePatternContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    InsertElementPatternFillerContext *insertElementPatternFiller();

   
  };

  template<typename ContextT>
  InsertNodePatternContext* insertNodePattern(ContextT* ctx) {
    InsertNodePatternContext *_localctx = _tracker.createInstance<InsertNodePatternContext>(_ctx, getState());
    enterRule(_localctx, 330, GQLParser::RuleInsertNodePattern);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2135);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(2137);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IS || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0) || _la == GQLParser::COLON

      || _la == GQLParser::LEFT_BRACE) {
        setState(2136);
        {
          auto childCtxHolder = ctx->EnterInsertElementPatternFiller();
          insertElementPatternFiller(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2139);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  InsertEdgePatternContext : public antlr4::ParserRuleContext {
  public:
    InsertEdgePatternContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    InsertEdgePointingLeftContext *insertEdgePointingLeft();
    InsertEdgePointingRightContext *insertEdgePointingRight();
    InsertEdgeUndirectedContext *insertEdgeUndirected();

   
  };

  template<typename ContextT>
  InsertEdgePatternContext* insertEdgePattern(ContextT* ctx) {
    InsertEdgePatternContext *_localctx = _tracker.createInstance<InsertEdgePatternContext>(_ctx, getState());
    enterRule(_localctx, 332, GQLParser::RuleInsertEdgePattern);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2144);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LEFT_ARROW_BRACKET: {
          enterOuterAlt(_localctx, 1);
          setState(2141);
          {
            auto childCtxHolder = ctx->EnterInsertEdgePointingLeft();
            insertEdgePointingLeft(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::MINUS_LEFT_BRACKET: {
          enterOuterAlt(_localctx, 2);
          setState(2142);
          {
            auto childCtxHolder = ctx->EnterInsertEdgePointingRight();
            insertEdgePointingRight(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::TILDE_LEFT_BRACKET: {
          enterOuterAlt(_localctx, 3);
          setState(2143);
          {
            auto childCtxHolder = ctx->EnterInsertEdgeUndirected();
            insertEdgeUndirected(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  InsertEdgePointingLeftContext : public antlr4::ParserRuleContext {
  public:
    InsertEdgePointingLeftContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_ARROW_BRACKET();
    antlr4::tree::TerminalNode *RIGHT_BRACKET_MINUS();
    InsertElementPatternFillerContext *insertElementPatternFiller();

   
  };

  template<typename ContextT>
  InsertEdgePointingLeftContext* insertEdgePointingLeft(ContextT* ctx) {
    InsertEdgePointingLeftContext *_localctx = _tracker.createInstance<InsertEdgePointingLeftContext>(_ctx, getState());
    enterRule(_localctx, 334, GQLParser::RuleInsertEdgePointingLeft);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2146);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ARROW_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ARROW_BRACKET);
      setState(2148);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IS || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0) || _la == GQLParser::COLON

      || _la == GQLParser::LEFT_BRACE) {
        setState(2147);
        {
          auto childCtxHolder = ctx->EnterInsertElementPatternFiller();
          insertElementPatternFiller(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2150);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_MINUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_MINUS);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  InsertEdgePointingRightContext : public antlr4::ParserRuleContext {
  public:
    InsertEdgePointingRightContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MINUS_LEFT_BRACKET();
    antlr4::tree::TerminalNode *BRACKET_RIGHT_ARROW();
    InsertElementPatternFillerContext *insertElementPatternFiller();

   
  };

  template<typename ContextT>
  InsertEdgePointingRightContext* insertEdgePointingRight(ContextT* ctx) {
    InsertEdgePointingRightContext *_localctx = _tracker.createInstance<InsertEdgePointingRightContext>(_ctx, getState());
    enterRule(_localctx, 336, GQLParser::RuleInsertEdgePointingRight);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2152);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MINUS_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MINUS_LEFT_BRACKET);
      setState(2154);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IS || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0) || _la == GQLParser::COLON

      || _la == GQLParser::LEFT_BRACE) {
        setState(2153);
        {
          auto childCtxHolder = ctx->EnterInsertElementPatternFiller();
          insertElementPatternFiller(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2156);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BRACKET_RIGHT_ARROW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BRACKET_RIGHT_ARROW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  InsertEdgeUndirectedContext : public antlr4::ParserRuleContext {
  public:
    InsertEdgeUndirectedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TILDE_LEFT_BRACKET();
    antlr4::tree::TerminalNode *RIGHT_BRACKET_TILDE();
    InsertElementPatternFillerContext *insertElementPatternFiller();

   
  };

  template<typename ContextT>
  InsertEdgeUndirectedContext* insertEdgeUndirected(ContextT* ctx) {
    InsertEdgeUndirectedContext *_localctx = _tracker.createInstance<InsertEdgeUndirectedContext>(_ctx, getState());
    enterRule(_localctx, 338, GQLParser::RuleInsertEdgeUndirected);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2158);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE_LEFT_BRACKET);
      setState(2160);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IS || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0) || _la == GQLParser::COLON

      || _la == GQLParser::LEFT_BRACE) {
        setState(2159);
        {
          auto childCtxHolder = ctx->EnterInsertElementPatternFiller();
          insertElementPatternFiller(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2162);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_TILDE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  InsertElementPatternFillerContext : public antlr4::ParserRuleContext {
  public:
    InsertElementPatternFillerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ElementVariableDeclarationContext *elementVariableDeclaration();
    LabelAndPropertySetSpecificationContext *labelAndPropertySetSpecification();

   
  };

  template<typename ContextT>
  InsertElementPatternFillerContext* insertElementPatternFiller(ContextT* ctx) {
    InsertElementPatternFillerContext *_localctx = _tracker.createInstance<InsertElementPatternFillerContext>(_ctx, getState());
    enterRule(_localctx, 340, GQLParser::RuleInsertElementPatternFiller);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2172);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 168, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2164);
        {
          auto childCtxHolder = ctx->EnterElementVariableDeclaration();
          elementVariableDeclaration(get_raw_pointer(childCtxHolder));
        }
        setState(2166);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::IS || _la == GQLParser::COLON

        || _la == GQLParser::LEFT_BRACE) {
          setState(2165);
          {
            auto childCtxHolder = ctx->EnterLabelAndPropertySetSpecification();
            labelAndPropertySetSpecification(get_raw_pointer(childCtxHolder));
          }
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2169);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 277) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 277)) & 560750930165759) != 0)) {
          setState(2168);
          {
            auto childCtxHolder = ctx->EnterElementVariableDeclaration();
            elementVariableDeclaration(get_raw_pointer(childCtxHolder));
          }
        }
        setState(2171);
        {
          auto childCtxHolder = ctx->EnterLabelAndPropertySetSpecification();
          labelAndPropertySetSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LabelAndPropertySetSpecificationContext : public antlr4::ParserRuleContext {
  public:
    LabelAndPropertySetSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IsOrColonContext *isOrColon();
    LabelSetSpecificationContext *labelSetSpecification();
    ElementPropertySpecificationContext *elementPropertySpecification();

   
  };

  template<typename ContextT>
  LabelAndPropertySetSpecificationContext* labelAndPropertySetSpecification(ContextT* ctx) {
    LabelAndPropertySetSpecificationContext *_localctx = _tracker.createInstance<LabelAndPropertySetSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 342, GQLParser::RuleLabelAndPropertySetSpecification);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2185);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2174);
        {
          auto childCtxHolder = ctx->EnterIsOrColon();
          isOrColon(get_raw_pointer(childCtxHolder));
        }
        setState(2175);
        {
          auto childCtxHolder = ctx->EnterLabelSetSpecification();
          labelSetSpecification(get_raw_pointer(childCtxHolder));
        }
        setState(2177);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::LEFT_BRACE) {
          setState(2176);
          {
            auto childCtxHolder = ctx->EnterElementPropertySpecification();
            elementPropertySpecification(get_raw_pointer(childCtxHolder));
          }
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2182);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::IS || _la == GQLParser::COLON) {
          setState(2179);
          {
            auto childCtxHolder = ctx->EnterIsOrColon();
            isOrColon(get_raw_pointer(childCtxHolder));
          }
          setState(2180);
          {
            auto childCtxHolder = ctx->EnterLabelSetSpecification();
            labelSetSpecification(get_raw_pointer(childCtxHolder));
          }
        }
        setState(2184);
        {
          auto childCtxHolder = ctx->EnterElementPropertySpecification();
          elementPropertySpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathPatternPrefixContext : public antlr4::ParserRuleContext {
  public:
    PathPatternPrefixContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PathModePrefixContext *pathModePrefix();
    PathSearchPrefixContext *pathSearchPrefix();

   
  };

  template<typename ContextT>
  PathPatternPrefixContext* pathPatternPrefix(ContextT* ctx) {
    PathPatternPrefixContext *_localctx = _tracker.createInstance<PathPatternPrefixContext>(_ctx, getState());
    enterRule(_localctx, 344, GQLParser::RulePathPatternPrefix);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2189);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ACYCLIC:
        case GQLParser::SIMPLE:
        case GQLParser::TRAIL:
        case GQLParser::WALK: {
          enterOuterAlt(_localctx, 1);
          setState(2187);
          {
            auto childCtxHolder = ctx->EnterPathModePrefix();
            pathModePrefix(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ALL:
        case GQLParser::ANY:
        case GQLParser::SHORTEST: {
          enterOuterAlt(_localctx, 2);
          setState(2188);
          {
            auto childCtxHolder = ctx->EnterPathSearchPrefix();
            pathSearchPrefix(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathModePrefixContext : public antlr4::ParserRuleContext {
  public:
    PathModePrefixContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PathModeContext *pathMode();
    PathOrPathsContext *pathOrPaths();

   
  };

  template<typename ContextT>
  PathModePrefixContext* pathModePrefix(ContextT* ctx) {
    PathModePrefixContext *_localctx = _tracker.createInstance<PathModePrefixContext>(_ctx, getState());
    enterRule(_localctx, 346, GQLParser::RulePathModePrefix);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2191);
      {
        auto childCtxHolder = ctx->EnterPathMode();
        pathMode(get_raw_pointer(childCtxHolder));
      }
      setState(2193);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx)) {
      case 1: {
        setState(2192);
        {
          auto childCtxHolder = ctx->EnterPathOrPaths();
          pathOrPaths(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathModeContext : public antlr4::ParserRuleContext {
  public:
    PathModeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WALK();
    antlr4::tree::TerminalNode *TRAIL();
    antlr4::tree::TerminalNode *SIMPLE();
    antlr4::tree::TerminalNode *ACYCLIC();

   
  };

  template<typename ContextT>
  PathModeContext* pathMode(ContextT* ctx) {
    PathModeContext *_localctx = _tracker.createInstance<PathModeContext>(_ctx, getState());
    enterRule(_localctx, 348, GQLParser::RulePathMode);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2195);
      _la = _input->LA(1);
      if (!(((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 18159121727489) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathSearchPrefixContext : public antlr4::ParserRuleContext {
  public:
    PathSearchPrefixContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    AllPathSearchContext *allPathSearch();
    AnyPathSearchContext *anyPathSearch();
    ShortestPathSearchContext *shortestPathSearch();

   
  };

  template<typename ContextT>
  PathSearchPrefixContext* pathSearchPrefix(ContextT* ctx) {
    PathSearchPrefixContext *_localctx = _tracker.createInstance<PathSearchPrefixContext>(_ctx, getState());
    enterRule(_localctx, 350, GQLParser::RulePathSearchPrefix);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2200);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2197);
        {
          auto childCtxHolder = ctx->EnterAllPathSearch();
          allPathSearch(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2198);
        {
          auto childCtxHolder = ctx->EnterAnyPathSearch();
          anyPathSearch(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2199);
        {
          auto childCtxHolder = ctx->EnterShortestPathSearch();
          shortestPathSearch(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  AllPathSearchContext : public antlr4::ParserRuleContext {
  public:
    AllPathSearchContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALL();
    PathModeContext *pathMode();
    PathOrPathsContext *pathOrPaths();

   
  };

  template<typename ContextT>
  AllPathSearchContext* allPathSearch(ContextT* ctx) {
    AllPathSearchContext *_localctx = _tracker.createInstance<AllPathSearchContext>(_ctx, getState());
    enterRule(_localctx, 352, GQLParser::RuleAllPathSearch);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2202);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ALL) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ALL);
      setState(2204);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx)) {
      case 1: {
        setState(2203);
        {
          auto childCtxHolder = ctx->EnterPathMode();
          pathMode(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2207);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 176, _ctx)) {
      case 1: {
        setState(2206);
        {
          auto childCtxHolder = ctx->EnterPathOrPaths();
          pathOrPaths(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathOrPathsContext : public antlr4::ParserRuleContext {
  public:
    PathOrPathsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PATH();
    antlr4::tree::TerminalNode *PATHS();

   
  };

  template<typename ContextT>
  PathOrPathsContext* pathOrPaths(ContextT* ctx) {
    PathOrPathsContext *_localctx = _tracker.createInstance<PathOrPathsContext>(_ctx, getState());
    enterRule(_localctx, 354, GQLParser::RulePathOrPaths);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2209);
      _la = _input->LA(1);
      if (!(_la == GQLParser::PATH

      || _la == GQLParser::PATHS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  AnyPathSearchContext : public antlr4::ParserRuleContext {
  public:
    AnyPathSearchContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ANY();
    NumberOfPathsContext *numberOfPaths();
    PathModeContext *pathMode();
    PathOrPathsContext *pathOrPaths();

   
  };

  template<typename ContextT>
  AnyPathSearchContext* anyPathSearch(ContextT* ctx) {
    AnyPathSearchContext *_localctx = _tracker.createInstance<AnyPathSearchContext>(_ctx, getState());
    enterRule(_localctx, 356, GQLParser::RuleAnyPathSearch);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2211);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ANY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ANY);
      setState(2213);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 177, _ctx)) {
      case 1: {
        setState(2212);
        {
          auto childCtxHolder = ctx->EnterNumberOfPaths();
          numberOfPaths(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2216);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 178, _ctx)) {
      case 1: {
        setState(2215);
        {
          auto childCtxHolder = ctx->EnterPathMode();
          pathMode(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2219);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx)) {
      case 1: {
        setState(2218);
        {
          auto childCtxHolder = ctx->EnterPathOrPaths();
          pathOrPaths(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NumberOfPathsContext : public antlr4::ParserRuleContext {
  public:
    NumberOfPathsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NonNegativeIntegerSpecificationContext *nonNegativeIntegerSpecification();

   
  };

  template<typename ContextT>
  NumberOfPathsContext* numberOfPaths(ContextT* ctx) {
    NumberOfPathsContext *_localctx = _tracker.createInstance<NumberOfPathsContext>(_ctx, getState());
    enterRule(_localctx, 358, GQLParser::RuleNumberOfPaths);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2221);
      {
        auto childCtxHolder = ctx->EnterNonNegativeIntegerSpecification();
        nonNegativeIntegerSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ShortestPathSearchContext : public antlr4::ParserRuleContext {
  public:
    ShortestPathSearchContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    AllShortestPathSearchContext *allShortestPathSearch();
    AnyShortestPathSearchContext *anyShortestPathSearch();
    CountedShortestPathSearchContext *countedShortestPathSearch();
    CountedShortestGroupSearchContext *countedShortestGroupSearch();

   
  };

  template<typename ContextT>
  ShortestPathSearchContext* shortestPathSearch(ContextT* ctx) {
    ShortestPathSearchContext *_localctx = _tracker.createInstance<ShortestPathSearchContext>(_ctx, getState());
    enterRule(_localctx, 360, GQLParser::RuleShortestPathSearch);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2227);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2223);
        {
          auto childCtxHolder = ctx->EnterAllShortestPathSearch();
          allShortestPathSearch(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2224);
        {
          auto childCtxHolder = ctx->EnterAnyShortestPathSearch();
          anyShortestPathSearch(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2225);
        {
          auto childCtxHolder = ctx->EnterCountedShortestPathSearch();
          countedShortestPathSearch(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(2226);
        {
          auto childCtxHolder = ctx->EnterCountedShortestGroupSearch();
          countedShortestGroupSearch(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  AllShortestPathSearchContext : public antlr4::ParserRuleContext {
  public:
    AllShortestPathSearchContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALL();
    antlr4::tree::TerminalNode *SHORTEST();
    PathModeContext *pathMode();
    PathOrPathsContext *pathOrPaths();

   
  };

  template<typename ContextT>
  AllShortestPathSearchContext* allShortestPathSearch(ContextT* ctx) {
    AllShortestPathSearchContext *_localctx = _tracker.createInstance<AllShortestPathSearchContext>(_ctx, getState());
    enterRule(_localctx, 362, GQLParser::RuleAllShortestPathSearch);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2229);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ALL) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ALL);
      setState(2230);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SHORTEST) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SHORTEST);
      setState(2232);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 181, _ctx)) {
      case 1: {
        setState(2231);
        {
          auto childCtxHolder = ctx->EnterPathMode();
          pathMode(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2235);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {
      case 1: {
        setState(2234);
        {
          auto childCtxHolder = ctx->EnterPathOrPaths();
          pathOrPaths(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  AnyShortestPathSearchContext : public antlr4::ParserRuleContext {
  public:
    AnyShortestPathSearchContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ANY();
    antlr4::tree::TerminalNode *SHORTEST();
    PathModeContext *pathMode();
    PathOrPathsContext *pathOrPaths();

   
  };

  template<typename ContextT>
  AnyShortestPathSearchContext* anyShortestPathSearch(ContextT* ctx) {
    AnyShortestPathSearchContext *_localctx = _tracker.createInstance<AnyShortestPathSearchContext>(_ctx, getState());
    enterRule(_localctx, 364, GQLParser::RuleAnyShortestPathSearch);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2237);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ANY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ANY);
      setState(2238);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SHORTEST) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SHORTEST);
      setState(2240);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 183, _ctx)) {
      case 1: {
        setState(2239);
        {
          auto childCtxHolder = ctx->EnterPathMode();
          pathMode(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2243);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx)) {
      case 1: {
        setState(2242);
        {
          auto childCtxHolder = ctx->EnterPathOrPaths();
          pathOrPaths(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CountedShortestPathSearchContext : public antlr4::ParserRuleContext {
  public:
    CountedShortestPathSearchContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SHORTEST();
    NumberOfPathsContext *numberOfPaths();
    PathModeContext *pathMode();
    PathOrPathsContext *pathOrPaths();

   
  };

  template<typename ContextT>
  CountedShortestPathSearchContext* countedShortestPathSearch(ContextT* ctx) {
    CountedShortestPathSearchContext *_localctx = _tracker.createInstance<CountedShortestPathSearchContext>(_ctx, getState());
    enterRule(_localctx, 366, GQLParser::RuleCountedShortestPathSearch);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2245);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SHORTEST) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SHORTEST);
      setState(2246);
      {
        auto childCtxHolder = ctx->EnterNumberOfPaths();
        numberOfPaths(get_raw_pointer(childCtxHolder));
      }
      setState(2248);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 185, _ctx)) {
      case 1: {
        setState(2247);
        {
          auto childCtxHolder = ctx->EnterPathMode();
          pathMode(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2251);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 186, _ctx)) {
      case 1: {
        setState(2250);
        {
          auto childCtxHolder = ctx->EnterPathOrPaths();
          pathOrPaths(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CountedShortestGroupSearchContext : public antlr4::ParserRuleContext {
  public:
    CountedShortestGroupSearchContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SHORTEST();
    antlr4::tree::TerminalNode *GROUP();
    antlr4::tree::TerminalNode *GROUPS();
    NumberOfGroupsContext *numberOfGroups();
    PathModeContext *pathMode();
    PathOrPathsContext *pathOrPaths();

   
  };

  template<typename ContextT>
  CountedShortestGroupSearchContext* countedShortestGroupSearch(ContextT* ctx) {
    CountedShortestGroupSearchContext *_localctx = _tracker.createInstance<CountedShortestGroupSearchContext>(_ctx, getState());
    enterRule(_localctx, 368, GQLParser::RuleCountedShortestGroupSearch);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2253);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SHORTEST) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SHORTEST);
      setState(2255);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 983040) != 0) || _la == GQLParser::GENERAL_PARAMETER_REFERENCE) {
        setState(2254);
        {
          auto childCtxHolder = ctx->EnterNumberOfGroups();
          numberOfGroups(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2258);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 18159121727489) != 0)) {
        setState(2257);
        {
          auto childCtxHolder = ctx->EnterPathMode();
          pathMode(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2261);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PATH

      || _la == GQLParser::PATHS) {
        setState(2260);
        {
          auto childCtxHolder = ctx->EnterPathOrPaths();
          pathOrPaths(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2263);
      _la = _input->LA(1);
      if (!(_la == GQLParser::GROUP || _la == GQLParser::GROUPS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NumberOfGroupsContext : public antlr4::ParserRuleContext {
  public:
    NumberOfGroupsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NonNegativeIntegerSpecificationContext *nonNegativeIntegerSpecification();

   
  };

  template<typename ContextT>
  NumberOfGroupsContext* numberOfGroups(ContextT* ctx) {
    NumberOfGroupsContext *_localctx = _tracker.createInstance<NumberOfGroupsContext>(_ctx, getState());
    enterRule(_localctx, 370, GQLParser::RuleNumberOfGroups);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2265);
      {
        auto childCtxHolder = ctx->EnterNonNegativeIntegerSpecification();
        nonNegativeIntegerSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathPatternExpressionContext : public antlr4::ParserRuleContext {
  public:
    PathPatternExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
   
    PathPatternExpressionContext() = default;
    void copyFrom(PathPatternExpressionContext *context);
    using antlr4::ParserRuleContext::copyFrom;

    virtual size_t getRuleIndex() const override;

   
  };

  class  PpePatternUnionContext : public PathPatternExpressionContext {
  public:
    PpePatternUnionContext(PathPatternExpressionContext *ctx);

    std::vector<PathTermContext *> pathTerm();
    PathTermContext* pathTerm(size_t i);
    std::vector<antlr4::tree::TerminalNode *> VERTICAL_BAR();
    antlr4::tree::TerminalNode* VERTICAL_BAR(size_t i);
  };

  class  PpePathTermContext : public PathPatternExpressionContext {
  public:
    PpePathTermContext(PathPatternExpressionContext *ctx);

    PathTermContext *pathTerm();
  };

  class  PpeMultisetAlternationContext : public PathPatternExpressionContext {
  public:
    PpeMultisetAlternationContext(PathPatternExpressionContext *ctx);

    std::vector<PathTermContext *> pathTerm();
    PathTermContext* pathTerm(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MULTISET_ALTERNATION_OPERATOR();
    antlr4::tree::TerminalNode* MULTISET_ALTERNATION_OPERATOR(size_t i);
  };

  template<typename ContextT>
  PathPatternExpressionContext* pathPatternExpression(ContextT* ctx) {
    PathPatternExpressionContext *_localctx = _tracker.createInstance<PathPatternExpressionContext>(_ctx, getState());
    enterRule(_localctx, 372, GQLParser::RulePathPatternExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      setState(2282);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 192, _ctx)) {
      case 1: {
        _localctx = _tracker.createInstance<GQLParser::PpePathTermContext>(_localctx);
        auto ctxHolder = ctx->EnterPpePathTerm();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 1);
        setState(2267);
        {
          auto childCtxHolder = ctx->EnterPathTerm();
          pathTerm(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        _localctx = _tracker.createInstance<GQLParser::PpeMultisetAlternationContext>(_localctx);
        auto ctxHolder = ctx->EnterPpeMultisetAlternation();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 2);
        setState(2268);
        {
          auto childCtxHolder = ctx->EnterPathTerm();
          pathTerm(get_raw_pointer(childCtxHolder));
        }
        setState(2271); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(2269);
                  if constexpr (has_OnToken<decltype(ctx)>::value) {
                    if (_input->LA(1) == GQLParser::MULTISET_ALTERNATION_OPERATOR) {
                      ctx->OnToken(_input->LT(1));
                    }
                  }
                  match(GQLParser::MULTISET_ALTERNATION_OPERATOR);
                  setState(2270);
                  {
                    auto childCtxHolder = ctx->EnterPathTerm();
                    pathTerm(get_raw_pointer(childCtxHolder));
                  }
                  break;
                }

          default:
            throw antlr4::NoViableAltException(this);
          }
          setState(2273); 
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 190, _ctx);
        } while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      case 3: {
        _localctx = _tracker.createInstance<GQLParser::PpePatternUnionContext>(_localctx);
        auto ctxHolder = ctx->EnterPpePatternUnion();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 3);
        setState(2275);
        {
          auto childCtxHolder = ctx->EnterPathTerm();
          pathTerm(get_raw_pointer(childCtxHolder));
        }
        setState(2278); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(2276);
                  if constexpr (has_OnToken<decltype(ctx)>::value) {
                    if (_input->LA(1) == GQLParser::VERTICAL_BAR) {
                      ctx->OnToken(_input->LT(1));
                    }
                  }
                  match(GQLParser::VERTICAL_BAR);
                  setState(2277);
                  {
                    auto childCtxHolder = ctx->EnterPathTerm();
                    pathTerm(get_raw_pointer(childCtxHolder));
                  }
                  break;
                }

          default:
            throw antlr4::NoViableAltException(this);
          }
          setState(2280); 
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 191, _ctx);
        } while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathTermContext : public antlr4::ParserRuleContext {
  public:
    PathTermContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<PathFactorContext *> pathFactor();
    PathFactorContext* pathFactor(size_t i);

   
  };

  template<typename ContextT>
  PathTermContext* pathTerm(ContextT* ctx) {
    PathTermContext *_localctx = _tracker.createInstance<PathTermContext>(_ctx, getState());
    enterRule(_localctx, 374, GQLParser::RulePathTerm);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(2285); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(2284);
                {
                  auto childCtxHolder = ctx->EnterPathFactor();
                  pathFactor(get_raw_pointer(childCtxHolder));
                }
                break;
              }

        default:
          throw antlr4::NoViableAltException(this);
        }
        setState(2287); 
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx);
      } while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathFactorContext : public antlr4::ParserRuleContext {
  public:
    PathFactorContext(antlr4::ParserRuleContext *parent, size_t invokingState);
   
    PathFactorContext() = default;
    void copyFrom(PathFactorContext *context);
    using antlr4::ParserRuleContext::copyFrom;

    virtual size_t getRuleIndex() const override;

   
  };

  class  PfQuantifiedPathPrimaryContext : public PathFactorContext {
  public:
    PfQuantifiedPathPrimaryContext(PathFactorContext *ctx);

    PathPrimaryContext *pathPrimary();
    GraphPatternQuantifierContext *graphPatternQuantifier();
  };

  class  PfQuestionedPathPrimaryContext : public PathFactorContext {
  public:
    PfQuestionedPathPrimaryContext(PathFactorContext *ctx);

    PathPrimaryContext *pathPrimary();
    antlr4::tree::TerminalNode *QUESTION_MARK();
  };

  class  PfPathPrimaryContext : public PathFactorContext {
  public:
    PfPathPrimaryContext(PathFactorContext *ctx);

    PathPrimaryContext *pathPrimary();
  };

  template<typename ContextT>
  PathFactorContext* pathFactor(ContextT* ctx) {
    PathFactorContext *_localctx = _tracker.createInstance<PathFactorContext>(_ctx, getState());
    enterRule(_localctx, 376, GQLParser::RulePathFactor);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2296);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx)) {
      case 1: {
        _localctx = _tracker.createInstance<GQLParser::PfPathPrimaryContext>(_localctx);
        auto ctxHolder = ctx->EnterPfPathPrimary();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 1);
        setState(2289);
        {
          auto childCtxHolder = ctx->EnterPathPrimary();
          pathPrimary(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        _localctx = _tracker.createInstance<GQLParser::PfQuantifiedPathPrimaryContext>(_localctx);
        auto ctxHolder = ctx->EnterPfQuantifiedPathPrimary();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 2);
        setState(2290);
        {
          auto childCtxHolder = ctx->EnterPathPrimary();
          pathPrimary(get_raw_pointer(childCtxHolder));
        }
        setState(2291);
        {
          auto childCtxHolder = ctx->EnterGraphPatternQuantifier();
          graphPatternQuantifier(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        _localctx = _tracker.createInstance<GQLParser::PfQuestionedPathPrimaryContext>(_localctx);
        auto ctxHolder = ctx->EnterPfQuestionedPathPrimary();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 3);
        setState(2293);
        {
          auto childCtxHolder = ctx->EnterPathPrimary();
          pathPrimary(get_raw_pointer(childCtxHolder));
        }
        setState(2294);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::QUESTION_MARK) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::QUESTION_MARK);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathPrimaryContext : public antlr4::ParserRuleContext {
  public:
    PathPrimaryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
   
    PathPrimaryContext() = default;
    void copyFrom(PathPrimaryContext *context);
    using antlr4::ParserRuleContext::copyFrom;

    virtual size_t getRuleIndex() const override;

   
  };

  class  PpParenthesizedPathPatternExpressionContext : public PathPrimaryContext {
  public:
    PpParenthesizedPathPatternExpressionContext(PathPrimaryContext *ctx);

    ParenthesizedPathPatternExpressionContext *parenthesizedPathPatternExpression();
  };

  class  PpElementPatternContext : public PathPrimaryContext {
  public:
    PpElementPatternContext(PathPrimaryContext *ctx);

    ElementPatternContext *elementPattern();
  };

  class  PpSimplifiedPathPatternExpressionContext : public PathPrimaryContext {
  public:
    PpSimplifiedPathPatternExpressionContext(PathPrimaryContext *ctx);

    SimplifiedPathPatternExpressionContext *simplifiedPathPatternExpression();
  };

  template<typename ContextT>
  PathPrimaryContext* pathPrimary(ContextT* ctx) {
    PathPrimaryContext *_localctx = _tracker.createInstance<PathPrimaryContext>(_ctx, getState());
    enterRule(_localctx, 378, GQLParser::RulePathPrimary);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2301);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
      case 1: {
        _localctx = _tracker.createInstance<GQLParser::PpElementPatternContext>(_localctx);
        auto ctxHolder = ctx->EnterPpElementPattern();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 1);
        setState(2298);
        {
          auto childCtxHolder = ctx->EnterElementPattern();
          elementPattern(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        _localctx = _tracker.createInstance<GQLParser::PpParenthesizedPathPatternExpressionContext>(_localctx);
        auto ctxHolder = ctx->EnterPpParenthesizedPathPatternExpression();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 2);
        setState(2299);
        {
          auto childCtxHolder = ctx->EnterParenthesizedPathPatternExpression();
          parenthesizedPathPatternExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        _localctx = _tracker.createInstance<GQLParser::PpSimplifiedPathPatternExpressionContext>(_localctx);
        auto ctxHolder = ctx->EnterPpSimplifiedPathPatternExpression();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        enterOuterAlt(_localctx, 3);
        setState(2300);
        {
          auto childCtxHolder = ctx->EnterSimplifiedPathPatternExpression();
          simplifiedPathPatternExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ElementPatternContext : public antlr4::ParserRuleContext {
  public:
    ElementPatternContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NodePatternContext *nodePattern();
    EdgePatternContext *edgePattern();

   
  };

  template<typename ContextT>
  ElementPatternContext* elementPattern(ContextT* ctx) {
    ElementPatternContext *_localctx = _tracker.createInstance<ElementPatternContext>(_ctx, getState());
    enterRule(_localctx, 380, GQLParser::RuleElementPattern);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2305);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LEFT_PAREN: {
          enterOuterAlt(_localctx, 1);
          setState(2303);
          {
            auto childCtxHolder = ctx->EnterNodePattern();
            nodePattern(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LEFT_ARROW:
        case GQLParser::LEFT_ARROW_TILDE:
        case GQLParser::LEFT_ARROW_BRACKET:
        case GQLParser::LEFT_ARROW_TILDE_BRACKET:
        case GQLParser::LEFT_MINUS_RIGHT:
        case GQLParser::MINUS_LEFT_BRACKET:
        case GQLParser::RIGHT_ARROW:
        case GQLParser::TILDE_LEFT_BRACKET:
        case GQLParser::TILDE_RIGHT_ARROW:
        case GQLParser::MINUS_SIGN:
        case GQLParser::TILDE: {
          enterOuterAlt(_localctx, 2);
          setState(2304);
          {
            auto childCtxHolder = ctx->EnterEdgePattern();
            edgePattern(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NodePatternContext : public antlr4::ParserRuleContext {
  public:
    NodePatternContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ElementPatternFillerContext *elementPatternFiller();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  NodePatternContext* nodePattern(ContextT* ctx) {
    NodePatternContext *_localctx = _tracker.createInstance<NodePatternContext>(_ctx, getState());
    enterRule(_localctx, 382, GQLParser::RuleNodePattern);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2307);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(2308);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2309);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ElementPatternFillerContext : public antlr4::ParserRuleContext {
  public:
    ElementPatternFillerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ElementVariableDeclarationContext *elementVariableDeclaration();
    IsLabelExpressionContext *isLabelExpression();
    ElementPatternPredicateContext *elementPatternPredicate();

   
  };

  template<typename ContextT>
  ElementPatternFillerContext* elementPatternFiller(ContextT* ctx) {
    ElementPatternFillerContext *_localctx = _tracker.createInstance<ElementPatternFillerContext>(_ctx, getState());
    enterRule(_localctx, 384, GQLParser::RuleElementPatternFiller);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2312);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0)) {
        setState(2311);
        {
          auto childCtxHolder = ctx->EnterElementVariableDeclaration();
          elementVariableDeclaration(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2315);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IS || _la == GQLParser::COLON) {
        setState(2314);
        {
          auto childCtxHolder = ctx->EnterIsLabelExpression();
          isLabelExpression(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2318);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::WHERE || _la == GQLParser::LEFT_BRACE) {
        setState(2317);
        {
          auto childCtxHolder = ctx->EnterElementPatternPredicate();
          elementPatternPredicate(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ElementVariableDeclarationContext : public antlr4::ParserRuleContext {
  public:
    ElementVariableDeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ElementVariableContext *elementVariable();
    antlr4::tree::TerminalNode *TEMP();

   
  };

  template<typename ContextT>
  ElementVariableDeclarationContext* elementVariableDeclaration(ContextT* ctx) {
    ElementVariableDeclarationContext *_localctx = _tracker.createInstance<ElementVariableDeclarationContext>(_ctx, getState());
    enterRule(_localctx, 386, GQLParser::RuleElementVariableDeclaration);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2321);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx)) {
      case 1: {
        setState(2320);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::TEMP) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::TEMP);
        break;
      }

      default:
        break;
      }
      setState(2323);
      {
        auto childCtxHolder = ctx->EnterElementVariable();
        elementVariable(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  IsLabelExpressionContext : public antlr4::ParserRuleContext {
  public:
    IsLabelExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IsOrColonContext *isOrColon();
    LabelExpressionContext *labelExpression();

   
  };

  template<typename ContextT>
  IsLabelExpressionContext* isLabelExpression(ContextT* ctx) {
    IsLabelExpressionContext *_localctx = _tracker.createInstance<IsLabelExpressionContext>(_ctx, getState());
    enterRule(_localctx, 388, GQLParser::RuleIsLabelExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2325);
      {
        auto childCtxHolder = ctx->EnterIsOrColon();
        isOrColon(get_raw_pointer(childCtxHolder));
      }
      setState(2326);
      {
        auto childCtxHolder = ctx->EnterLabelExpression();
        labelExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  IsOrColonContext : public antlr4::ParserRuleContext {
  public:
    IsOrColonContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *COLON();

   
  };

  template<typename ContextT>
  IsOrColonContext* isOrColon(ContextT* ctx) {
    IsOrColonContext *_localctx = _tracker.createInstance<IsOrColonContext>(_ctx, getState());
    enterRule(_localctx, 390, GQLParser::RuleIsOrColon);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2328);
      _la = _input->LA(1);
      if (!(_la == GQLParser::IS || _la == GQLParser::COLON)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ElementPatternPredicateContext : public antlr4::ParserRuleContext {
  public:
    ElementPatternPredicateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ElementPatternWhereClauseContext *elementPatternWhereClause();
    ElementPropertySpecificationContext *elementPropertySpecification();

   
  };

  template<typename ContextT>
  ElementPatternPredicateContext* elementPatternPredicate(ContextT* ctx) {
    ElementPatternPredicateContext *_localctx = _tracker.createInstance<ElementPatternPredicateContext>(_ctx, getState());
    enterRule(_localctx, 392, GQLParser::RuleElementPatternPredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2332);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::WHERE: {
          enterOuterAlt(_localctx, 1);
          setState(2330);
          {
            auto childCtxHolder = ctx->EnterElementPatternWhereClause();
            elementPatternWhereClause(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(2331);
          {
            auto childCtxHolder = ctx->EnterElementPropertySpecification();
            elementPropertySpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ElementPatternWhereClauseContext : public antlr4::ParserRuleContext {
  public:
    ElementPatternWhereClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHERE();
    SearchConditionContext *searchCondition();

   
  };

  template<typename ContextT>
  ElementPatternWhereClauseContext* elementPatternWhereClause(ContextT* ctx) {
    ElementPatternWhereClauseContext *_localctx = _tracker.createInstance<ElementPatternWhereClauseContext>(_ctx, getState());
    enterRule(_localctx, 394, GQLParser::RuleElementPatternWhereClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2334);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::WHERE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::WHERE);
      setState(2335);
      {
        auto childCtxHolder = ctx->EnterSearchCondition();
        searchCondition(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ElementPropertySpecificationContext : public antlr4::ParserRuleContext {
  public:
    ElementPropertySpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_BRACE();
    PropertyKeyValuePairListContext *propertyKeyValuePairList();
    antlr4::tree::TerminalNode *RIGHT_BRACE();

   
  };

  template<typename ContextT>
  ElementPropertySpecificationContext* elementPropertySpecification(ContextT* ctx) {
    ElementPropertySpecificationContext *_localctx = _tracker.createInstance<ElementPropertySpecificationContext>(_ctx, getState());
    enterRule(_localctx, 396, GQLParser::RuleElementPropertySpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2337);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(2338);
      {
        auto childCtxHolder = ctx->EnterPropertyKeyValuePairList();
        propertyKeyValuePairList(get_raw_pointer(childCtxHolder));
      }
      setState(2339);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PropertyKeyValuePairListContext : public antlr4::ParserRuleContext {
  public:
    PropertyKeyValuePairListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<PropertyKeyValuePairContext *> propertyKeyValuePair();
    PropertyKeyValuePairContext* propertyKeyValuePair(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  PropertyKeyValuePairListContext* propertyKeyValuePairList(ContextT* ctx) {
    PropertyKeyValuePairListContext *_localctx = _tracker.createInstance<PropertyKeyValuePairListContext>(_ctx, getState());
    enterRule(_localctx, 398, GQLParser::RulePropertyKeyValuePairList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2341);
      {
        auto childCtxHolder = ctx->EnterPropertyKeyValuePair();
        propertyKeyValuePair(get_raw_pointer(childCtxHolder));
      }
      setState(2346);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(2342);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(2343);
        {
          auto childCtxHolder = ctx->EnterPropertyKeyValuePair();
          propertyKeyValuePair(get_raw_pointer(childCtxHolder));
        }
        setState(2348);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PropertyKeyValuePairContext : public antlr4::ParserRuleContext {
  public:
    PropertyKeyValuePairContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PropertyNameContext *propertyName();
    antlr4::tree::TerminalNode *COLON();
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  PropertyKeyValuePairContext* propertyKeyValuePair(ContextT* ctx) {
    PropertyKeyValuePairContext *_localctx = _tracker.createInstance<PropertyKeyValuePairContext>(_ctx, getState());
    enterRule(_localctx, 400, GQLParser::RulePropertyKeyValuePair);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2349);
      {
        auto childCtxHolder = ctx->EnterPropertyName();
        propertyName(get_raw_pointer(childCtxHolder));
      }
      setState(2350);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COLON) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COLON);
      setState(2351);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgePatternContext : public antlr4::ParserRuleContext {
  public:
    EdgePatternContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    FullEdgePatternContext *fullEdgePattern();
    AbbreviatedEdgePatternContext *abbreviatedEdgePattern();

   
  };

  template<typename ContextT>
  EdgePatternContext* edgePattern(ContextT* ctx) {
    EdgePatternContext *_localctx = _tracker.createInstance<EdgePatternContext>(_ctx, getState());
    enterRule(_localctx, 402, GQLParser::RuleEdgePattern);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2355);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LEFT_ARROW_BRACKET:
        case GQLParser::LEFT_ARROW_TILDE_BRACKET:
        case GQLParser::MINUS_LEFT_BRACKET:
        case GQLParser::TILDE_LEFT_BRACKET: {
          enterOuterAlt(_localctx, 1);
          setState(2353);
          {
            auto childCtxHolder = ctx->EnterFullEdgePattern();
            fullEdgePattern(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LEFT_ARROW:
        case GQLParser::LEFT_ARROW_TILDE:
        case GQLParser::LEFT_MINUS_RIGHT:
        case GQLParser::RIGHT_ARROW:
        case GQLParser::TILDE_RIGHT_ARROW:
        case GQLParser::MINUS_SIGN:
        case GQLParser::TILDE: {
          enterOuterAlt(_localctx, 2);
          setState(2354);
          {
            auto childCtxHolder = ctx->EnterAbbreviatedEdgePattern();
            abbreviatedEdgePattern(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FullEdgePatternContext : public antlr4::ParserRuleContext {
  public:
    FullEdgePatternContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    FullEdgePointingLeftContext *fullEdgePointingLeft();
    FullEdgeUndirectedContext *fullEdgeUndirected();
    FullEdgePointingRightContext *fullEdgePointingRight();
    FullEdgeLeftOrUndirectedContext *fullEdgeLeftOrUndirected();
    FullEdgeUndirectedOrRightContext *fullEdgeUndirectedOrRight();
    FullEdgeLeftOrRightContext *fullEdgeLeftOrRight();
    FullEdgeAnyDirectionContext *fullEdgeAnyDirection();

   
  };

  template<typename ContextT>
  FullEdgePatternContext* fullEdgePattern(ContextT* ctx) {
    FullEdgePatternContext *_localctx = _tracker.createInstance<FullEdgePatternContext>(_ctx, getState());
    enterRule(_localctx, 404, GQLParser::RuleFullEdgePattern);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2364);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2357);
        {
          auto childCtxHolder = ctx->EnterFullEdgePointingLeft();
          fullEdgePointingLeft(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2358);
        {
          auto childCtxHolder = ctx->EnterFullEdgeUndirected();
          fullEdgeUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2359);
        {
          auto childCtxHolder = ctx->EnterFullEdgePointingRight();
          fullEdgePointingRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(2360);
        {
          auto childCtxHolder = ctx->EnterFullEdgeLeftOrUndirected();
          fullEdgeLeftOrUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(2361);
        {
          auto childCtxHolder = ctx->EnterFullEdgeUndirectedOrRight();
          fullEdgeUndirectedOrRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(2362);
        {
          auto childCtxHolder = ctx->EnterFullEdgeLeftOrRight();
          fullEdgeLeftOrRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(2363);
        {
          auto childCtxHolder = ctx->EnterFullEdgeAnyDirection();
          fullEdgeAnyDirection(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FullEdgePointingLeftContext : public antlr4::ParserRuleContext {
  public:
    FullEdgePointingLeftContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_ARROW_BRACKET();
    ElementPatternFillerContext *elementPatternFiller();
    antlr4::tree::TerminalNode *RIGHT_BRACKET_MINUS();

   
  };

  template<typename ContextT>
  FullEdgePointingLeftContext* fullEdgePointingLeft(ContextT* ctx) {
    FullEdgePointingLeftContext *_localctx = _tracker.createInstance<FullEdgePointingLeftContext>(_ctx, getState());
    enterRule(_localctx, 406, GQLParser::RuleFullEdgePointingLeft);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2366);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ARROW_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ARROW_BRACKET);
      setState(2367);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2368);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_MINUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_MINUS);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FullEdgeUndirectedContext : public antlr4::ParserRuleContext {
  public:
    FullEdgeUndirectedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TILDE_LEFT_BRACKET();
    ElementPatternFillerContext *elementPatternFiller();
    antlr4::tree::TerminalNode *RIGHT_BRACKET_TILDE();

   
  };

  template<typename ContextT>
  FullEdgeUndirectedContext* fullEdgeUndirected(ContextT* ctx) {
    FullEdgeUndirectedContext *_localctx = _tracker.createInstance<FullEdgeUndirectedContext>(_ctx, getState());
    enterRule(_localctx, 408, GQLParser::RuleFullEdgeUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2370);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE_LEFT_BRACKET);
      setState(2371);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2372);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_TILDE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FullEdgePointingRightContext : public antlr4::ParserRuleContext {
  public:
    FullEdgePointingRightContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MINUS_LEFT_BRACKET();
    ElementPatternFillerContext *elementPatternFiller();
    antlr4::tree::TerminalNode *BRACKET_RIGHT_ARROW();

   
  };

  template<typename ContextT>
  FullEdgePointingRightContext* fullEdgePointingRight(ContextT* ctx) {
    FullEdgePointingRightContext *_localctx = _tracker.createInstance<FullEdgePointingRightContext>(_ctx, getState());
    enterRule(_localctx, 410, GQLParser::RuleFullEdgePointingRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2374);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MINUS_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MINUS_LEFT_BRACKET);
      setState(2375);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2376);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BRACKET_RIGHT_ARROW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BRACKET_RIGHT_ARROW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FullEdgeLeftOrUndirectedContext : public antlr4::ParserRuleContext {
  public:
    FullEdgeLeftOrUndirectedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_ARROW_TILDE_BRACKET();
    ElementPatternFillerContext *elementPatternFiller();
    antlr4::tree::TerminalNode *RIGHT_BRACKET_TILDE();

   
  };

  template<typename ContextT>
  FullEdgeLeftOrUndirectedContext* fullEdgeLeftOrUndirected(ContextT* ctx) {
    FullEdgeLeftOrUndirectedContext *_localctx = _tracker.createInstance<FullEdgeLeftOrUndirectedContext>(_ctx, getState());
    enterRule(_localctx, 412, GQLParser::RuleFullEdgeLeftOrUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2378);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ARROW_TILDE_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ARROW_TILDE_BRACKET);
      setState(2379);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2380);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_TILDE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FullEdgeUndirectedOrRightContext : public antlr4::ParserRuleContext {
  public:
    FullEdgeUndirectedOrRightContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TILDE_LEFT_BRACKET();
    ElementPatternFillerContext *elementPatternFiller();
    antlr4::tree::TerminalNode *BRACKET_TILDE_RIGHT_ARROW();

   
  };

  template<typename ContextT>
  FullEdgeUndirectedOrRightContext* fullEdgeUndirectedOrRight(ContextT* ctx) {
    FullEdgeUndirectedOrRightContext *_localctx = _tracker.createInstance<FullEdgeUndirectedOrRightContext>(_ctx, getState());
    enterRule(_localctx, 414, GQLParser::RuleFullEdgeUndirectedOrRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2382);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE_LEFT_BRACKET);
      setState(2383);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2384);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BRACKET_TILDE_RIGHT_ARROW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BRACKET_TILDE_RIGHT_ARROW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FullEdgeLeftOrRightContext : public antlr4::ParserRuleContext {
  public:
    FullEdgeLeftOrRightContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_ARROW_BRACKET();
    ElementPatternFillerContext *elementPatternFiller();
    antlr4::tree::TerminalNode *BRACKET_RIGHT_ARROW();

   
  };

  template<typename ContextT>
  FullEdgeLeftOrRightContext* fullEdgeLeftOrRight(ContextT* ctx) {
    FullEdgeLeftOrRightContext *_localctx = _tracker.createInstance<FullEdgeLeftOrRightContext>(_ctx, getState());
    enterRule(_localctx, 416, GQLParser::RuleFullEdgeLeftOrRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2386);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ARROW_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ARROW_BRACKET);
      setState(2387);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2388);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BRACKET_RIGHT_ARROW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BRACKET_RIGHT_ARROW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FullEdgeAnyDirectionContext : public antlr4::ParserRuleContext {
  public:
    FullEdgeAnyDirectionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MINUS_LEFT_BRACKET();
    ElementPatternFillerContext *elementPatternFiller();
    antlr4::tree::TerminalNode *RIGHT_BRACKET_MINUS();

   
  };

  template<typename ContextT>
  FullEdgeAnyDirectionContext* fullEdgeAnyDirection(ContextT* ctx) {
    FullEdgeAnyDirectionContext *_localctx = _tracker.createInstance<FullEdgeAnyDirectionContext>(_ctx, getState());
    enterRule(_localctx, 418, GQLParser::RuleFullEdgeAnyDirection);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2390);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MINUS_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MINUS_LEFT_BRACKET);
      setState(2391);
      {
        auto childCtxHolder = ctx->EnterElementPatternFiller();
        elementPatternFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2392);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_MINUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_MINUS);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  AbbreviatedEdgePatternContext : public antlr4::ParserRuleContext {
  public:
    AbbreviatedEdgePatternContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_ARROW();
    antlr4::tree::TerminalNode *TILDE();
    antlr4::tree::TerminalNode *RIGHT_ARROW();
    antlr4::tree::TerminalNode *LEFT_ARROW_TILDE();
    antlr4::tree::TerminalNode *TILDE_RIGHT_ARROW();
    antlr4::tree::TerminalNode *LEFT_MINUS_RIGHT();
    antlr4::tree::TerminalNode *MINUS_SIGN();

   
  };

  template<typename ContextT>
  AbbreviatedEdgePatternContext* abbreviatedEdgePattern(ContextT* ctx) {
    AbbreviatedEdgePatternContext *_localctx = _tracker.createInstance<AbbreviatedEdgePatternContext>(_ctx, getState());
    enterRule(_localctx, 420, GQLParser::RuleAbbreviatedEdgePattern);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2394);
      _la = _input->LA(1);
      if (!(((((_la - 336) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 336)) & 281612416714771) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ParenthesizedPathPatternExpressionContext : public antlr4::ParserRuleContext {
  public:
    ParenthesizedPathPatternExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    PathPatternExpressionContext *pathPatternExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    SubpathVariableDeclarationContext *subpathVariableDeclaration();
    PathModePrefixContext *pathModePrefix();
    ParenthesizedPathPatternWhereClauseContext *parenthesizedPathPatternWhereClause();

   
  };

  template<typename ContextT>
  ParenthesizedPathPatternExpressionContext* parenthesizedPathPatternExpression(ContextT* ctx) {
    ParenthesizedPathPatternExpressionContext *_localctx = _tracker.createInstance<ParenthesizedPathPatternExpressionContext>(_ctx, getState());
    enterRule(_localctx, 422, GQLParser::RuleParenthesizedPathPatternExpression);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2396);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(2398);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx)) {
      case 1: {
        setState(2397);
        {
          auto childCtxHolder = ctx->EnterSubpathVariableDeclaration();
          subpathVariableDeclaration(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2401);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 18159121727489) != 0)) {
        setState(2400);
        {
          auto childCtxHolder = ctx->EnterPathModePrefix();
          pathModePrefix(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2403);
      {
        auto childCtxHolder = ctx->EnterPathPatternExpression();
        pathPatternExpression(get_raw_pointer(childCtxHolder));
      }
      setState(2405);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::WHERE) {
        setState(2404);
        {
          auto childCtxHolder = ctx->EnterParenthesizedPathPatternWhereClause();
          parenthesizedPathPatternWhereClause(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2407);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SubpathVariableDeclarationContext : public antlr4::ParserRuleContext {
  public:
    SubpathVariableDeclarationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SubpathVariableContext *subpathVariable();
    antlr4::tree::TerminalNode *EQUALS_OPERATOR();

   
  };

  template<typename ContextT>
  SubpathVariableDeclarationContext* subpathVariableDeclaration(ContextT* ctx) {
    SubpathVariableDeclarationContext *_localctx = _tracker.createInstance<SubpathVariableDeclarationContext>(_ctx, getState());
    enterRule(_localctx, 424, GQLParser::RuleSubpathVariableDeclaration);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2409);
      {
        auto childCtxHolder = ctx->EnterSubpathVariable();
        subpathVariable(get_raw_pointer(childCtxHolder));
      }
      setState(2410);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EQUALS_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EQUALS_OPERATOR);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ParenthesizedPathPatternWhereClauseContext : public antlr4::ParserRuleContext {
  public:
    ParenthesizedPathPatternWhereClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHERE();
    SearchConditionContext *searchCondition();

   
  };

  template<typename ContextT>
  ParenthesizedPathPatternWhereClauseContext* parenthesizedPathPatternWhereClause(ContextT* ctx) {
    ParenthesizedPathPatternWhereClauseContext *_localctx = _tracker.createInstance<ParenthesizedPathPatternWhereClauseContext>(_ctx, getState());
    enterRule(_localctx, 426, GQLParser::RuleParenthesizedPathPatternWhereClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2412);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::WHERE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::WHERE);
      setState(2413);
      {
        auto childCtxHolder = ctx->EnterSearchCondition();
        searchCondition(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LabelExpressionContext : public antlr4::ParserRuleContext {
  public:
    LabelExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
   
    LabelExpressionContext() = default;
    void copyFrom(LabelExpressionContext *context);
    using antlr4::ParserRuleContext::copyFrom;

    virtual size_t getRuleIndex() const override;

   
  };

  class  LabelExpressionNegationContext : public LabelExpressionContext {
  public:
    LabelExpressionNegationContext(LabelExpressionContext *ctx);

    antlr4::tree::TerminalNode *EXCLAMATION_MARK();
    LabelExpressionContext *labelExpression();
  };

  class  LabelExpressionDisjunctionContext : public LabelExpressionContext {
  public:
    LabelExpressionDisjunctionContext(LabelExpressionContext *ctx);

    std::vector<LabelExpressionContext *> labelExpression();
    LabelExpressionContext* labelExpression(size_t i);
    antlr4::tree::TerminalNode *VERTICAL_BAR();
  };

  class  LabelExpressionParenthesizedContext : public LabelExpressionContext {
  public:
    LabelExpressionParenthesizedContext(LabelExpressionContext *ctx);

    antlr4::tree::TerminalNode *LEFT_PAREN();
    LabelExpressionContext *labelExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
  };

  class  LabelExpressionWildcardContext : public LabelExpressionContext {
  public:
    LabelExpressionWildcardContext(LabelExpressionContext *ctx);

    antlr4::tree::TerminalNode *PERCENT();
  };

  class  LabelExpressionConjunctionContext : public LabelExpressionContext {
  public:
    LabelExpressionConjunctionContext(LabelExpressionContext *ctx);

    std::vector<LabelExpressionContext *> labelExpression();
    LabelExpressionContext* labelExpression(size_t i);
    antlr4::tree::TerminalNode *AMPERSAND();
  };

  class  LabelExpressionNameContext : public LabelExpressionContext {
  public:
    LabelExpressionNameContext(LabelExpressionContext *ctx);

    LabelNameContext *labelName();
  };


  template<typename ContextT>
  LabelExpressionContext* labelExpression(ContextT* ctx) {
     return labelExpression(0, ctx);
  }

  template<typename ContextT>
  LabelExpressionContext* labelExpression(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    GQLParser::LabelExpressionContext *_localctx = _tracker.createInstance<LabelExpressionContext>(_ctx, parentState);
    GQLParser::LabelExpressionContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 428;
    enterRecursionRule(_localctx, 428, GQLParser::RuleLabelExpression, precedence);

      

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(2424);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::EXCLAMATION_MARK: {
          _localctx = _tracker.createInstance<LabelExpressionNegationContext>(_localctx);
          _ctx = _localctx;
          previousContext = _localctx;
          auto ctxHolder = ctx->EnterLabelExpressionNegation();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });

          setState(2416);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::EXCLAMATION_MARK) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::EXCLAMATION_MARK);
          setState(2417);
          {
            auto childCtxHolder = ctx->EnterLabelExpression();
            labelExpression(6, get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          _localctx = _tracker.createInstance<LabelExpressionNameContext>(_localctx);
          _ctx = _localctx;
          previousContext = _localctx;
          auto ctxHolder = ctx->EnterLabelExpressionName();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          setState(2418);
          {
            auto childCtxHolder = ctx->EnterLabelName();
            labelName(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::PERCENT: {
          _localctx = _tracker.createInstance<LabelExpressionWildcardContext>(_localctx);
          _ctx = _localctx;
          previousContext = _localctx;
          auto ctxHolder = ctx->EnterLabelExpressionWildcard();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          setState(2419);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::PERCENT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::PERCENT);
          break;
        }

        case GQLParser::LEFT_PAREN: {
          _localctx = _tracker.createInstance<LabelExpressionParenthesizedContext>(_localctx);
          _ctx = _localctx;
          previousContext = _localctx;
          auto ctxHolder = ctx->EnterLabelExpressionParenthesized();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          setState(2420);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(2421);
          {
            auto childCtxHolder = ctx->EnterLabelExpression();
            labelExpression(0, get_raw_pointer(childCtxHolder));
          }
          setState(2422);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
      _ctx->stop = _input->LT(-1);
      setState(2434);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 210, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          setState(2432);
          _errHandler->sync(this);
          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 209, _ctx)) {
          case 1: {
            auto newContext = _tracker.createInstance<LabelExpressionConjunctionContext>(_tracker.createInstance<LabelExpressionContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleLabelExpression);
            auto ctxHolder = ctx->PushLabelExpressionConjunction_LabelExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(2426);

            if (!(precpred(_ctx, 5))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 5)");
            setState(2427);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::AMPERSAND) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::AMPERSAND);
            setState(2428);
            {
              auto childCtxHolder = ctx->EnterLabelExpression();
              labelExpression(6, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 2: {
            auto newContext = _tracker.createInstance<LabelExpressionDisjunctionContext>(_tracker.createInstance<LabelExpressionContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleLabelExpression);
            auto ctxHolder = ctx->PushLabelExpressionDisjunction_LabelExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(2429);

            if (!(precpred(_ctx, 4))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 4)");
            setState(2430);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::VERTICAL_BAR) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::VERTICAL_BAR);
            setState(2431);
            {
              auto childCtxHolder = ctx->EnterLabelExpression();
              labelExpression(5, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          } 
        }
        setState(2436);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 210, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }

  class  PathVariableReferenceContext : public antlr4::ParserRuleContext {
  public:
    PathVariableReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BindingVariableReferenceContext *bindingVariableReference();

   
  };

  template<typename ContextT>
  PathVariableReferenceContext* pathVariableReference(ContextT* ctx) {
    PathVariableReferenceContext *_localctx = _tracker.createInstance<PathVariableReferenceContext>(_ctx, getState());
    enterRule(_localctx, 430, GQLParser::RulePathVariableReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2437);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ElementVariableReferenceContext : public antlr4::ParserRuleContext {
  public:
    ElementVariableReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BindingVariableReferenceContext *bindingVariableReference();

   
  };

  template<typename ContextT>
  ElementVariableReferenceContext* elementVariableReference(ContextT* ctx) {
    ElementVariableReferenceContext *_localctx = _tracker.createInstance<ElementVariableReferenceContext>(_ctx, getState());
    enterRule(_localctx, 432, GQLParser::RuleElementVariableReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2439);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphPatternQuantifierContext : public antlr4::ParserRuleContext {
  public:
    GraphPatternQuantifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ASTERISK();
    antlr4::tree::TerminalNode *PLUS_SIGN();
    FixedQuantifierContext *fixedQuantifier();
    GeneralQuantifierContext *generalQuantifier();

   
  };

  template<typename ContextT>
  GraphPatternQuantifierContext* graphPatternQuantifier(ContextT* ctx) {
    GraphPatternQuantifierContext *_localctx = _tracker.createInstance<GraphPatternQuantifierContext>(_ctx, getState());
    enterRule(_localctx, 434, GQLParser::RuleGraphPatternQuantifier);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2445);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 211, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2441);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::ASTERISK) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::ASTERISK);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2442);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PLUS_SIGN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PLUS_SIGN);
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2443);
        {
          auto childCtxHolder = ctx->EnterFixedQuantifier();
          fixedQuantifier(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(2444);
        {
          auto childCtxHolder = ctx->EnterGeneralQuantifier();
          generalQuantifier(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FixedQuantifierContext : public antlr4::ParserRuleContext {
  public:
    FixedQuantifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_BRACE();
    UnsignedIntegerContext *unsignedInteger();
    antlr4::tree::TerminalNode *RIGHT_BRACE();

   
  };

  template<typename ContextT>
  FixedQuantifierContext* fixedQuantifier(ContextT* ctx) {
    FixedQuantifierContext *_localctx = _tracker.createInstance<FixedQuantifierContext>(_ctx, getState());
    enterRule(_localctx, 436, GQLParser::RuleFixedQuantifier);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2447);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(2448);
      {
        auto childCtxHolder = ctx->EnterUnsignedInteger();
        unsignedInteger(get_raw_pointer(childCtxHolder));
      }
      setState(2449);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GeneralQuantifierContext : public antlr4::ParserRuleContext {
  public:
    GeneralQuantifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_BRACE();
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *RIGHT_BRACE();
    LowerBoundContext *lowerBound();
    UpperBoundContext *upperBound();

   
  };

  template<typename ContextT>
  GeneralQuantifierContext* generalQuantifier(ContextT* ctx) {
    GeneralQuantifierContext *_localctx = _tracker.createInstance<GeneralQuantifierContext>(_ctx, getState());
    enterRule(_localctx, 438, GQLParser::RuleGeneralQuantifier);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2451);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(2453);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 983040) != 0)) {
        setState(2452);
        {
          auto childCtxHolder = ctx->EnterLowerBound();
          lowerBound(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2455);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(2457);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 983040) != 0)) {
        setState(2456);
        {
          auto childCtxHolder = ctx->EnterUpperBound();
          upperBound(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2459);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LowerBoundContext : public antlr4::ParserRuleContext {
  public:
    LowerBoundContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UnsignedIntegerContext *unsignedInteger();

   
  };

  template<typename ContextT>
  LowerBoundContext* lowerBound(ContextT* ctx) {
    LowerBoundContext *_localctx = _tracker.createInstance<LowerBoundContext>(_ctx, getState());
    enterRule(_localctx, 440, GQLParser::RuleLowerBound);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2461);
      {
        auto childCtxHolder = ctx->EnterUnsignedInteger();
        unsignedInteger(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  UpperBoundContext : public antlr4::ParserRuleContext {
  public:
    UpperBoundContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UnsignedIntegerContext *unsignedInteger();

   
  };

  template<typename ContextT>
  UpperBoundContext* upperBound(ContextT* ctx) {
    UpperBoundContext *_localctx = _tracker.createInstance<UpperBoundContext>(_ctx, getState());
    enterRule(_localctx, 442, GQLParser::RuleUpperBound);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2463);
      {
        auto childCtxHolder = ctx->EnterUnsignedInteger();
        unsignedInteger(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedPathPatternExpressionContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedPathPatternExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SimplifiedDefaultingLeftContext *simplifiedDefaultingLeft();
    SimplifiedDefaultingUndirectedContext *simplifiedDefaultingUndirected();
    SimplifiedDefaultingRightContext *simplifiedDefaultingRight();
    SimplifiedDefaultingLeftOrUndirectedContext *simplifiedDefaultingLeftOrUndirected();
    SimplifiedDefaultingUndirectedOrRightContext *simplifiedDefaultingUndirectedOrRight();
    SimplifiedDefaultingLeftOrRightContext *simplifiedDefaultingLeftOrRight();
    SimplifiedDefaultingAnyDirectionContext *simplifiedDefaultingAnyDirection();

   
  };

  template<typename ContextT>
  SimplifiedPathPatternExpressionContext* simplifiedPathPatternExpression(ContextT* ctx) {
    SimplifiedPathPatternExpressionContext *_localctx = _tracker.createInstance<SimplifiedPathPatternExpressionContext>(_ctx, getState());
    enterRule(_localctx, 444, GQLParser::RuleSimplifiedPathPatternExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2472);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 214, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2465);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDefaultingLeft();
          simplifiedDefaultingLeft(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2466);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDefaultingUndirected();
          simplifiedDefaultingUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2467);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDefaultingRight();
          simplifiedDefaultingRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(2468);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDefaultingLeftOrUndirected();
          simplifiedDefaultingLeftOrUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(2469);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDefaultingUndirectedOrRight();
          simplifiedDefaultingUndirectedOrRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(2470);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDefaultingLeftOrRight();
          simplifiedDefaultingLeftOrRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(2471);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDefaultingAnyDirection();
          simplifiedDefaultingAnyDirection(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedDefaultingLeftContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedDefaultingLeftContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_MINUS_SLASH();
    SimplifiedContentsContext *simplifiedContents();
    antlr4::tree::TerminalNode *SLASH_MINUS();

   
  };

  template<typename ContextT>
  SimplifiedDefaultingLeftContext* simplifiedDefaultingLeft(ContextT* ctx) {
    SimplifiedDefaultingLeftContext *_localctx = _tracker.createInstance<SimplifiedDefaultingLeftContext>(_ctx, getState());
    enterRule(_localctx, 446, GQLParser::RuleSimplifiedDefaultingLeft);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2474);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_MINUS_SLASH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_MINUS_SLASH);
      setState(2475);
      {
        auto childCtxHolder = ctx->EnterSimplifiedContents();
        simplifiedContents(get_raw_pointer(childCtxHolder));
      }
      setState(2476);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SLASH_MINUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SLASH_MINUS);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedDefaultingUndirectedContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedDefaultingUndirectedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TILDE_SLASH();
    SimplifiedContentsContext *simplifiedContents();
    antlr4::tree::TerminalNode *SLASH_TILDE();

   
  };

  template<typename ContextT>
  SimplifiedDefaultingUndirectedContext* simplifiedDefaultingUndirected(ContextT* ctx) {
    SimplifiedDefaultingUndirectedContext *_localctx = _tracker.createInstance<SimplifiedDefaultingUndirectedContext>(_ctx, getState());
    enterRule(_localctx, 448, GQLParser::RuleSimplifiedDefaultingUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2478);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE_SLASH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE_SLASH);
      setState(2479);
      {
        auto childCtxHolder = ctx->EnterSimplifiedContents();
        simplifiedContents(get_raw_pointer(childCtxHolder));
      }
      setState(2480);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SLASH_TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SLASH_TILDE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedDefaultingRightContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedDefaultingRightContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MINUS_SLASH();
    SimplifiedContentsContext *simplifiedContents();
    antlr4::tree::TerminalNode *SLASH_MINUS_RIGHT();

   
  };

  template<typename ContextT>
  SimplifiedDefaultingRightContext* simplifiedDefaultingRight(ContextT* ctx) {
    SimplifiedDefaultingRightContext *_localctx = _tracker.createInstance<SimplifiedDefaultingRightContext>(_ctx, getState());
    enterRule(_localctx, 450, GQLParser::RuleSimplifiedDefaultingRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2482);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MINUS_SLASH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MINUS_SLASH);
      setState(2483);
      {
        auto childCtxHolder = ctx->EnterSimplifiedContents();
        simplifiedContents(get_raw_pointer(childCtxHolder));
      }
      setState(2484);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SLASH_MINUS_RIGHT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SLASH_MINUS_RIGHT);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedDefaultingLeftOrUndirectedContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedDefaultingLeftOrUndirectedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_TILDE_SLASH();
    SimplifiedContentsContext *simplifiedContents();
    antlr4::tree::TerminalNode *SLASH_TILDE();

   
  };

  template<typename ContextT>
  SimplifiedDefaultingLeftOrUndirectedContext* simplifiedDefaultingLeftOrUndirected(ContextT* ctx) {
    SimplifiedDefaultingLeftOrUndirectedContext *_localctx = _tracker.createInstance<SimplifiedDefaultingLeftOrUndirectedContext>(_ctx, getState());
    enterRule(_localctx, 452, GQLParser::RuleSimplifiedDefaultingLeftOrUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2486);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_TILDE_SLASH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_TILDE_SLASH);
      setState(2487);
      {
        auto childCtxHolder = ctx->EnterSimplifiedContents();
        simplifiedContents(get_raw_pointer(childCtxHolder));
      }
      setState(2488);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SLASH_TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SLASH_TILDE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedDefaultingUndirectedOrRightContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedDefaultingUndirectedOrRightContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TILDE_SLASH();
    SimplifiedContentsContext *simplifiedContents();
    antlr4::tree::TerminalNode *SLASH_TILDE_RIGHT();

   
  };

  template<typename ContextT>
  SimplifiedDefaultingUndirectedOrRightContext* simplifiedDefaultingUndirectedOrRight(ContextT* ctx) {
    SimplifiedDefaultingUndirectedOrRightContext *_localctx = _tracker.createInstance<SimplifiedDefaultingUndirectedOrRightContext>(_ctx, getState());
    enterRule(_localctx, 454, GQLParser::RuleSimplifiedDefaultingUndirectedOrRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2490);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE_SLASH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE_SLASH);
      setState(2491);
      {
        auto childCtxHolder = ctx->EnterSimplifiedContents();
        simplifiedContents(get_raw_pointer(childCtxHolder));
      }
      setState(2492);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SLASH_TILDE_RIGHT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SLASH_TILDE_RIGHT);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedDefaultingLeftOrRightContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedDefaultingLeftOrRightContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_MINUS_SLASH();
    SimplifiedContentsContext *simplifiedContents();
    antlr4::tree::TerminalNode *SLASH_MINUS_RIGHT();

   
  };

  template<typename ContextT>
  SimplifiedDefaultingLeftOrRightContext* simplifiedDefaultingLeftOrRight(ContextT* ctx) {
    SimplifiedDefaultingLeftOrRightContext *_localctx = _tracker.createInstance<SimplifiedDefaultingLeftOrRightContext>(_ctx, getState());
    enterRule(_localctx, 456, GQLParser::RuleSimplifiedDefaultingLeftOrRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2494);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_MINUS_SLASH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_MINUS_SLASH);
      setState(2495);
      {
        auto childCtxHolder = ctx->EnterSimplifiedContents();
        simplifiedContents(get_raw_pointer(childCtxHolder));
      }
      setState(2496);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SLASH_MINUS_RIGHT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SLASH_MINUS_RIGHT);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedDefaultingAnyDirectionContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedDefaultingAnyDirectionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MINUS_SLASH();
    SimplifiedContentsContext *simplifiedContents();
    antlr4::tree::TerminalNode *SLASH_MINUS();

   
  };

  template<typename ContextT>
  SimplifiedDefaultingAnyDirectionContext* simplifiedDefaultingAnyDirection(ContextT* ctx) {
    SimplifiedDefaultingAnyDirectionContext *_localctx = _tracker.createInstance<SimplifiedDefaultingAnyDirectionContext>(_ctx, getState());
    enterRule(_localctx, 458, GQLParser::RuleSimplifiedDefaultingAnyDirection);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2498);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MINUS_SLASH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MINUS_SLASH);
      setState(2499);
      {
        auto childCtxHolder = ctx->EnterSimplifiedContents();
        simplifiedContents(get_raw_pointer(childCtxHolder));
      }
      setState(2500);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SLASH_MINUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SLASH_MINUS);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedContentsContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedContentsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SimplifiedTermContext *simplifiedTerm();
    SimplifiedPathUnionContext *simplifiedPathUnion();
    SimplifiedMultisetAlternationContext *simplifiedMultisetAlternation();

   
  };

  template<typename ContextT>
  SimplifiedContentsContext* simplifiedContents(ContextT* ctx) {
    SimplifiedContentsContext *_localctx = _tracker.createInstance<SimplifiedContentsContext>(_ctx, getState());
    enterRule(_localctx, 460, GQLParser::RuleSimplifiedContents);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2505);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2502);
        {
          auto childCtxHolder = ctx->EnterSimplifiedTerm();
          simplifiedTerm(0, get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2503);
        {
          auto childCtxHolder = ctx->EnterSimplifiedPathUnion();
          simplifiedPathUnion(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2504);
        {
          auto childCtxHolder = ctx->EnterSimplifiedMultisetAlternation();
          simplifiedMultisetAlternation(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedPathUnionContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedPathUnionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<SimplifiedTermContext *> simplifiedTerm();
    SimplifiedTermContext* simplifiedTerm(size_t i);
    std::vector<antlr4::tree::TerminalNode *> VERTICAL_BAR();
    antlr4::tree::TerminalNode* VERTICAL_BAR(size_t i);

   
  };

  template<typename ContextT>
  SimplifiedPathUnionContext* simplifiedPathUnion(ContextT* ctx) {
    SimplifiedPathUnionContext *_localctx = _tracker.createInstance<SimplifiedPathUnionContext>(_ctx, getState());
    enterRule(_localctx, 462, GQLParser::RuleSimplifiedPathUnion);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2507);
      {
        auto childCtxHolder = ctx->EnterSimplifiedTerm();
        simplifiedTerm(0, get_raw_pointer(childCtxHolder));
      }
      setState(2508);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::VERTICAL_BAR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::VERTICAL_BAR);
      setState(2509);
      {
        auto childCtxHolder = ctx->EnterSimplifiedTerm();
        simplifiedTerm(0, get_raw_pointer(childCtxHolder));
      }
      setState(2514);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::VERTICAL_BAR) {
        setState(2510);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::VERTICAL_BAR) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::VERTICAL_BAR);
        setState(2511);
        {
          auto childCtxHolder = ctx->EnterSimplifiedTerm();
          simplifiedTerm(0, get_raw_pointer(childCtxHolder));
        }
        setState(2516);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedMultisetAlternationContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedMultisetAlternationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<SimplifiedTermContext *> simplifiedTerm();
    SimplifiedTermContext* simplifiedTerm(size_t i);
    std::vector<antlr4::tree::TerminalNode *> MULTISET_ALTERNATION_OPERATOR();
    antlr4::tree::TerminalNode* MULTISET_ALTERNATION_OPERATOR(size_t i);

   
  };

  template<typename ContextT>
  SimplifiedMultisetAlternationContext* simplifiedMultisetAlternation(ContextT* ctx) {
    SimplifiedMultisetAlternationContext *_localctx = _tracker.createInstance<SimplifiedMultisetAlternationContext>(_ctx, getState());
    enterRule(_localctx, 464, GQLParser::RuleSimplifiedMultisetAlternation);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2517);
      {
        auto childCtxHolder = ctx->EnterSimplifiedTerm();
        simplifiedTerm(0, get_raw_pointer(childCtxHolder));
      }
      setState(2518);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MULTISET_ALTERNATION_OPERATOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MULTISET_ALTERNATION_OPERATOR);
      setState(2519);
      {
        auto childCtxHolder = ctx->EnterSimplifiedTerm();
        simplifiedTerm(0, get_raw_pointer(childCtxHolder));
      }
      setState(2524);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::MULTISET_ALTERNATION_OPERATOR) {
        setState(2520);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::MULTISET_ALTERNATION_OPERATOR) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::MULTISET_ALTERNATION_OPERATOR);
        setState(2521);
        {
          auto childCtxHolder = ctx->EnterSimplifiedTerm();
          simplifiedTerm(0, get_raw_pointer(childCtxHolder));
        }
        setState(2526);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedTermContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedTermContext(antlr4::ParserRuleContext *parent, size_t invokingState);
   
    SimplifiedTermContext() = default;
    void copyFrom(SimplifiedTermContext *context);
    using antlr4::ParserRuleContext::copyFrom;

    virtual size_t getRuleIndex() const override;

   
  };

  class  SimplifiedFactorLowLabelContext : public SimplifiedTermContext {
  public:
    SimplifiedFactorLowLabelContext(SimplifiedTermContext *ctx);

    SimplifiedFactorLowContext *simplifiedFactorLow();
  };

  class  SimplifiedConcatenationLabelContext : public SimplifiedTermContext {
  public:
    SimplifiedConcatenationLabelContext(SimplifiedTermContext *ctx);

    SimplifiedTermContext *simplifiedTerm();
    SimplifiedFactorLowContext *simplifiedFactorLow();
  };


  template<typename ContextT>
  SimplifiedTermContext* simplifiedTerm(ContextT* ctx) {
     return simplifiedTerm(0, ctx);
  }

  template<typename ContextT>
  SimplifiedTermContext* simplifiedTerm(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    GQLParser::SimplifiedTermContext *_localctx = _tracker.createInstance<SimplifiedTermContext>(_ctx, parentState);
    GQLParser::SimplifiedTermContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 466;
    enterRecursionRule(_localctx, 466, GQLParser::RuleSimplifiedTerm, precedence);

      

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      _localctx = _tracker.createInstance<SimplifiedFactorLowLabelContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      auto ctxHolder = ctx->EnterSimplifiedFactorLowLabel();
      auto ctx = get_raw_pointer(ctxHolder);
      auto onExit = antlrcpp::finally([ctx, _localctx] {
        (void)_localctx;
        if constexpr (has_ExitRule<decltype(ctx)>::value)
          ctx->ExitRule(_localctx);
        else
          (void)ctx;
      });

      setState(2528);
      {
        auto childCtxHolder = ctx->EnterSimplifiedFactorLow();
        simplifiedFactorLow(0, get_raw_pointer(childCtxHolder));
      }
      _ctx->stop = _input->LT(-1);
      setState(2534);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          auto newContext = _tracker.createInstance<SimplifiedConcatenationLabelContext>(_tracker.createInstance<SimplifiedTermContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimplifiedTerm);
          auto ctxHolder = ctx->PushSimplifiedConcatenationLabel_SimplifiedTerm();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          setState(2530);

          if (!(precpred(_ctx, 1))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(2531);
          {
            auto childCtxHolder = ctx->EnterSimplifiedFactorLow();
            simplifiedFactorLow(0, get_raw_pointer(childCtxHolder));
          } 
        }
        setState(2536);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }

  class  SimplifiedFactorLowContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedFactorLowContext(antlr4::ParserRuleContext *parent, size_t invokingState);
   
    SimplifiedFactorLowContext() = default;
    void copyFrom(SimplifiedFactorLowContext *context);
    using antlr4::ParserRuleContext::copyFrom;

    virtual size_t getRuleIndex() const override;

   
  };

  class  SimplifiedConjunctionLabelContext : public SimplifiedFactorLowContext {
  public:
    SimplifiedConjunctionLabelContext(SimplifiedFactorLowContext *ctx);

    SimplifiedFactorLowContext *simplifiedFactorLow();
    antlr4::tree::TerminalNode *AMPERSAND();
    SimplifiedFactorHighContext *simplifiedFactorHigh();
  };

  class  SimplifiedFactorHighLabelContext : public SimplifiedFactorLowContext {
  public:
    SimplifiedFactorHighLabelContext(SimplifiedFactorLowContext *ctx);

    SimplifiedFactorHighContext *simplifiedFactorHigh();
  };


  template<typename ContextT>
  SimplifiedFactorLowContext* simplifiedFactorLow(ContextT* ctx) {
     return simplifiedFactorLow(0, ctx);
  }

  template<typename ContextT>
  SimplifiedFactorLowContext* simplifiedFactorLow(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    GQLParser::SimplifiedFactorLowContext *_localctx = _tracker.createInstance<SimplifiedFactorLowContext>(_ctx, parentState);
    GQLParser::SimplifiedFactorLowContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 468;
    enterRecursionRule(_localctx, 468, GQLParser::RuleSimplifiedFactorLow, precedence);

      

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      _localctx = _tracker.createInstance<SimplifiedFactorHighLabelContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      auto ctxHolder = ctx->EnterSimplifiedFactorHighLabel();
      auto ctx = get_raw_pointer(ctxHolder);
      auto onExit = antlrcpp::finally([ctx, _localctx] {
        (void)_localctx;
        if constexpr (has_ExitRule<decltype(ctx)>::value)
          ctx->ExitRule(_localctx);
        else
          (void)ctx;
      });

      setState(2538);
      {
        auto childCtxHolder = ctx->EnterSimplifiedFactorHigh();
        simplifiedFactorHigh(get_raw_pointer(childCtxHolder));
      }
      _ctx->stop = _input->LT(-1);
      setState(2545);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          auto newContext = _tracker.createInstance<SimplifiedConjunctionLabelContext>(_tracker.createInstance<SimplifiedFactorLowContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimplifiedFactorLow);
          auto ctxHolder = ctx->PushSimplifiedConjunctionLabel_SimplifiedFactorLow();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          setState(2540);

          if (!(precpred(_ctx, 1))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(2541);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::AMPERSAND) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::AMPERSAND);
          setState(2542);
          {
            auto childCtxHolder = ctx->EnterSimplifiedFactorHigh();
            simplifiedFactorHigh(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(2547);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }

  class  SimplifiedFactorHighContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedFactorHighContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SimplifiedTertiaryContext *simplifiedTertiary();
    SimplifiedQuantifiedContext *simplifiedQuantified();
    SimplifiedQuestionedContext *simplifiedQuestioned();

   
  };

  template<typename ContextT>
  SimplifiedFactorHighContext* simplifiedFactorHigh(ContextT* ctx) {
    SimplifiedFactorHighContext *_localctx = _tracker.createInstance<SimplifiedFactorHighContext>(_ctx, getState());
    enterRule(_localctx, 470, GQLParser::RuleSimplifiedFactorHigh);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2551);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 220, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2548);
        {
          auto childCtxHolder = ctx->EnterSimplifiedTertiary();
          simplifiedTertiary(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2549);
        {
          auto childCtxHolder = ctx->EnterSimplifiedQuantified();
          simplifiedQuantified(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2550);
        {
          auto childCtxHolder = ctx->EnterSimplifiedQuestioned();
          simplifiedQuestioned(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedQuantifiedContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedQuantifiedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SimplifiedTertiaryContext *simplifiedTertiary();
    GraphPatternQuantifierContext *graphPatternQuantifier();

   
  };

  template<typename ContextT>
  SimplifiedQuantifiedContext* simplifiedQuantified(ContextT* ctx) {
    SimplifiedQuantifiedContext *_localctx = _tracker.createInstance<SimplifiedQuantifiedContext>(_ctx, getState());
    enterRule(_localctx, 472, GQLParser::RuleSimplifiedQuantified);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2553);
      {
        auto childCtxHolder = ctx->EnterSimplifiedTertiary();
        simplifiedTertiary(get_raw_pointer(childCtxHolder));
      }
      setState(2554);
      {
        auto childCtxHolder = ctx->EnterGraphPatternQuantifier();
        graphPatternQuantifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedQuestionedContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedQuestionedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SimplifiedTertiaryContext *simplifiedTertiary();
    antlr4::tree::TerminalNode *QUESTION_MARK();

   
  };

  template<typename ContextT>
  SimplifiedQuestionedContext* simplifiedQuestioned(ContextT* ctx) {
    SimplifiedQuestionedContext *_localctx = _tracker.createInstance<SimplifiedQuestionedContext>(_ctx, getState());
    enterRule(_localctx, 474, GQLParser::RuleSimplifiedQuestioned);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2556);
      {
        auto childCtxHolder = ctx->EnterSimplifiedTertiary();
        simplifiedTertiary(get_raw_pointer(childCtxHolder));
      }
      setState(2557);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::QUESTION_MARK) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::QUESTION_MARK);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedTertiaryContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedTertiaryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SimplifiedDirectionOverrideContext *simplifiedDirectionOverride();
    SimplifiedSecondaryContext *simplifiedSecondary();

   
  };

  template<typename ContextT>
  SimplifiedTertiaryContext* simplifiedTertiary(ContextT* ctx) {
    SimplifiedTertiaryContext *_localctx = _tracker.createInstance<SimplifiedTertiaryContext>(_ctx, getState());
    enterRule(_localctx, 476, GQLParser::RuleSimplifiedTertiary);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2561);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2559);
        {
          auto childCtxHolder = ctx->EnterSimplifiedDirectionOverride();
          simplifiedDirectionOverride(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2560);
        {
          auto childCtxHolder = ctx->EnterSimplifiedSecondary();
          simplifiedSecondary(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedDirectionOverrideContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedDirectionOverrideContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SimplifiedOverrideLeftContext *simplifiedOverrideLeft();
    SimplifiedOverrideUndirectedContext *simplifiedOverrideUndirected();
    SimplifiedOverrideRightContext *simplifiedOverrideRight();
    SimplifiedOverrideLeftOrUndirectedContext *simplifiedOverrideLeftOrUndirected();
    SimplifiedOverrideUndirectedOrRightContext *simplifiedOverrideUndirectedOrRight();
    SimplifiedOverrideLeftOrRightContext *simplifiedOverrideLeftOrRight();
    SimplifiedOverrideAnyDirectionContext *simplifiedOverrideAnyDirection();

   
  };

  template<typename ContextT>
  SimplifiedDirectionOverrideContext* simplifiedDirectionOverride(ContextT* ctx) {
    SimplifiedDirectionOverrideContext *_localctx = _tracker.createInstance<SimplifiedDirectionOverrideContext>(_ctx, getState());
    enterRule(_localctx, 478, GQLParser::RuleSimplifiedDirectionOverride);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2570);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 222, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2563);
        {
          auto childCtxHolder = ctx->EnterSimplifiedOverrideLeft();
          simplifiedOverrideLeft(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2564);
        {
          auto childCtxHolder = ctx->EnterSimplifiedOverrideUndirected();
          simplifiedOverrideUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2565);
        {
          auto childCtxHolder = ctx->EnterSimplifiedOverrideRight();
          simplifiedOverrideRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(2566);
        {
          auto childCtxHolder = ctx->EnterSimplifiedOverrideLeftOrUndirected();
          simplifiedOverrideLeftOrUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(2567);
        {
          auto childCtxHolder = ctx->EnterSimplifiedOverrideUndirectedOrRight();
          simplifiedOverrideUndirectedOrRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(2568);
        {
          auto childCtxHolder = ctx->EnterSimplifiedOverrideLeftOrRight();
          simplifiedOverrideLeftOrRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(2569);
        {
          auto childCtxHolder = ctx->EnterSimplifiedOverrideAnyDirection();
          simplifiedOverrideAnyDirection(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedOverrideLeftContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedOverrideLeftContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_ANGLE_BRACKET();
    SimplifiedSecondaryContext *simplifiedSecondary();

   
  };

  template<typename ContextT>
  SimplifiedOverrideLeftContext* simplifiedOverrideLeft(ContextT* ctx) {
    SimplifiedOverrideLeftContext *_localctx = _tracker.createInstance<SimplifiedOverrideLeftContext>(_ctx, getState());
    enterRule(_localctx, 480, GQLParser::RuleSimplifiedOverrideLeft);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2572);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ANGLE_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ANGLE_BRACKET);
      setState(2573);
      {
        auto childCtxHolder = ctx->EnterSimplifiedSecondary();
        simplifiedSecondary(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedOverrideUndirectedContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedOverrideUndirectedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TILDE();
    SimplifiedSecondaryContext *simplifiedSecondary();

   
  };

  template<typename ContextT>
  SimplifiedOverrideUndirectedContext* simplifiedOverrideUndirected(ContextT* ctx) {
    SimplifiedOverrideUndirectedContext *_localctx = _tracker.createInstance<SimplifiedOverrideUndirectedContext>(_ctx, getState());
    enterRule(_localctx, 482, GQLParser::RuleSimplifiedOverrideUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2575);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE);
      setState(2576);
      {
        auto childCtxHolder = ctx->EnterSimplifiedSecondary();
        simplifiedSecondary(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedOverrideRightContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedOverrideRightContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SimplifiedSecondaryContext *simplifiedSecondary();
    antlr4::tree::TerminalNode *RIGHT_ANGLE_BRACKET();

   
  };

  template<typename ContextT>
  SimplifiedOverrideRightContext* simplifiedOverrideRight(ContextT* ctx) {
    SimplifiedOverrideRightContext *_localctx = _tracker.createInstance<SimplifiedOverrideRightContext>(_ctx, getState());
    enterRule(_localctx, 484, GQLParser::RuleSimplifiedOverrideRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2578);
      {
        auto childCtxHolder = ctx->EnterSimplifiedSecondary();
        simplifiedSecondary(get_raw_pointer(childCtxHolder));
      }
      setState(2579);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_ANGLE_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_ANGLE_BRACKET);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedOverrideLeftOrUndirectedContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedOverrideLeftOrUndirectedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_ARROW_TILDE();
    SimplifiedSecondaryContext *simplifiedSecondary();

   
  };

  template<typename ContextT>
  SimplifiedOverrideLeftOrUndirectedContext* simplifiedOverrideLeftOrUndirected(ContextT* ctx) {
    SimplifiedOverrideLeftOrUndirectedContext *_localctx = _tracker.createInstance<SimplifiedOverrideLeftOrUndirectedContext>(_ctx, getState());
    enterRule(_localctx, 486, GQLParser::RuleSimplifiedOverrideLeftOrUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2581);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ARROW_TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ARROW_TILDE);
      setState(2582);
      {
        auto childCtxHolder = ctx->EnterSimplifiedSecondary();
        simplifiedSecondary(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedOverrideUndirectedOrRightContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedOverrideUndirectedOrRightContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TILDE();
    SimplifiedSecondaryContext *simplifiedSecondary();
    antlr4::tree::TerminalNode *RIGHT_ANGLE_BRACKET();

   
  };

  template<typename ContextT>
  SimplifiedOverrideUndirectedOrRightContext* simplifiedOverrideUndirectedOrRight(ContextT* ctx) {
    SimplifiedOverrideUndirectedOrRightContext *_localctx = _tracker.createInstance<SimplifiedOverrideUndirectedOrRightContext>(_ctx, getState());
    enterRule(_localctx, 488, GQLParser::RuleSimplifiedOverrideUndirectedOrRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2584);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE);
      setState(2585);
      {
        auto childCtxHolder = ctx->EnterSimplifiedSecondary();
        simplifiedSecondary(get_raw_pointer(childCtxHolder));
      }
      setState(2586);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_ANGLE_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_ANGLE_BRACKET);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedOverrideLeftOrRightContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedOverrideLeftOrRightContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_ANGLE_BRACKET();
    SimplifiedSecondaryContext *simplifiedSecondary();
    antlr4::tree::TerminalNode *RIGHT_ANGLE_BRACKET();

   
  };

  template<typename ContextT>
  SimplifiedOverrideLeftOrRightContext* simplifiedOverrideLeftOrRight(ContextT* ctx) {
    SimplifiedOverrideLeftOrRightContext *_localctx = _tracker.createInstance<SimplifiedOverrideLeftOrRightContext>(_ctx, getState());
    enterRule(_localctx, 490, GQLParser::RuleSimplifiedOverrideLeftOrRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2588);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ANGLE_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ANGLE_BRACKET);
      setState(2589);
      {
        auto childCtxHolder = ctx->EnterSimplifiedSecondary();
        simplifiedSecondary(get_raw_pointer(childCtxHolder));
      }
      setState(2590);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_ANGLE_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_ANGLE_BRACKET);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedOverrideAnyDirectionContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedOverrideAnyDirectionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MINUS_SIGN();
    SimplifiedSecondaryContext *simplifiedSecondary();

   
  };

  template<typename ContextT>
  SimplifiedOverrideAnyDirectionContext* simplifiedOverrideAnyDirection(ContextT* ctx) {
    SimplifiedOverrideAnyDirectionContext *_localctx = _tracker.createInstance<SimplifiedOverrideAnyDirectionContext>(_ctx, getState());
    enterRule(_localctx, 492, GQLParser::RuleSimplifiedOverrideAnyDirection);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2592);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MINUS_SIGN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MINUS_SIGN);
      setState(2593);
      {
        auto childCtxHolder = ctx->EnterSimplifiedSecondary();
        simplifiedSecondary(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedSecondaryContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedSecondaryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SimplifiedPrimaryContext *simplifiedPrimary();
    SimplifiedNegationContext *simplifiedNegation();

   
  };

  template<typename ContextT>
  SimplifiedSecondaryContext* simplifiedSecondary(ContextT* ctx) {
    SimplifiedSecondaryContext *_localctx = _tracker.createInstance<SimplifiedSecondaryContext>(_ctx, getState());
    enterRule(_localctx, 494, GQLParser::RuleSimplifiedSecondary);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2597);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER:
        case GQLParser::LEFT_PAREN: {
          enterOuterAlt(_localctx, 1);
          setState(2595);
          {
            auto childCtxHolder = ctx->EnterSimplifiedPrimary();
            simplifiedPrimary(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::EXCLAMATION_MARK: {
          enterOuterAlt(_localctx, 2);
          setState(2596);
          {
            auto childCtxHolder = ctx->EnterSimplifiedNegation();
            simplifiedNegation(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedNegationContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedNegationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXCLAMATION_MARK();
    SimplifiedPrimaryContext *simplifiedPrimary();

   
  };

  template<typename ContextT>
  SimplifiedNegationContext* simplifiedNegation(ContextT* ctx) {
    SimplifiedNegationContext *_localctx = _tracker.createInstance<SimplifiedNegationContext>(_ctx, getState());
    enterRule(_localctx, 496, GQLParser::RuleSimplifiedNegation);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2599);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EXCLAMATION_MARK) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EXCLAMATION_MARK);
      setState(2600);
      {
        auto childCtxHolder = ctx->EnterSimplifiedPrimary();
        simplifiedPrimary(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimplifiedPrimaryContext : public antlr4::ParserRuleContext {
  public:
    SimplifiedPrimaryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    LabelNameContext *labelName();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SimplifiedContentsContext *simplifiedContents();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  SimplifiedPrimaryContext* simplifiedPrimary(ContextT* ctx) {
    SimplifiedPrimaryContext *_localctx = _tracker.createInstance<SimplifiedPrimaryContext>(_ctx, getState());
    enterRule(_localctx, 498, GQLParser::RuleSimplifiedPrimary);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2607);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 1);
          setState(2602);
          {
            auto childCtxHolder = ctx->EnterLabelName();
            labelName(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LEFT_PAREN: {
          enterOuterAlt(_localctx, 2);
          setState(2603);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(2604);
          {
            auto childCtxHolder = ctx->EnterSimplifiedContents();
            simplifiedContents(get_raw_pointer(childCtxHolder));
          }
          setState(2605);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  WhereClauseContext : public antlr4::ParserRuleContext {
  public:
    WhereClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHERE();
    SearchConditionContext *searchCondition();

   
  };

  template<typename ContextT>
  WhereClauseContext* whereClause(ContextT* ctx) {
    WhereClauseContext *_localctx = _tracker.createInstance<WhereClauseContext>(_ctx, getState());
    enterRule(_localctx, 500, GQLParser::RuleWhereClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2609);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::WHERE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::WHERE);
      setState(2610);
      {
        auto childCtxHolder = ctx->EnterSearchCondition();
        searchCondition(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  YieldClauseContext : public antlr4::ParserRuleContext {
  public:
    YieldClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *YIELD();
    YieldItemListContext *yieldItemList();

   
  };

  template<typename ContextT>
  YieldClauseContext* yieldClause(ContextT* ctx) {
    YieldClauseContext *_localctx = _tracker.createInstance<YieldClauseContext>(_ctx, getState());
    enterRule(_localctx, 502, GQLParser::RuleYieldClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2612);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::YIELD) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::YIELD);
      setState(2613);
      {
        auto childCtxHolder = ctx->EnterYieldItemList();
        yieldItemList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  YieldItemListContext : public antlr4::ParserRuleContext {
  public:
    YieldItemListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<YieldItemContext *> yieldItem();
    YieldItemContext* yieldItem(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  YieldItemListContext* yieldItemList(ContextT* ctx) {
    YieldItemListContext *_localctx = _tracker.createInstance<YieldItemListContext>(_ctx, getState());
    enterRule(_localctx, 504, GQLParser::RuleYieldItemList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2615);
      {
        auto childCtxHolder = ctx->EnterYieldItem();
        yieldItem(get_raw_pointer(childCtxHolder));
      }
      setState(2620);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(2616);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(2617);
        {
          auto childCtxHolder = ctx->EnterYieldItem();
          yieldItem(get_raw_pointer(childCtxHolder));
        }
        setState(2622);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  YieldItemContext : public antlr4::ParserRuleContext {
  public:
    YieldItemContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    YieldItemNameContext *yieldItemName();
    YieldItemAliasContext *yieldItemAlias();

   
  };

  template<typename ContextT>
  YieldItemContext* yieldItem(ContextT* ctx) {
    YieldItemContext *_localctx = _tracker.createInstance<YieldItemContext>(_ctx, getState());
    enterRule(_localctx, 506, GQLParser::RuleYieldItem);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2623);
      {
        auto childCtxHolder = ctx->EnterYieldItemName();
        yieldItemName(get_raw_pointer(childCtxHolder));
      }
      setState(2625);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::AS) {
        setState(2624);
        {
          auto childCtxHolder = ctx->EnterYieldItemAlias();
          yieldItemAlias(get_raw_pointer(childCtxHolder));
        }
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  YieldItemNameContext : public antlr4::ParserRuleContext {
  public:
    YieldItemNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    FieldNameContext *fieldName();

   
  };

  template<typename ContextT>
  YieldItemNameContext* yieldItemName(ContextT* ctx) {
    YieldItemNameContext *_localctx = _tracker.createInstance<YieldItemNameContext>(_ctx, getState());
    enterRule(_localctx, 508, GQLParser::RuleYieldItemName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2627);
      {
        auto childCtxHolder = ctx->EnterFieldName();
        fieldName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  YieldItemAliasContext : public antlr4::ParserRuleContext {
  public:
    YieldItemAliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AS();
    BindingVariableContext *bindingVariable();

   
  };

  template<typename ContextT>
  YieldItemAliasContext* yieldItemAlias(ContextT* ctx) {
    YieldItemAliasContext *_localctx = _tracker.createInstance<YieldItemAliasContext>(_ctx, getState());
    enterRule(_localctx, 510, GQLParser::RuleYieldItemAlias);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2629);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::AS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::AS);
      setState(2630);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GroupByClauseContext : public antlr4::ParserRuleContext {
  public:
    GroupByClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GROUP();
    antlr4::tree::TerminalNode *BY();
    GroupingElementListContext *groupingElementList();

   
  };

  template<typename ContextT>
  GroupByClauseContext* groupByClause(ContextT* ctx) {
    GroupByClauseContext *_localctx = _tracker.createInstance<GroupByClauseContext>(_ctx, getState());
    enterRule(_localctx, 512, GQLParser::RuleGroupByClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2632);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GROUP) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GROUP);
      setState(2633);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BY);
      setState(2634);
      {
        auto childCtxHolder = ctx->EnterGroupingElementList();
        groupingElementList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GroupingElementListContext : public antlr4::ParserRuleContext {
  public:
    GroupingElementListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<GroupingElementContext *> groupingElement();
    GroupingElementContext* groupingElement(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    EmptyGroupingSetContext *emptyGroupingSet();

   
  };

  template<typename ContextT>
  GroupingElementListContext* groupingElementList(ContextT* ctx) {
    GroupingElementListContext *_localctx = _tracker.createInstance<GroupingElementListContext>(_ctx, getState());
    enterRule(_localctx, 514, GQLParser::RuleGroupingElementList);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      setState(2645);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 1);
          setState(2636);
          {
            auto childCtxHolder = ctx->EnterGroupingElement();
            groupingElement(get_raw_pointer(childCtxHolder));
          }
          setState(2641);
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx);
          while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(2637);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::COMMA) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::COMMA);
              setState(2638);
              {
                auto childCtxHolder = ctx->EnterGroupingElement();
                groupingElement(get_raw_pointer(childCtxHolder));
              } 
            }
            setState(2643);
            _errHandler->sync(this);
            alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx);
          }
          break;
        }

        case GQLParser::LEFT_PAREN: {
          enterOuterAlt(_localctx, 2);
          setState(2644);
          {
            auto childCtxHolder = ctx->EnterEmptyGroupingSet();
            emptyGroupingSet(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GroupingElementContext : public antlr4::ParserRuleContext {
  public:
    GroupingElementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BindingVariableReferenceContext *bindingVariableReference();

   
  };

  template<typename ContextT>
  GroupingElementContext* groupingElement(ContextT* ctx) {
    GroupingElementContext *_localctx = _tracker.createInstance<GroupingElementContext>(_ctx, getState());
    enterRule(_localctx, 516, GQLParser::RuleGroupingElement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2647);
      {
        auto childCtxHolder = ctx->EnterBindingVariableReference();
        bindingVariableReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EmptyGroupingSetContext : public antlr4::ParserRuleContext {
  public:
    EmptyGroupingSetContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  EmptyGroupingSetContext* emptyGroupingSet(ContextT* ctx) {
    EmptyGroupingSetContext *_localctx = _tracker.createInstance<EmptyGroupingSetContext>(_ctx, getState());
    enterRule(_localctx, 518, GQLParser::RuleEmptyGroupingSet);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2649);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(2650);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  OrderByClauseContext : public antlr4::ParserRuleContext {
  public:
    OrderByClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ORDER();
    antlr4::tree::TerminalNode *BY();
    SortSpecificationListContext *sortSpecificationList();

   
  };

  template<typename ContextT>
  OrderByClauseContext* orderByClause(ContextT* ctx) {
    OrderByClauseContext *_localctx = _tracker.createInstance<OrderByClauseContext>(_ctx, getState());
    enterRule(_localctx, 520, GQLParser::RuleOrderByClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2652);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ORDER) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ORDER);
      setState(2653);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BY);
      setState(2654);
      {
        auto childCtxHolder = ctx->EnterSortSpecificationList();
        sortSpecificationList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SortSpecificationListContext : public antlr4::ParserRuleContext {
  public:
    SortSpecificationListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<SortSpecificationContext *> sortSpecification();
    SortSpecificationContext* sortSpecification(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  SortSpecificationListContext* sortSpecificationList(ContextT* ctx) {
    SortSpecificationListContext *_localctx = _tracker.createInstance<SortSpecificationListContext>(_ctx, getState());
    enterRule(_localctx, 522, GQLParser::RuleSortSpecificationList);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(2656);
      {
        auto childCtxHolder = ctx->EnterSortSpecification();
        sortSpecification(get_raw_pointer(childCtxHolder));
      }
      setState(2661);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 229, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2657);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COMMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COMMA);
          setState(2658);
          {
            auto childCtxHolder = ctx->EnterSortSpecification();
            sortSpecification(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(2663);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 229, _ctx);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SortSpecificationContext : public antlr4::ParserRuleContext {
  public:
    SortSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SortKeyContext *sortKey();
    OrderingSpecificationContext *orderingSpecification();
    NullOrderingContext *nullOrdering();

   
  };

  template<typename ContextT>
  SortSpecificationContext* sortSpecification(ContextT* ctx) {
    SortSpecificationContext *_localctx = _tracker.createInstance<SortSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 524, GQLParser::RuleSortSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2664);
      {
        auto childCtxHolder = ctx->EnterSortKey();
        sortKey(get_raw_pointer(childCtxHolder));
      }
      setState(2666);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx)) {
      case 1: {
        setState(2665);
        {
          auto childCtxHolder = ctx->EnterOrderingSpecification();
          orderingSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2669);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx)) {
      case 1: {
        setState(2668);
        {
          auto childCtxHolder = ctx->EnterNullOrdering();
          nullOrdering(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SortKeyContext : public antlr4::ParserRuleContext {
  public:
    SortKeyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    AggregatingValueExpressionContext *aggregatingValueExpression();

   
  };

  template<typename ContextT>
  SortKeyContext* sortKey(ContextT* ctx) {
    SortKeyContext *_localctx = _tracker.createInstance<SortKeyContext>(_ctx, getState());
    enterRule(_localctx, 526, GQLParser::RuleSortKey);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2671);
      {
        auto childCtxHolder = ctx->EnterAggregatingValueExpression();
        aggregatingValueExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  OrderingSpecificationContext : public antlr4::ParserRuleContext {
  public:
    OrderingSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ASC();
    antlr4::tree::TerminalNode *ASCENDING();
    antlr4::tree::TerminalNode *DESC();
    antlr4::tree::TerminalNode *DESCENDING();

   
  };

  template<typename ContextT>
  OrderingSpecificationContext* orderingSpecification(ContextT* ctx) {
    OrderingSpecificationContext *_localctx = _tracker.createInstance<OrderingSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 528, GQLParser::RuleOrderingSpecification);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2673);
      _la = _input->LA(1);
      if (!(((((_la - 28) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 28)) & 1688849860263939) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NullOrderingContext : public antlr4::ParserRuleContext {
  public:
    NullOrderingContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NULLS();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *LAST();

   
  };

  template<typename ContextT>
  NullOrderingContext* nullOrdering(ContextT* ctx) {
    NullOrderingContext *_localctx = _tracker.createInstance<NullOrderingContext>(_ctx, getState());
    enterRule(_localctx, 530, GQLParser::RuleNullOrdering);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2679);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2675);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NULLS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NULLS);
        setState(2676);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::FIRST) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::FIRST);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2677);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NULLS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NULLS);
        setState(2678);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LAST) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LAST);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LimitClauseContext : public antlr4::ParserRuleContext {
  public:
    LimitClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LIMIT();
    NonNegativeIntegerSpecificationContext *nonNegativeIntegerSpecification();

   
  };

  template<typename ContextT>
  LimitClauseContext* limitClause(ContextT* ctx) {
    LimitClauseContext *_localctx = _tracker.createInstance<LimitClauseContext>(_ctx, getState());
    enterRule(_localctx, 532, GQLParser::RuleLimitClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2681);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LIMIT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LIMIT);
      setState(2682);
      {
        auto childCtxHolder = ctx->EnterNonNegativeIntegerSpecification();
        nonNegativeIntegerSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  OffsetClauseContext : public antlr4::ParserRuleContext {
  public:
    OffsetClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    OffsetSynonymContext *offsetSynonym();
    NonNegativeIntegerSpecificationContext *nonNegativeIntegerSpecification();

   
  };

  template<typename ContextT>
  OffsetClauseContext* offsetClause(ContextT* ctx) {
    OffsetClauseContext *_localctx = _tracker.createInstance<OffsetClauseContext>(_ctx, getState());
    enterRule(_localctx, 534, GQLParser::RuleOffsetClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2684);
      {
        auto childCtxHolder = ctx->EnterOffsetSynonym();
        offsetSynonym(get_raw_pointer(childCtxHolder));
      }
      setState(2685);
      {
        auto childCtxHolder = ctx->EnterNonNegativeIntegerSpecification();
        nonNegativeIntegerSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  OffsetSynonymContext : public antlr4::ParserRuleContext {
  public:
    OffsetSynonymContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *OFFSET();
    antlr4::tree::TerminalNode *SKIP_RESERVED_WORD();

   
  };

  template<typename ContextT>
  OffsetSynonymContext* offsetSynonym(ContextT* ctx) {
    OffsetSynonymContext *_localctx = _tracker.createInstance<OffsetSynonymContext>(_ctx, getState());
    enterRule(_localctx, 536, GQLParser::RuleOffsetSynonym);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2687);
      _la = _input->LA(1);
      if (!(_la == GQLParser::OFFSET

      || _la == GQLParser::SKIP_RESERVED_WORD)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SchemaReferenceContext : public antlr4::ParserRuleContext {
  public:
    SchemaReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    AbsoluteCatalogSchemaReferenceContext *absoluteCatalogSchemaReference();
    RelativeCatalogSchemaReferenceContext *relativeCatalogSchemaReference();
    ReferenceParameterSpecificationContext *referenceParameterSpecification();

   
  };

  template<typename ContextT>
  SchemaReferenceContext* schemaReference(ContextT* ctx) {
    SchemaReferenceContext *_localctx = _tracker.createInstance<SchemaReferenceContext>(_ctx, getState());
    enterRule(_localctx, 538, GQLParser::RuleSchemaReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2692);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::SOLIDUS: {
          enterOuterAlt(_localctx, 1);
          setState(2689);
          {
            auto childCtxHolder = ctx->EnterAbsoluteCatalogSchemaReference();
            absoluteCatalogSchemaReference(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CURRENT_SCHEMA:
        case GQLParser::HOME_SCHEMA:
        case GQLParser::DOUBLE_PERIOD:
        case GQLParser::PERIOD: {
          enterOuterAlt(_localctx, 2);
          setState(2690);
          {
            auto childCtxHolder = ctx->EnterRelativeCatalogSchemaReference();
            relativeCatalogSchemaReference(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::SUBSTITUTED_PARAMETER_REFERENCE: {
          enterOuterAlt(_localctx, 3);
          setState(2691);
          {
            auto childCtxHolder = ctx->EnterReferenceParameterSpecification();
            referenceParameterSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  AbsoluteCatalogSchemaReferenceContext : public antlr4::ParserRuleContext {
  public:
    AbsoluteCatalogSchemaReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SOLIDUS();
    AbsoluteDirectoryPathContext *absoluteDirectoryPath();
    SchemaNameContext *schemaName();

   
  };

  template<typename ContextT>
  AbsoluteCatalogSchemaReferenceContext* absoluteCatalogSchemaReference(ContextT* ctx) {
    AbsoluteCatalogSchemaReferenceContext *_localctx = _tracker.createInstance<AbsoluteCatalogSchemaReferenceContext>(_ctx, getState());
    enterRule(_localctx, 540, GQLParser::RuleAbsoluteCatalogSchemaReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2698);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 234, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2694);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::SOLIDUS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::SOLIDUS);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2695);
        {
          auto childCtxHolder = ctx->EnterAbsoluteDirectoryPath();
          absoluteDirectoryPath(get_raw_pointer(childCtxHolder));
        }
        setState(2696);
        {
          auto childCtxHolder = ctx->EnterSchemaName();
          schemaName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CatalogSchemaParentAndNameContext : public antlr4::ParserRuleContext {
  public:
    CatalogSchemaParentAndNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    AbsoluteDirectoryPathContext *absoluteDirectoryPath();
    SchemaNameContext *schemaName();

   
  };

  template<typename ContextT>
  CatalogSchemaParentAndNameContext* catalogSchemaParentAndName(ContextT* ctx) {
    CatalogSchemaParentAndNameContext *_localctx = _tracker.createInstance<CatalogSchemaParentAndNameContext>(_ctx, getState());
    enterRule(_localctx, 542, GQLParser::RuleCatalogSchemaParentAndName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2700);
      {
        auto childCtxHolder = ctx->EnterAbsoluteDirectoryPath();
        absoluteDirectoryPath(get_raw_pointer(childCtxHolder));
      }
      setState(2701);
      {
        auto childCtxHolder = ctx->EnterSchemaName();
        schemaName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  RelativeCatalogSchemaReferenceContext : public antlr4::ParserRuleContext {
  public:
    RelativeCatalogSchemaReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PredefinedSchemaReferenceContext *predefinedSchemaReference();
    RelativeDirectoryPathContext *relativeDirectoryPath();
    SchemaNameContext *schemaName();

   
  };

  template<typename ContextT>
  RelativeCatalogSchemaReferenceContext* relativeCatalogSchemaReference(ContextT* ctx) {
    RelativeCatalogSchemaReferenceContext *_localctx = _tracker.createInstance<RelativeCatalogSchemaReferenceContext>(_ctx, getState());
    enterRule(_localctx, 544, GQLParser::RuleRelativeCatalogSchemaReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2707);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CURRENT_SCHEMA:
        case GQLParser::HOME_SCHEMA:
        case GQLParser::PERIOD: {
          enterOuterAlt(_localctx, 1);
          setState(2703);
          {
            auto childCtxHolder = ctx->EnterPredefinedSchemaReference();
            predefinedSchemaReference(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DOUBLE_PERIOD: {
          enterOuterAlt(_localctx, 2);
          setState(2704);
          {
            auto childCtxHolder = ctx->EnterRelativeDirectoryPath();
            relativeDirectoryPath(get_raw_pointer(childCtxHolder));
          }
          setState(2705);
          {
            auto childCtxHolder = ctx->EnterSchemaName();
            schemaName(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PredefinedSchemaReferenceContext : public antlr4::ParserRuleContext {
  public:
    PredefinedSchemaReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *HOME_SCHEMA();
    antlr4::tree::TerminalNode *CURRENT_SCHEMA();
    antlr4::tree::TerminalNode *PERIOD();

   
  };

  template<typename ContextT>
  PredefinedSchemaReferenceContext* predefinedSchemaReference(ContextT* ctx) {
    PredefinedSchemaReferenceContext *_localctx = _tracker.createInstance<PredefinedSchemaReferenceContext>(_ctx, getState());
    enterRule(_localctx, 546, GQLParser::RulePredefinedSchemaReference);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2709);
      _la = _input->LA(1);
      if (!(_la == GQLParser::CURRENT_SCHEMA

      || _la == GQLParser::HOME_SCHEMA || _la == GQLParser::PERIOD)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  AbsoluteDirectoryPathContext : public antlr4::ParserRuleContext {
  public:
    AbsoluteDirectoryPathContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SOLIDUS();
    SimpleDirectoryPathContext *simpleDirectoryPath();

   
  };

  template<typename ContextT>
  AbsoluteDirectoryPathContext* absoluteDirectoryPath(ContextT* ctx) {
    AbsoluteDirectoryPathContext *_localctx = _tracker.createInstance<AbsoluteDirectoryPathContext>(_ctx, getState());
    enterRule(_localctx, 548, GQLParser::RuleAbsoluteDirectoryPath);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2711);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SOLIDUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SOLIDUS);
      setState(2713);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 236, _ctx)) {
      case 1: {
        setState(2712);
        {
          auto childCtxHolder = ctx->EnterSimpleDirectoryPath();
          simpleDirectoryPath(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  RelativeDirectoryPathContext : public antlr4::ParserRuleContext {
  public:
    RelativeDirectoryPathContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> DOUBLE_PERIOD();
    antlr4::tree::TerminalNode* DOUBLE_PERIOD(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SOLIDUS();
    antlr4::tree::TerminalNode* SOLIDUS(size_t i);
    SimpleDirectoryPathContext *simpleDirectoryPath();

   
  };

  template<typename ContextT>
  RelativeDirectoryPathContext* relativeDirectoryPath(ContextT* ctx) {
    RelativeDirectoryPathContext *_localctx = _tracker.createInstance<RelativeDirectoryPathContext>(_ctx, getState());
    enterRule(_localctx, 550, GQLParser::RuleRelativeDirectoryPath);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(2715);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DOUBLE_PERIOD) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DOUBLE_PERIOD);
      setState(2720);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(2716);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::SOLIDUS) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::SOLIDUS);
          setState(2717);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::DOUBLE_PERIOD) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::DOUBLE_PERIOD); 
        }
        setState(2722);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx);
      }
      setState(2723);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SOLIDUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SOLIDUS);
      setState(2725);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx)) {
      case 1: {
        setState(2724);
        {
          auto childCtxHolder = ctx->EnterSimpleDirectoryPath();
          simpleDirectoryPath(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimpleDirectoryPathContext : public antlr4::ParserRuleContext {
  public:
    SimpleDirectoryPathContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<DirectoryNameContext *> directoryName();
    DirectoryNameContext* directoryName(size_t i);
    std::vector<antlr4::tree::TerminalNode *> SOLIDUS();
    antlr4::tree::TerminalNode* SOLIDUS(size_t i);

   
  };

  template<typename ContextT>
  SimpleDirectoryPathContext* simpleDirectoryPath(ContextT* ctx) {
    SimpleDirectoryPathContext *_localctx = _tracker.createInstance<SimpleDirectoryPathContext>(_ctx, getState());
    enterRule(_localctx, 552, GQLParser::RuleSimpleDirectoryPath);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(2730); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(2727);
                {
                  auto childCtxHolder = ctx->EnterDirectoryName();
                  directoryName(get_raw_pointer(childCtxHolder));
                }
                setState(2728);
                if constexpr (has_OnToken<decltype(ctx)>::value) {
                  if (_input->LA(1) == GQLParser::SOLIDUS) {
                    ctx->OnToken(_input->LT(1));
                  }
                }
                match(GQLParser::SOLIDUS);
                break;
              }

        default:
          throw antlr4::NoViableAltException(this);
        }
        setState(2732); 
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 239, _ctx);
      } while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphReferenceContext : public antlr4::ParserRuleContext {
  public:
    GraphReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CatalogObjectParentReferenceContext *catalogObjectParentReference();
    GraphNameContext *graphName();
    DelimitedGraphNameContext *delimitedGraphName();
    HomeGraphContext *homeGraph();
    ReferenceParameterSpecificationContext *referenceParameterSpecification();

   
  };

  template<typename ContextT>
  GraphReferenceContext* graphReference(ContextT* ctx) {
    GraphReferenceContext *_localctx = _tracker.createInstance<GraphReferenceContext>(_ctx, getState());
    enterRule(_localctx, 554, GQLParser::RuleGraphReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2740);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 240, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2734);
        {
          auto childCtxHolder = ctx->EnterCatalogObjectParentReference();
          catalogObjectParentReference(get_raw_pointer(childCtxHolder));
        }
        setState(2735);
        {
          auto childCtxHolder = ctx->EnterGraphName();
          graphName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2737);
        {
          auto childCtxHolder = ctx->EnterDelimitedGraphName();
          delimitedGraphName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2738);
        {
          auto childCtxHolder = ctx->EnterHomeGraph();
          homeGraph(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(2739);
        {
          auto childCtxHolder = ctx->EnterReferenceParameterSpecification();
          referenceParameterSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CatalogGraphParentAndNameContext : public antlr4::ParserRuleContext {
  public:
    CatalogGraphParentAndNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    GraphNameContext *graphName();
    CatalogObjectParentReferenceContext *catalogObjectParentReference();

   
  };

  template<typename ContextT>
  CatalogGraphParentAndNameContext* catalogGraphParentAndName(ContextT* ctx) {
    CatalogGraphParentAndNameContext *_localctx = _tracker.createInstance<CatalogGraphParentAndNameContext>(_ctx, getState());
    enterRule(_localctx, 556, GQLParser::RuleCatalogGraphParentAndName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2743);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx)) {
      case 1: {
        setState(2742);
        {
          auto childCtxHolder = ctx->EnterCatalogObjectParentReference();
          catalogObjectParentReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2745);
      {
        auto childCtxHolder = ctx->EnterGraphName();
        graphName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  HomeGraphContext : public antlr4::ParserRuleContext {
  public:
    HomeGraphContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *HOME_PROPERTY_GRAPH();
    antlr4::tree::TerminalNode *HOME_GRAPH();

   
  };

  template<typename ContextT>
  HomeGraphContext* homeGraph(ContextT* ctx) {
    HomeGraphContext *_localctx = _tracker.createInstance<HomeGraphContext>(_ctx, getState());
    enterRule(_localctx, 558, GQLParser::RuleHomeGraph);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2747);
      _la = _input->LA(1);
      if (!(_la == GQLParser::HOME_GRAPH

      || _la == GQLParser::HOME_PROPERTY_GRAPH)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphTypeReferenceContext : public antlr4::ParserRuleContext {
  public:
    GraphTypeReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CatalogGraphTypeParentAndNameContext *catalogGraphTypeParentAndName();
    ReferenceParameterSpecificationContext *referenceParameterSpecification();

   
  };

  template<typename ContextT>
  GraphTypeReferenceContext* graphTypeReference(ContextT* ctx) {
    GraphTypeReferenceContext *_localctx = _tracker.createInstance<GraphTypeReferenceContext>(_ctx, getState());
    enterRule(_localctx, 560, GQLParser::RuleGraphTypeReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2751);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2749);
        {
          auto childCtxHolder = ctx->EnterCatalogGraphTypeParentAndName();
          catalogGraphTypeParentAndName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2750);
        {
          auto childCtxHolder = ctx->EnterReferenceParameterSpecification();
          referenceParameterSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CatalogGraphTypeParentAndNameContext : public antlr4::ParserRuleContext {
  public:
    CatalogGraphTypeParentAndNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    GraphTypeNameContext *graphTypeName();
    CatalogObjectParentReferenceContext *catalogObjectParentReference();

   
  };

  template<typename ContextT>
  CatalogGraphTypeParentAndNameContext* catalogGraphTypeParentAndName(ContextT* ctx) {
    CatalogGraphTypeParentAndNameContext *_localctx = _tracker.createInstance<CatalogGraphTypeParentAndNameContext>(_ctx, getState());
    enterRule(_localctx, 562, GQLParser::RuleCatalogGraphTypeParentAndName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2754);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx)) {
      case 1: {
        setState(2753);
        {
          auto childCtxHolder = ctx->EnterCatalogObjectParentReference();
          catalogObjectParentReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2756);
      {
        auto childCtxHolder = ctx->EnterGraphTypeName();
        graphTypeName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BindingTableReferenceContext : public antlr4::ParserRuleContext {
  public:
    BindingTableReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CatalogObjectParentReferenceContext *catalogObjectParentReference();
    BindingTableNameContext *bindingTableName();
    DelimitedBindingTableNameContext *delimitedBindingTableName();
    ReferenceParameterSpecificationContext *referenceParameterSpecification();

   
  };

  template<typename ContextT>
  BindingTableReferenceContext* bindingTableReference(ContextT* ctx) {
    BindingTableReferenceContext *_localctx = _tracker.createInstance<BindingTableReferenceContext>(_ctx, getState());
    enterRule(_localctx, 564, GQLParser::RuleBindingTableReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2763);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2758);
        {
          auto childCtxHolder = ctx->EnterCatalogObjectParentReference();
          catalogObjectParentReference(get_raw_pointer(childCtxHolder));
        }
        setState(2759);
        {
          auto childCtxHolder = ctx->EnterBindingTableName();
          bindingTableName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2761);
        {
          auto childCtxHolder = ctx->EnterDelimitedBindingTableName();
          delimitedBindingTableName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2762);
        {
          auto childCtxHolder = ctx->EnterReferenceParameterSpecification();
          referenceParameterSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ProcedureReferenceContext : public antlr4::ParserRuleContext {
  public:
    ProcedureReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CatalogProcedureParentAndNameContext *catalogProcedureParentAndName();
    ReferenceParameterSpecificationContext *referenceParameterSpecification();

   
  };

  template<typename ContextT>
  ProcedureReferenceContext* procedureReference(ContextT* ctx) {
    ProcedureReferenceContext *_localctx = _tracker.createInstance<ProcedureReferenceContext>(_ctx, getState());
    enterRule(_localctx, 566, GQLParser::RuleProcedureReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2767);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 245, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2765);
        {
          auto childCtxHolder = ctx->EnterCatalogProcedureParentAndName();
          catalogProcedureParentAndName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2766);
        {
          auto childCtxHolder = ctx->EnterReferenceParameterSpecification();
          referenceParameterSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CatalogProcedureParentAndNameContext : public antlr4::ParserRuleContext {
  public:
    CatalogProcedureParentAndNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ProcedureNameContext *procedureName();
    CatalogObjectParentReferenceContext *catalogObjectParentReference();

   
  };

  template<typename ContextT>
  CatalogProcedureParentAndNameContext* catalogProcedureParentAndName(ContextT* ctx) {
    CatalogProcedureParentAndNameContext *_localctx = _tracker.createInstance<CatalogProcedureParentAndNameContext>(_ctx, getState());
    enterRule(_localctx, 568, GQLParser::RuleCatalogProcedureParentAndName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2770);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 246, _ctx)) {
      case 1: {
        setState(2769);
        {
          auto childCtxHolder = ctx->EnterCatalogObjectParentReference();
          catalogObjectParentReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2772);
      {
        auto childCtxHolder = ctx->EnterProcedureName();
        procedureName(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CatalogObjectParentReferenceContext : public antlr4::ParserRuleContext {
  public:
    CatalogObjectParentReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SchemaReferenceContext *schemaReference();
    antlr4::tree::TerminalNode *SOLIDUS();
    std::vector<ObjectNameContext *> objectName();
    ObjectNameContext* objectName(size_t i);
    std::vector<antlr4::tree::TerminalNode *> PERIOD();
    antlr4::tree::TerminalNode* PERIOD(size_t i);

   
  };

  template<typename ContextT>
  CatalogObjectParentReferenceContext* catalogObjectParentReference(ContextT* ctx) {
    CatalogObjectParentReferenceContext *_localctx = _tracker.createInstance<CatalogObjectParentReferenceContext>(_ctx, getState());
    enterRule(_localctx, 570, GQLParser::RuleCatalogObjectParentReference);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      setState(2793);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CURRENT_SCHEMA:
        case GQLParser::HOME_SCHEMA:
        case GQLParser::SUBSTITUTED_PARAMETER_REFERENCE:
        case GQLParser::DOUBLE_PERIOD:
        case GQLParser::PERIOD:
        case GQLParser::SOLIDUS: {
          enterOuterAlt(_localctx, 1);
          setState(2774);
          {
            auto childCtxHolder = ctx->EnterSchemaReference();
            schemaReference(get_raw_pointer(childCtxHolder));
          }
          setState(2776);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::SOLIDUS) {
            setState(2775);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::SOLIDUS) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::SOLIDUS);
          }
          setState(2783);
          _errHandler->sync(this);
          alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx);
          while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
            if (alt == 1) {
              setState(2778);
              {
                auto childCtxHolder = ctx->EnterObjectName();
                objectName(get_raw_pointer(childCtxHolder));
              }
              setState(2779);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::PERIOD) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::PERIOD); 
            }
            setState(2785);
            _errHandler->sync(this);
            alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx);
          }
          break;
        }

        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 2);
          setState(2789); 
          _errHandler->sync(this);
          alt = 1;
          do {
            switch (alt) {
              case 1: {
                    setState(2786);
                    {
                      auto childCtxHolder = ctx->EnterObjectName();
                      objectName(get_raw_pointer(childCtxHolder));
                    }
                    setState(2787);
                    if constexpr (has_OnToken<decltype(ctx)>::value) {
                      if (_input->LA(1) == GQLParser::PERIOD) {
                        ctx->OnToken(_input->LT(1));
                      }
                    }
                    match(GQLParser::PERIOD);
                    break;
                  }

            default:
              throw antlr4::NoViableAltException(this);
            }
            setState(2791); 
            _errHandler->sync(this);
            alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx);
          } while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ReferenceParameterSpecificationContext : public antlr4::ParserRuleContext {
  public:
    ReferenceParameterSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SUBSTITUTED_PARAMETER_REFERENCE();

   
  };

  template<typename ContextT>
  ReferenceParameterSpecificationContext* referenceParameterSpecification(ContextT* ctx) {
    ReferenceParameterSpecificationContext *_localctx = _tracker.createInstance<ReferenceParameterSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 572, GQLParser::RuleReferenceParameterSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2795);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SUBSTITUTED_PARAMETER_REFERENCE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SUBSTITUTED_PARAMETER_REFERENCE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NestedGraphTypeSpecificationContext : public antlr4::ParserRuleContext {
  public:
    NestedGraphTypeSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_BRACE();
    GraphTypeSpecificationBodyContext *graphTypeSpecificationBody();
    antlr4::tree::TerminalNode *RIGHT_BRACE();

   
  };

  template<typename ContextT>
  NestedGraphTypeSpecificationContext* nestedGraphTypeSpecification(ContextT* ctx) {
    NestedGraphTypeSpecificationContext *_localctx = _tracker.createInstance<NestedGraphTypeSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 574, GQLParser::RuleNestedGraphTypeSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2797);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(2798);
      {
        auto childCtxHolder = ctx->EnterGraphTypeSpecificationBody();
        graphTypeSpecificationBody(get_raw_pointer(childCtxHolder));
      }
      setState(2799);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphTypeSpecificationBodyContext : public antlr4::ParserRuleContext {
  public:
    GraphTypeSpecificationBodyContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ElementTypeListContext *elementTypeList();

   
  };

  template<typename ContextT>
  GraphTypeSpecificationBodyContext* graphTypeSpecificationBody(ContextT* ctx) {
    GraphTypeSpecificationBodyContext *_localctx = _tracker.createInstance<GraphTypeSpecificationBodyContext>(_ctx, getState());
    enterRule(_localctx, 576, GQLParser::RuleGraphTypeSpecificationBody);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2801);
      {
        auto childCtxHolder = ctx->EnterElementTypeList();
        elementTypeList(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ElementTypeListContext : public antlr4::ParserRuleContext {
  public:
    ElementTypeListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ElementTypeSpecificationContext *> elementTypeSpecification();
    ElementTypeSpecificationContext* elementTypeSpecification(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  ElementTypeListContext* elementTypeList(ContextT* ctx) {
    ElementTypeListContext *_localctx = _tracker.createInstance<ElementTypeListContext>(_ctx, getState());
    enterRule(_localctx, 578, GQLParser::RuleElementTypeList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2803);
      {
        auto childCtxHolder = ctx->EnterElementTypeSpecification();
        elementTypeSpecification(get_raw_pointer(childCtxHolder));
      }
      setState(2808);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(2804);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(2805);
        {
          auto childCtxHolder = ctx->EnterElementTypeSpecification();
          elementTypeSpecification(get_raw_pointer(childCtxHolder));
        }
        setState(2810);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ElementTypeSpecificationContext : public antlr4::ParserRuleContext {
  public:
    ElementTypeSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NodeTypeSpecificationContext *nodeTypeSpecification();
    EdgeTypeSpecificationContext *edgeTypeSpecification();

   
  };

  template<typename ContextT>
  ElementTypeSpecificationContext* elementTypeSpecification(ContextT* ctx) {
    ElementTypeSpecificationContext *_localctx = _tracker.createInstance<ElementTypeSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 580, GQLParser::RuleElementTypeSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2813);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2811);
        {
          auto childCtxHolder = ctx->EnterNodeTypeSpecification();
          nodeTypeSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2812);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeSpecification();
          edgeTypeSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NodeTypeSpecificationContext : public antlr4::ParserRuleContext {
  public:
    NodeTypeSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NodeTypePatternContext *nodeTypePattern();
    NodeTypePhraseContext *nodeTypePhrase();

   
  };

  template<typename ContextT>
  NodeTypeSpecificationContext* nodeTypeSpecification(ContextT* ctx) {
    NodeTypeSpecificationContext *_localctx = _tracker.createInstance<NodeTypeSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 582, GQLParser::RuleNodeTypeSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2817);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2815);
        {
          auto childCtxHolder = ctx->EnterNodeTypePattern();
          nodeTypePattern(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2816);
        {
          auto childCtxHolder = ctx->EnterNodeTypePhrase();
          nodeTypePhrase(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NodeTypePatternContext : public antlr4::ParserRuleContext {
  public:
    NodeTypePatternContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    NodeSynonymContext *nodeSynonym();
    NodeTypeNameContext *nodeTypeName();
    LocalNodeTypeAliasContext *localNodeTypeAlias();
    NodeTypeFillerContext *nodeTypeFiller();
    antlr4::tree::TerminalNode *TYPE();

   
  };

  template<typename ContextT>
  NodeTypePatternContext* nodeTypePattern(ContextT* ctx) {
    NodeTypePatternContext *_localctx = _tracker.createInstance<NodeTypePatternContext>(_ctx, getState());
    enterRule(_localctx, 584, GQLParser::RuleNodeTypePattern);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2825);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::NODE

      || _la == GQLParser::VERTEX) {
        setState(2819);
        {
          auto childCtxHolder = ctx->EnterNodeSynonym();
          nodeSynonym(get_raw_pointer(childCtxHolder));
        }
        setState(2821);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::TYPE) {
          setState(2820);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TYPE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TYPE);
        }
        setState(2823);
        {
          auto childCtxHolder = ctx->EnterNodeTypeName();
          nodeTypeName(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2827);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(2829);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx)) {
      case 1: {
        setState(2828);
        {
          auto childCtxHolder = ctx->EnterLocalNodeTypeAlias();
          localNodeTypeAlias(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      setState(2832);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IMPLIES || _la == GQLParser::IS || _la == GQLParser::LABEL

      || _la == GQLParser::LABELS || _la == GQLParser::COLON

      || _la == GQLParser::LEFT_BRACE) {
        setState(2831);
        {
          auto childCtxHolder = ctx->EnterNodeTypeFiller();
          nodeTypeFiller(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2834);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NodeTypePhraseContext : public antlr4::ParserRuleContext {
  public:
    NodeTypePhraseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NodeSynonymContext *nodeSynonym();
    NodeTypePhraseFillerContext *nodeTypePhraseFiller();
    antlr4::tree::TerminalNode *TYPE();
    antlr4::tree::TerminalNode *AS();
    LocalNodeTypeAliasContext *localNodeTypeAlias();

   
  };

  template<typename ContextT>
  NodeTypePhraseContext* nodeTypePhrase(ContextT* ctx) {
    NodeTypePhraseContext *_localctx = _tracker.createInstance<NodeTypePhraseContext>(_ctx, getState());
    enterRule(_localctx, 586, GQLParser::RuleNodeTypePhrase);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2836);
      {
        auto childCtxHolder = ctx->EnterNodeSynonym();
        nodeSynonym(get_raw_pointer(childCtxHolder));
      }
      setState(2838);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::TYPE) {
        setState(2837);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::TYPE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::TYPE);
      }
      setState(2840);
      {
        auto childCtxHolder = ctx->EnterNodeTypePhraseFiller();
        nodeTypePhraseFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2843);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 259, _ctx)) {
      case 1: {
        setState(2841);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::AS) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::AS);
        setState(2842);
        {
          auto childCtxHolder = ctx->EnterLocalNodeTypeAlias();
          localNodeTypeAlias(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NodeTypePhraseFillerContext : public antlr4::ParserRuleContext {
  public:
    NodeTypePhraseFillerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NodeTypeNameContext *nodeTypeName();
    NodeTypeFillerContext *nodeTypeFiller();

   
  };

  template<typename ContextT>
  NodeTypePhraseFillerContext* nodeTypePhraseFiller(ContextT* ctx) {
    NodeTypePhraseFillerContext *_localctx = _tracker.createInstance<NodeTypePhraseFillerContext>(_ctx, getState());
    enterRule(_localctx, 588, GQLParser::RuleNodeTypePhraseFiller);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2850);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2845);
        {
          auto childCtxHolder = ctx->EnterNodeTypeName();
          nodeTypeName(get_raw_pointer(childCtxHolder));
        }
        setState(2847);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 260, _ctx)) {
        case 1: {
          setState(2846);
          {
            auto childCtxHolder = ctx->EnterNodeTypeFiller();
            nodeTypeFiller(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2849);
        {
          auto childCtxHolder = ctx->EnterNodeTypeFiller();
          nodeTypeFiller(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NodeTypeFillerContext : public antlr4::ParserRuleContext {
  public:
    NodeTypeFillerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NodeTypeKeyLabelSetContext *nodeTypeKeyLabelSet();
    NodeTypeImpliedContentContext *nodeTypeImpliedContent();

   
  };

  template<typename ContextT>
  NodeTypeFillerContext* nodeTypeFiller(ContextT* ctx) {
    NodeTypeFillerContext *_localctx = _tracker.createInstance<NodeTypeFillerContext>(_ctx, getState());
    enterRule(_localctx, 590, GQLParser::RuleNodeTypeFiller);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2857);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 263, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2852);
        {
          auto childCtxHolder = ctx->EnterNodeTypeKeyLabelSet();
          nodeTypeKeyLabelSet(get_raw_pointer(childCtxHolder));
        }
        setState(2854);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 262, _ctx)) {
        case 1: {
          setState(2853);
          {
            auto childCtxHolder = ctx->EnterNodeTypeImpliedContent();
            nodeTypeImpliedContent(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2856);
        {
          auto childCtxHolder = ctx->EnterNodeTypeImpliedContent();
          nodeTypeImpliedContent(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LocalNodeTypeAliasContext : public antlr4::ParserRuleContext {
  public:
    LocalNodeTypeAliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    RegularIdentifierContext *regularIdentifier();

   
  };

  template<typename ContextT>
  LocalNodeTypeAliasContext* localNodeTypeAlias(ContextT* ctx) {
    LocalNodeTypeAliasContext *_localctx = _tracker.createInstance<LocalNodeTypeAliasContext>(_ctx, getState());
    enterRule(_localctx, 592, GQLParser::RuleLocalNodeTypeAlias);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2859);
      {
        auto childCtxHolder = ctx->EnterRegularIdentifier();
        regularIdentifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NodeTypeImpliedContentContext : public antlr4::ParserRuleContext {
  public:
    NodeTypeImpliedContentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NodeTypeLabelSetContext *nodeTypeLabelSet();
    NodeTypePropertyTypesContext *nodeTypePropertyTypes();

   
  };

  template<typename ContextT>
  NodeTypeImpliedContentContext* nodeTypeImpliedContent(ContextT* ctx) {
    NodeTypeImpliedContentContext *_localctx = _tracker.createInstance<NodeTypeImpliedContentContext>(_ctx, getState());
    enterRule(_localctx, 594, GQLParser::RuleNodeTypeImpliedContent);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2866);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 264, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2861);
        {
          auto childCtxHolder = ctx->EnterNodeTypeLabelSet();
          nodeTypeLabelSet(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2862);
        {
          auto childCtxHolder = ctx->EnterNodeTypePropertyTypes();
          nodeTypePropertyTypes(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2863);
        {
          auto childCtxHolder = ctx->EnterNodeTypeLabelSet();
          nodeTypeLabelSet(get_raw_pointer(childCtxHolder));
        }
        setState(2864);
        {
          auto childCtxHolder = ctx->EnterNodeTypePropertyTypes();
          nodeTypePropertyTypes(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NodeTypeKeyLabelSetContext : public antlr4::ParserRuleContext {
  public:
    NodeTypeKeyLabelSetContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IMPLIES();
    LabelSetPhraseContext *labelSetPhrase();

   
  };

  template<typename ContextT>
  NodeTypeKeyLabelSetContext* nodeTypeKeyLabelSet(ContextT* ctx) {
    NodeTypeKeyLabelSetContext *_localctx = _tracker.createInstance<NodeTypeKeyLabelSetContext>(_ctx, getState());
    enterRule(_localctx, 596, GQLParser::RuleNodeTypeKeyLabelSet);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2869);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IS || _la == GQLParser::LABEL

      || _la == GQLParser::LABELS || _la == GQLParser::COLON) {
        setState(2868);
        {
          auto childCtxHolder = ctx->EnterLabelSetPhrase();
          labelSetPhrase(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2871);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IMPLIES) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IMPLIES);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NodeTypeLabelSetContext : public antlr4::ParserRuleContext {
  public:
    NodeTypeLabelSetContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    LabelSetPhraseContext *labelSetPhrase();

   
  };

  template<typename ContextT>
  NodeTypeLabelSetContext* nodeTypeLabelSet(ContextT* ctx) {
    NodeTypeLabelSetContext *_localctx = _tracker.createInstance<NodeTypeLabelSetContext>(_ctx, getState());
    enterRule(_localctx, 598, GQLParser::RuleNodeTypeLabelSet);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2873);
      {
        auto childCtxHolder = ctx->EnterLabelSetPhrase();
        labelSetPhrase(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NodeTypePropertyTypesContext : public antlr4::ParserRuleContext {
  public:
    NodeTypePropertyTypesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PropertyTypesSpecificationContext *propertyTypesSpecification();

   
  };

  template<typename ContextT>
  NodeTypePropertyTypesContext* nodeTypePropertyTypes(ContextT* ctx) {
    NodeTypePropertyTypesContext *_localctx = _tracker.createInstance<NodeTypePropertyTypesContext>(_ctx, getState());
    enterRule(_localctx, 600, GQLParser::RuleNodeTypePropertyTypes);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2875);
      {
        auto childCtxHolder = ctx->EnterPropertyTypesSpecification();
        propertyTypesSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeTypeSpecificationContext : public antlr4::ParserRuleContext {
  public:
    EdgeTypeSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    EdgeTypePatternContext *edgeTypePattern();
    EdgeTypePhraseContext *edgeTypePhrase();

   
  };

  template<typename ContextT>
  EdgeTypeSpecificationContext* edgeTypeSpecification(ContextT* ctx) {
    EdgeTypeSpecificationContext *_localctx = _tracker.createInstance<EdgeTypeSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 602, GQLParser::RuleEdgeTypeSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2879);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 266, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2877);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePattern();
          edgeTypePattern(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2878);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePhrase();
          edgeTypePhrase(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeTypePatternContext : public antlr4::ParserRuleContext {
  public:
    EdgeTypePatternContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    EdgeTypePatternDirectedContext *edgeTypePatternDirected();
    EdgeTypePatternUndirectedContext *edgeTypePatternUndirected();
    EdgeSynonymContext *edgeSynonym();
    EdgeTypeNameContext *edgeTypeName();
    EdgeKindContext *edgeKind();
    antlr4::tree::TerminalNode *TYPE();

   
  };

  template<typename ContextT>
  EdgeTypePatternContext* edgeTypePattern(ContextT* ctx) {
    EdgeTypePatternContext *_localctx = _tracker.createInstance<EdgeTypePatternContext>(_ctx, getState());
    enterRule(_localctx, 604, GQLParser::RuleEdgeTypePattern);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2890);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 283) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 283)) & 68736253955) != 0)) {
        setState(2882);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::DIRECTED

        || _la == GQLParser::UNDIRECTED) {
          setState(2881);
          {
            auto childCtxHolder = ctx->EnterEdgeKind();
            edgeKind(get_raw_pointer(childCtxHolder));
          }
        }
        setState(2884);
        {
          auto childCtxHolder = ctx->EnterEdgeSynonym();
          edgeSynonym(get_raw_pointer(childCtxHolder));
        }
        setState(2886);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::TYPE) {
          setState(2885);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TYPE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TYPE);
        }
        setState(2888);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeName();
          edgeTypeName(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2894);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 270, _ctx)) {
      case 1: {
        setState(2892);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePatternDirected();
          edgeTypePatternDirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        setState(2893);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePatternUndirected();
          edgeTypePatternUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeTypePhraseContext : public antlr4::ParserRuleContext {
  public:
    EdgeTypePhraseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    EdgeKindContext *edgeKind();
    EdgeSynonymContext *edgeSynonym();
    EdgeTypePhraseFillerContext *edgeTypePhraseFiller();
    EndpointPairPhraseContext *endpointPairPhrase();
    antlr4::tree::TerminalNode *TYPE();

   
  };

  template<typename ContextT>
  EdgeTypePhraseContext* edgeTypePhrase(ContextT* ctx) {
    EdgeTypePhraseContext *_localctx = _tracker.createInstance<EdgeTypePhraseContext>(_ctx, getState());
    enterRule(_localctx, 606, GQLParser::RuleEdgeTypePhrase);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2896);
      {
        auto childCtxHolder = ctx->EnterEdgeKind();
        edgeKind(get_raw_pointer(childCtxHolder));
      }
      setState(2897);
      {
        auto childCtxHolder = ctx->EnterEdgeSynonym();
        edgeSynonym(get_raw_pointer(childCtxHolder));
      }
      setState(2899);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::TYPE) {
        setState(2898);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::TYPE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::TYPE);
      }
      setState(2901);
      {
        auto childCtxHolder = ctx->EnterEdgeTypePhraseFiller();
        edgeTypePhraseFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2902);
      {
        auto childCtxHolder = ctx->EnterEndpointPairPhrase();
        endpointPairPhrase(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeTypePhraseFillerContext : public antlr4::ParserRuleContext {
  public:
    EdgeTypePhraseFillerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    EdgeTypeNameContext *edgeTypeName();
    EdgeTypeFillerContext *edgeTypeFiller();

   
  };

  template<typename ContextT>
  EdgeTypePhraseFillerContext* edgeTypePhraseFiller(ContextT* ctx) {
    EdgeTypePhraseFillerContext *_localctx = _tracker.createInstance<EdgeTypePhraseFillerContext>(_ctx, getState());
    enterRule(_localctx, 608, GQLParser::RuleEdgeTypePhraseFiller);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2909);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 273, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2904);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeName();
          edgeTypeName(get_raw_pointer(childCtxHolder));
        }
        setState(2906);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::IMPLIES || _la == GQLParser::IS || _la == GQLParser::LABEL

        || _la == GQLParser::LABELS || _la == GQLParser::COLON

        || _la == GQLParser::LEFT_BRACE) {
          setState(2905);
          {
            auto childCtxHolder = ctx->EnterEdgeTypeFiller();
            edgeTypeFiller(get_raw_pointer(childCtxHolder));
          }
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2908);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeFiller();
          edgeTypeFiller(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeTypeFillerContext : public antlr4::ParserRuleContext {
  public:
    EdgeTypeFillerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    EdgeTypeKeyLabelSetContext *edgeTypeKeyLabelSet();
    EdgeTypeImpliedContentContext *edgeTypeImpliedContent();

   
  };

  template<typename ContextT>
  EdgeTypeFillerContext* edgeTypeFiller(ContextT* ctx) {
    EdgeTypeFillerContext *_localctx = _tracker.createInstance<EdgeTypeFillerContext>(_ctx, getState());
    enterRule(_localctx, 610, GQLParser::RuleEdgeTypeFiller);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2916);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 275, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2911);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeKeyLabelSet();
          edgeTypeKeyLabelSet(get_raw_pointer(childCtxHolder));
        }
        setState(2913);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::IS || _la == GQLParser::LABEL

        || _la == GQLParser::LABELS || _la == GQLParser::COLON

        || _la == GQLParser::LEFT_BRACE) {
          setState(2912);
          {
            auto childCtxHolder = ctx->EnterEdgeTypeImpliedContent();
            edgeTypeImpliedContent(get_raw_pointer(childCtxHolder));
          }
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2915);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeImpliedContent();
          edgeTypeImpliedContent(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeTypeImpliedContentContext : public antlr4::ParserRuleContext {
  public:
    EdgeTypeImpliedContentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    EdgeTypeLabelSetContext *edgeTypeLabelSet();
    EdgeTypePropertyTypesContext *edgeTypePropertyTypes();

   
  };

  template<typename ContextT>
  EdgeTypeImpliedContentContext* edgeTypeImpliedContent(ContextT* ctx) {
    EdgeTypeImpliedContentContext *_localctx = _tracker.createInstance<EdgeTypeImpliedContentContext>(_ctx, getState());
    enterRule(_localctx, 612, GQLParser::RuleEdgeTypeImpliedContent);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2923);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 276, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2918);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeLabelSet();
          edgeTypeLabelSet(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2919);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePropertyTypes();
          edgeTypePropertyTypes(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2920);
        {
          auto childCtxHolder = ctx->EnterEdgeTypeLabelSet();
          edgeTypeLabelSet(get_raw_pointer(childCtxHolder));
        }
        setState(2921);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePropertyTypes();
          edgeTypePropertyTypes(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeTypeKeyLabelSetContext : public antlr4::ParserRuleContext {
  public:
    EdgeTypeKeyLabelSetContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IMPLIES();
    LabelSetPhraseContext *labelSetPhrase();

   
  };

  template<typename ContextT>
  EdgeTypeKeyLabelSetContext* edgeTypeKeyLabelSet(ContextT* ctx) {
    EdgeTypeKeyLabelSetContext *_localctx = _tracker.createInstance<EdgeTypeKeyLabelSetContext>(_ctx, getState());
    enterRule(_localctx, 614, GQLParser::RuleEdgeTypeKeyLabelSet);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2926);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::IS || _la == GQLParser::LABEL

      || _la == GQLParser::LABELS || _la == GQLParser::COLON) {
        setState(2925);
        {
          auto childCtxHolder = ctx->EnterLabelSetPhrase();
          labelSetPhrase(get_raw_pointer(childCtxHolder));
        }
      }
      setState(2928);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IMPLIES) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IMPLIES);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeTypeLabelSetContext : public antlr4::ParserRuleContext {
  public:
    EdgeTypeLabelSetContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    LabelSetPhraseContext *labelSetPhrase();

   
  };

  template<typename ContextT>
  EdgeTypeLabelSetContext* edgeTypeLabelSet(ContextT* ctx) {
    EdgeTypeLabelSetContext *_localctx = _tracker.createInstance<EdgeTypeLabelSetContext>(_ctx, getState());
    enterRule(_localctx, 616, GQLParser::RuleEdgeTypeLabelSet);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2930);
      {
        auto childCtxHolder = ctx->EnterLabelSetPhrase();
        labelSetPhrase(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeTypePropertyTypesContext : public antlr4::ParserRuleContext {
  public:
    EdgeTypePropertyTypesContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PropertyTypesSpecificationContext *propertyTypesSpecification();

   
  };

  template<typename ContextT>
  EdgeTypePropertyTypesContext* edgeTypePropertyTypes(ContextT* ctx) {
    EdgeTypePropertyTypesContext *_localctx = _tracker.createInstance<EdgeTypePropertyTypesContext>(_ctx, getState());
    enterRule(_localctx, 618, GQLParser::RuleEdgeTypePropertyTypes);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2932);
      {
        auto childCtxHolder = ctx->EnterPropertyTypesSpecification();
        propertyTypesSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeTypePatternDirectedContext : public antlr4::ParserRuleContext {
  public:
    EdgeTypePatternDirectedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    EdgeTypePatternPointingRightContext *edgeTypePatternPointingRight();
    EdgeTypePatternPointingLeftContext *edgeTypePatternPointingLeft();

   
  };

  template<typename ContextT>
  EdgeTypePatternDirectedContext* edgeTypePatternDirected(ContextT* ctx) {
    EdgeTypePatternDirectedContext *_localctx = _tracker.createInstance<EdgeTypePatternDirectedContext>(_ctx, getState());
    enterRule(_localctx, 620, GQLParser::RuleEdgeTypePatternDirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2936);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 278, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2934);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePatternPointingRight();
          edgeTypePatternPointingRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2935);
        {
          auto childCtxHolder = ctx->EnterEdgeTypePatternPointingLeft();
          edgeTypePatternPointingLeft(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeTypePatternPointingRightContext : public antlr4::ParserRuleContext {
  public:
    EdgeTypePatternPointingRightContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SourceNodeTypeReferenceContext *sourceNodeTypeReference();
    ArcTypePointingRightContext *arcTypePointingRight();
    DestinationNodeTypeReferenceContext *destinationNodeTypeReference();

   
  };

  template<typename ContextT>
  EdgeTypePatternPointingRightContext* edgeTypePatternPointingRight(ContextT* ctx) {
    EdgeTypePatternPointingRightContext *_localctx = _tracker.createInstance<EdgeTypePatternPointingRightContext>(_ctx, getState());
    enterRule(_localctx, 622, GQLParser::RuleEdgeTypePatternPointingRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2938);
      {
        auto childCtxHolder = ctx->EnterSourceNodeTypeReference();
        sourceNodeTypeReference(get_raw_pointer(childCtxHolder));
      }
      setState(2939);
      {
        auto childCtxHolder = ctx->EnterArcTypePointingRight();
        arcTypePointingRight(get_raw_pointer(childCtxHolder));
      }
      setState(2940);
      {
        auto childCtxHolder = ctx->EnterDestinationNodeTypeReference();
        destinationNodeTypeReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeTypePatternPointingLeftContext : public antlr4::ParserRuleContext {
  public:
    EdgeTypePatternPointingLeftContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DestinationNodeTypeReferenceContext *destinationNodeTypeReference();
    ArcTypePointingLeftContext *arcTypePointingLeft();
    SourceNodeTypeReferenceContext *sourceNodeTypeReference();

   
  };

  template<typename ContextT>
  EdgeTypePatternPointingLeftContext* edgeTypePatternPointingLeft(ContextT* ctx) {
    EdgeTypePatternPointingLeftContext *_localctx = _tracker.createInstance<EdgeTypePatternPointingLeftContext>(_ctx, getState());
    enterRule(_localctx, 624, GQLParser::RuleEdgeTypePatternPointingLeft);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2942);
      {
        auto childCtxHolder = ctx->EnterDestinationNodeTypeReference();
        destinationNodeTypeReference(get_raw_pointer(childCtxHolder));
      }
      setState(2943);
      {
        auto childCtxHolder = ctx->EnterArcTypePointingLeft();
        arcTypePointingLeft(get_raw_pointer(childCtxHolder));
      }
      setState(2944);
      {
        auto childCtxHolder = ctx->EnterSourceNodeTypeReference();
        sourceNodeTypeReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeTypePatternUndirectedContext : public antlr4::ParserRuleContext {
  public:
    EdgeTypePatternUndirectedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SourceNodeTypeReferenceContext *sourceNodeTypeReference();
    ArcTypeUndirectedContext *arcTypeUndirected();
    DestinationNodeTypeReferenceContext *destinationNodeTypeReference();

   
  };

  template<typename ContextT>
  EdgeTypePatternUndirectedContext* edgeTypePatternUndirected(ContextT* ctx) {
    EdgeTypePatternUndirectedContext *_localctx = _tracker.createInstance<EdgeTypePatternUndirectedContext>(_ctx, getState());
    enterRule(_localctx, 626, GQLParser::RuleEdgeTypePatternUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2946);
      {
        auto childCtxHolder = ctx->EnterSourceNodeTypeReference();
        sourceNodeTypeReference(get_raw_pointer(childCtxHolder));
      }
      setState(2947);
      {
        auto childCtxHolder = ctx->EnterArcTypeUndirected();
        arcTypeUndirected(get_raw_pointer(childCtxHolder));
      }
      setState(2948);
      {
        auto childCtxHolder = ctx->EnterDestinationNodeTypeReference();
        destinationNodeTypeReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ArcTypePointingRightContext : public antlr4::ParserRuleContext {
  public:
    ArcTypePointingRightContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MINUS_LEFT_BRACKET();
    EdgeTypeFillerContext *edgeTypeFiller();
    antlr4::tree::TerminalNode *BRACKET_RIGHT_ARROW();

   
  };

  template<typename ContextT>
  ArcTypePointingRightContext* arcTypePointingRight(ContextT* ctx) {
    ArcTypePointingRightContext *_localctx = _tracker.createInstance<ArcTypePointingRightContext>(_ctx, getState());
    enterRule(_localctx, 628, GQLParser::RuleArcTypePointingRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2950);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MINUS_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MINUS_LEFT_BRACKET);
      setState(2951);
      {
        auto childCtxHolder = ctx->EnterEdgeTypeFiller();
        edgeTypeFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2952);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BRACKET_RIGHT_ARROW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BRACKET_RIGHT_ARROW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ArcTypePointingLeftContext : public antlr4::ParserRuleContext {
  public:
    ArcTypePointingLeftContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_ARROW_BRACKET();
    EdgeTypeFillerContext *edgeTypeFiller();
    antlr4::tree::TerminalNode *RIGHT_BRACKET_MINUS();

   
  };

  template<typename ContextT>
  ArcTypePointingLeftContext* arcTypePointingLeft(ContextT* ctx) {
    ArcTypePointingLeftContext *_localctx = _tracker.createInstance<ArcTypePointingLeftContext>(_ctx, getState());
    enterRule(_localctx, 630, GQLParser::RuleArcTypePointingLeft);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2954);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ARROW_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ARROW_BRACKET);
      setState(2955);
      {
        auto childCtxHolder = ctx->EnterEdgeTypeFiller();
        edgeTypeFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2956);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_MINUS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_MINUS);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ArcTypeUndirectedContext : public antlr4::ParserRuleContext {
  public:
    ArcTypeUndirectedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TILDE_LEFT_BRACKET();
    EdgeTypeFillerContext *edgeTypeFiller();
    antlr4::tree::TerminalNode *RIGHT_BRACKET_TILDE();

   
  };

  template<typename ContextT>
  ArcTypeUndirectedContext* arcTypeUndirected(ContextT* ctx) {
    ArcTypeUndirectedContext *_localctx = _tracker.createInstance<ArcTypeUndirectedContext>(_ctx, getState());
    enterRule(_localctx, 632, GQLParser::RuleArcTypeUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2958);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TILDE_LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TILDE_LEFT_BRACKET);
      setState(2959);
      {
        auto childCtxHolder = ctx->EnterEdgeTypeFiller();
        edgeTypeFiller(get_raw_pointer(childCtxHolder));
      }
      setState(2960);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET_TILDE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET_TILDE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SourceNodeTypeReferenceContext : public antlr4::ParserRuleContext {
  public:
    SourceNodeTypeReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SourceNodeTypeAliasContext *sourceNodeTypeAlias();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    NodeTypeFillerContext *nodeTypeFiller();

   
  };

  template<typename ContextT>
  SourceNodeTypeReferenceContext* sourceNodeTypeReference(ContextT* ctx) {
    SourceNodeTypeReferenceContext *_localctx = _tracker.createInstance<SourceNodeTypeReferenceContext>(_ctx, getState());
    enterRule(_localctx, 634, GQLParser::RuleSourceNodeTypeReference);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2971);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 280, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2962);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(2963);
        {
          auto childCtxHolder = ctx->EnterSourceNodeTypeAlias();
          sourceNodeTypeAlias(get_raw_pointer(childCtxHolder));
        }
        setState(2964);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2966);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(2968);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::IMPLIES || _la == GQLParser::IS || _la == GQLParser::LABEL

        || _la == GQLParser::LABELS || _la == GQLParser::COLON

        || _la == GQLParser::LEFT_BRACE) {
          setState(2967);
          {
            auto childCtxHolder = ctx->EnterNodeTypeFiller();
            nodeTypeFiller(get_raw_pointer(childCtxHolder));
          }
        }
        setState(2970);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DestinationNodeTypeReferenceContext : public antlr4::ParserRuleContext {
  public:
    DestinationNodeTypeReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    DestinationNodeTypeAliasContext *destinationNodeTypeAlias();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    NodeTypeFillerContext *nodeTypeFiller();

   
  };

  template<typename ContextT>
  DestinationNodeTypeReferenceContext* destinationNodeTypeReference(ContextT* ctx) {
    DestinationNodeTypeReferenceContext *_localctx = _tracker.createInstance<DestinationNodeTypeReferenceContext>(_ctx, getState());
    enterRule(_localctx, 636, GQLParser::RuleDestinationNodeTypeReference);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2982);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 282, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2973);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(2974);
        {
          auto childCtxHolder = ctx->EnterDestinationNodeTypeAlias();
          destinationNodeTypeAlias(get_raw_pointer(childCtxHolder));
        }
        setState(2975);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2977);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(2979);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::IMPLIES || _la == GQLParser::IS || _la == GQLParser::LABEL

        || _la == GQLParser::LABELS || _la == GQLParser::COLON

        || _la == GQLParser::LEFT_BRACE) {
          setState(2978);
          {
            auto childCtxHolder = ctx->EnterNodeTypeFiller();
            nodeTypeFiller(get_raw_pointer(childCtxHolder));
          }
        }
        setState(2981);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeKindContext : public antlr4::ParserRuleContext {
  public:
    EdgeKindContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DIRECTED();
    antlr4::tree::TerminalNode *UNDIRECTED();

   
  };

  template<typename ContextT>
  EdgeKindContext* edgeKind(ContextT* ctx) {
    EdgeKindContext *_localctx = _tracker.createInstance<EdgeKindContext>(_ctx, getState());
    enterRule(_localctx, 638, GQLParser::RuleEdgeKind);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2984);
      _la = _input->LA(1);
      if (!(_la == GQLParser::DIRECTED

      || _la == GQLParser::UNDIRECTED)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EndpointPairPhraseContext : public antlr4::ParserRuleContext {
  public:
    EndpointPairPhraseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CONNECTING();
    EndpointPairContext *endpointPair();

   
  };

  template<typename ContextT>
  EndpointPairPhraseContext* endpointPairPhrase(ContextT* ctx) {
    EndpointPairPhraseContext *_localctx = _tracker.createInstance<EndpointPairPhraseContext>(_ctx, getState());
    enterRule(_localctx, 640, GQLParser::RuleEndpointPairPhrase);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2986);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CONNECTING) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CONNECTING);
      setState(2987);
      {
        auto childCtxHolder = ctx->EnterEndpointPair();
        endpointPair(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EndpointPairContext : public antlr4::ParserRuleContext {
  public:
    EndpointPairContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    EndpointPairDirectedContext *endpointPairDirected();
    EndpointPairUndirectedContext *endpointPairUndirected();

   
  };

  template<typename ContextT>
  EndpointPairContext* endpointPair(ContextT* ctx) {
    EndpointPairContext *_localctx = _tracker.createInstance<EndpointPairContext>(_ctx, getState());
    enterRule(_localctx, 642, GQLParser::RuleEndpointPair);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2991);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 283, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2989);
        {
          auto childCtxHolder = ctx->EnterEndpointPairDirected();
          endpointPairDirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2990);
        {
          auto childCtxHolder = ctx->EnterEndpointPairUndirected();
          endpointPairUndirected(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EndpointPairDirectedContext : public antlr4::ParserRuleContext {
  public:
    EndpointPairDirectedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    EndpointPairPointingRightContext *endpointPairPointingRight();
    EndpointPairPointingLeftContext *endpointPairPointingLeft();

   
  };

  template<typename ContextT>
  EndpointPairDirectedContext* endpointPairDirected(ContextT* ctx) {
    EndpointPairDirectedContext *_localctx = _tracker.createInstance<EndpointPairDirectedContext>(_ctx, getState());
    enterRule(_localctx, 644, GQLParser::RuleEndpointPairDirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(2995);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 284, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2993);
        {
          auto childCtxHolder = ctx->EnterEndpointPairPointingRight();
          endpointPairPointingRight(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2994);
        {
          auto childCtxHolder = ctx->EnterEndpointPairPointingLeft();
          endpointPairPointingLeft(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EndpointPairPointingRightContext : public antlr4::ParserRuleContext {
  public:
    EndpointPairPointingRightContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SourceNodeTypeAliasContext *sourceNodeTypeAlias();
    ConnectorPointingRightContext *connectorPointingRight();
    DestinationNodeTypeAliasContext *destinationNodeTypeAlias();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  EndpointPairPointingRightContext* endpointPairPointingRight(ContextT* ctx) {
    EndpointPairPointingRightContext *_localctx = _tracker.createInstance<EndpointPairPointingRightContext>(_ctx, getState());
    enterRule(_localctx, 646, GQLParser::RuleEndpointPairPointingRight);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(2997);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(2998);
      {
        auto childCtxHolder = ctx->EnterSourceNodeTypeAlias();
        sourceNodeTypeAlias(get_raw_pointer(childCtxHolder));
      }
      setState(2999);
      {
        auto childCtxHolder = ctx->EnterConnectorPointingRight();
        connectorPointingRight(get_raw_pointer(childCtxHolder));
      }
      setState(3000);
      {
        auto childCtxHolder = ctx->EnterDestinationNodeTypeAlias();
        destinationNodeTypeAlias(get_raw_pointer(childCtxHolder));
      }
      setState(3001);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EndpointPairPointingLeftContext : public antlr4::ParserRuleContext {
  public:
    EndpointPairPointingLeftContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    DestinationNodeTypeAliasContext *destinationNodeTypeAlias();
    antlr4::tree::TerminalNode *LEFT_ARROW();
    SourceNodeTypeAliasContext *sourceNodeTypeAlias();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  EndpointPairPointingLeftContext* endpointPairPointingLeft(ContextT* ctx) {
    EndpointPairPointingLeftContext *_localctx = _tracker.createInstance<EndpointPairPointingLeftContext>(_ctx, getState());
    enterRule(_localctx, 648, GQLParser::RuleEndpointPairPointingLeft);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3003);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3004);
      {
        auto childCtxHolder = ctx->EnterDestinationNodeTypeAlias();
        destinationNodeTypeAlias(get_raw_pointer(childCtxHolder));
      }
      setState(3005);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_ARROW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_ARROW);
      setState(3006);
      {
        auto childCtxHolder = ctx->EnterSourceNodeTypeAlias();
        sourceNodeTypeAlias(get_raw_pointer(childCtxHolder));
      }
      setState(3007);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EndpointPairUndirectedContext : public antlr4::ParserRuleContext {
  public:
    EndpointPairUndirectedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    SourceNodeTypeAliasContext *sourceNodeTypeAlias();
    ConnectorUndirectedContext *connectorUndirected();
    DestinationNodeTypeAliasContext *destinationNodeTypeAlias();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  EndpointPairUndirectedContext* endpointPairUndirected(ContextT* ctx) {
    EndpointPairUndirectedContext *_localctx = _tracker.createInstance<EndpointPairUndirectedContext>(_ctx, getState());
    enterRule(_localctx, 650, GQLParser::RuleEndpointPairUndirected);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3009);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3010);
      {
        auto childCtxHolder = ctx->EnterSourceNodeTypeAlias();
        sourceNodeTypeAlias(get_raw_pointer(childCtxHolder));
      }
      setState(3011);
      {
        auto childCtxHolder = ctx->EnterConnectorUndirected();
        connectorUndirected(get_raw_pointer(childCtxHolder));
      }
      setState(3012);
      {
        auto childCtxHolder = ctx->EnterDestinationNodeTypeAlias();
        destinationNodeTypeAlias(get_raw_pointer(childCtxHolder));
      }
      setState(3013);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ConnectorPointingRightContext : public antlr4::ParserRuleContext {
  public:
    ConnectorPointingRightContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *RIGHT_ARROW();

   
  };

  template<typename ContextT>
  ConnectorPointingRightContext* connectorPointingRight(ContextT* ctx) {
    ConnectorPointingRightContext *_localctx = _tracker.createInstance<ConnectorPointingRightContext>(_ctx, getState());
    enterRule(_localctx, 652, GQLParser::RuleConnectorPointingRight);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3015);
      _la = _input->LA(1);
      if (!(_la == GQLParser::TO

      || _la == GQLParser::RIGHT_ARROW)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ConnectorUndirectedContext : public antlr4::ParserRuleContext {
  public:
    ConnectorUndirectedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *TILDE();

   
  };

  template<typename ContextT>
  ConnectorUndirectedContext* connectorUndirected(ContextT* ctx) {
    ConnectorUndirectedContext *_localctx = _tracker.createInstance<ConnectorUndirectedContext>(_ctx, getState());
    enterRule(_localctx, 654, GQLParser::RuleConnectorUndirected);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3017);
      _la = _input->LA(1);
      if (!(_la == GQLParser::TO || _la == GQLParser::TILDE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SourceNodeTypeAliasContext : public antlr4::ParserRuleContext {
  public:
    SourceNodeTypeAliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    RegularIdentifierContext *regularIdentifier();

   
  };

  template<typename ContextT>
  SourceNodeTypeAliasContext* sourceNodeTypeAlias(ContextT* ctx) {
    SourceNodeTypeAliasContext *_localctx = _tracker.createInstance<SourceNodeTypeAliasContext>(_ctx, getState());
    enterRule(_localctx, 656, GQLParser::RuleSourceNodeTypeAlias);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3019);
      {
        auto childCtxHolder = ctx->EnterRegularIdentifier();
        regularIdentifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DestinationNodeTypeAliasContext : public antlr4::ParserRuleContext {
  public:
    DestinationNodeTypeAliasContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    RegularIdentifierContext *regularIdentifier();

   
  };

  template<typename ContextT>
  DestinationNodeTypeAliasContext* destinationNodeTypeAlias(ContextT* ctx) {
    DestinationNodeTypeAliasContext *_localctx = _tracker.createInstance<DestinationNodeTypeAliasContext>(_ctx, getState());
    enterRule(_localctx, 658, GQLParser::RuleDestinationNodeTypeAlias);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3021);
      {
        auto childCtxHolder = ctx->EnterRegularIdentifier();
        regularIdentifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LabelSetPhraseContext : public antlr4::ParserRuleContext {
  public:
    LabelSetPhraseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LABEL();
    LabelNameContext *labelName();
    antlr4::tree::TerminalNode *LABELS();
    LabelSetSpecificationContext *labelSetSpecification();
    IsOrColonContext *isOrColon();

   
  };

  template<typename ContextT>
  LabelSetPhraseContext* labelSetPhrase(ContextT* ctx) {
    LabelSetPhraseContext *_localctx = _tracker.createInstance<LabelSetPhraseContext>(_ctx, getState());
    enterRule(_localctx, 660, GQLParser::RuleLabelSetPhrase);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3030);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LABEL: {
          enterOuterAlt(_localctx, 1);
          setState(3023);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LABEL) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LABEL);
          setState(3024);
          {
            auto childCtxHolder = ctx->EnterLabelName();
            labelName(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LABELS: {
          enterOuterAlt(_localctx, 2);
          setState(3025);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LABELS) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LABELS);
          setState(3026);
          {
            auto childCtxHolder = ctx->EnterLabelSetSpecification();
            labelSetSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::IS:
        case GQLParser::COLON: {
          enterOuterAlt(_localctx, 3);
          setState(3027);
          {
            auto childCtxHolder = ctx->EnterIsOrColon();
            isOrColon(get_raw_pointer(childCtxHolder));
          }
          setState(3028);
          {
            auto childCtxHolder = ctx->EnterLabelSetSpecification();
            labelSetSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LabelSetSpecificationContext : public antlr4::ParserRuleContext {
  public:
    LabelSetSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<LabelNameContext *> labelName();
    LabelNameContext* labelName(size_t i);
    std::vector<antlr4::tree::TerminalNode *> AMPERSAND();
    antlr4::tree::TerminalNode* AMPERSAND(size_t i);

   
  };

  template<typename ContextT>
  LabelSetSpecificationContext* labelSetSpecification(ContextT* ctx) {
    LabelSetSpecificationContext *_localctx = _tracker.createInstance<LabelSetSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 662, GQLParser::RuleLabelSetSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(3032);
      {
        auto childCtxHolder = ctx->EnterLabelName();
        labelName(get_raw_pointer(childCtxHolder));
      }
      setState(3037);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 286, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3033);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::AMPERSAND) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::AMPERSAND);
          setState(3034);
          {
            auto childCtxHolder = ctx->EnterLabelName();
            labelName(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(3039);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 286, _ctx);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PropertyTypesSpecificationContext : public antlr4::ParserRuleContext {
  public:
    PropertyTypesSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_BRACE();
    antlr4::tree::TerminalNode *RIGHT_BRACE();
    PropertyTypeListContext *propertyTypeList();

   
  };

  template<typename ContextT>
  PropertyTypesSpecificationContext* propertyTypesSpecification(ContextT* ctx) {
    PropertyTypesSpecificationContext *_localctx = _tracker.createInstance<PropertyTypesSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 664, GQLParser::RulePropertyTypesSpecification);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3040);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(3042);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE

      || _la == GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0)) {
        setState(3041);
        {
          auto childCtxHolder = ctx->EnterPropertyTypeList();
          propertyTypeList(get_raw_pointer(childCtxHolder));
        }
      }
      setState(3044);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PropertyTypeListContext : public antlr4::ParserRuleContext {
  public:
    PropertyTypeListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<PropertyTypeContext *> propertyType();
    PropertyTypeContext* propertyType(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  PropertyTypeListContext* propertyTypeList(ContextT* ctx) {
    PropertyTypeListContext *_localctx = _tracker.createInstance<PropertyTypeListContext>(_ctx, getState());
    enterRule(_localctx, 666, GQLParser::RulePropertyTypeList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3046);
      {
        auto childCtxHolder = ctx->EnterPropertyType();
        propertyType(get_raw_pointer(childCtxHolder));
      }
      setState(3051);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(3047);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(3048);
        {
          auto childCtxHolder = ctx->EnterPropertyType();
          propertyType(get_raw_pointer(childCtxHolder));
        }
        setState(3053);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PropertyTypeContext : public antlr4::ParserRuleContext {
  public:
    PropertyTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PropertyNameContext *propertyName();
    PropertyValueTypeContext *propertyValueType();
    TypedContext *typed();

   
  };

  template<typename ContextT>
  PropertyTypeContext* propertyType(ContextT* ctx) {
    PropertyTypeContext *_localctx = _tracker.createInstance<PropertyTypeContext>(_ctx, getState());
    enterRule(_localctx, 668, GQLParser::RulePropertyType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3054);
      {
        auto childCtxHolder = ctx->EnterPropertyName();
        propertyName(get_raw_pointer(childCtxHolder));
      }
      setState(3056);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
        setState(3055);
        {
          auto childCtxHolder = ctx->EnterTyped();
          typed(get_raw_pointer(childCtxHolder));
        }
      }
      setState(3058);
      {
        auto childCtxHolder = ctx->EnterPropertyValueType();
        propertyValueType(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PropertyValueTypeContext : public antlr4::ParserRuleContext {
  public:
    PropertyValueTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueTypeContext *valueType();

   
  };

  template<typename ContextT>
  PropertyValueTypeContext* propertyValueType(ContextT* ctx) {
    PropertyValueTypeContext *_localctx = _tracker.createInstance<PropertyValueTypeContext>(_ctx, getState());
    enterRule(_localctx, 670, GQLParser::RulePropertyValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3060);
      {
        auto childCtxHolder = ctx->EnterValueType();
        valueType(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BindingTableTypeContext : public antlr4::ParserRuleContext {
  public:
    BindingTableTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TABLE();
    FieldTypesSpecificationContext *fieldTypesSpecification();
    antlr4::tree::TerminalNode *BINDING();

   
  };

  template<typename ContextT>
  BindingTableTypeContext* bindingTableType(ContextT* ctx) {
    BindingTableTypeContext *_localctx = _tracker.createInstance<BindingTableTypeContext>(_ctx, getState());
    enterRule(_localctx, 672, GQLParser::RuleBindingTableType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3063);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::BINDING) {
        setState(3062);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::BINDING) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::BINDING);
      }
      setState(3065);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TABLE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TABLE);
      setState(3066);
      {
        auto childCtxHolder = ctx->EnterFieldTypesSpecification();
        fieldTypesSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ValueTypeContext : public antlr4::ParserRuleContext {
  public:
    ValueTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
   
    ValueTypeContext() = default;
    void copyFrom(ValueTypeContext *context);
    using antlr4::ParserRuleContext::copyFrom;

    virtual size_t getRuleIndex() const override;

   
  };

  class  DynamicPropertyValueTypeLabelContext : public ValueTypeContext {
  public:
    DynamicPropertyValueTypeLabelContext(ValueTypeContext *ctx);

    antlr4::tree::TerminalNode *PROPERTY();
    antlr4::tree::TerminalNode *VALUE();
    antlr4::tree::TerminalNode *ANY();
    NotNullContext *notNull();
  };

  class  ClosedDynamicUnionTypeAtl1Context : public ValueTypeContext {
  public:
    ClosedDynamicUnionTypeAtl1Context(ValueTypeContext *ctx);

    antlr4::tree::TerminalNode *ANY();
    antlr4::tree::TerminalNode *LEFT_ANGLE_BRACKET();
    std::vector<ValueTypeContext *> valueType();
    ValueTypeContext* valueType(size_t i);
    antlr4::tree::TerminalNode *RIGHT_ANGLE_BRACKET();
    antlr4::tree::TerminalNode *VALUE();
    std::vector<antlr4::tree::TerminalNode *> VERTICAL_BAR();
    antlr4::tree::TerminalNode* VERTICAL_BAR(size_t i);
  };

  class  ClosedDynamicUnionTypeAtl2Context : public ValueTypeContext {
  public:
    ClosedDynamicUnionTypeAtl2Context(ValueTypeContext *ctx);

    std::vector<ValueTypeContext *> valueType();
    ValueTypeContext* valueType(size_t i);
    antlr4::tree::TerminalNode *VERTICAL_BAR();
  };

  class  PathValueTypeLabelContext : public ValueTypeContext {
  public:
    PathValueTypeLabelContext(ValueTypeContext *ctx);

    PathValueTypeContext *pathValueType();
  };

  class  ListValueTypeAlt3Context : public ValueTypeContext {
  public:
    ListValueTypeAlt3Context(ValueTypeContext *ctx);

    ListValueTypeNameContext *listValueTypeName();
    antlr4::tree::TerminalNode *LEFT_BRACKET();
    MaxLengthContext *maxLength();
    antlr4::tree::TerminalNode *RIGHT_BRACKET();
    NotNullContext *notNull();
  };

  class  ListValueTypeAlt2Context : public ValueTypeContext {
  public:
    ListValueTypeAlt2Context(ValueTypeContext *ctx);

    ValueTypeContext *valueType();
    ListValueTypeNameContext *listValueTypeName();
    antlr4::tree::TerminalNode *LEFT_BRACKET();
    MaxLengthContext *maxLength();
    antlr4::tree::TerminalNode *RIGHT_BRACKET();
    NotNullContext *notNull();
  };

  class  ListValueTypeAlt1Context : public ValueTypeContext {
  public:
    ListValueTypeAlt1Context(ValueTypeContext *ctx);

    ListValueTypeNameContext *listValueTypeName();
    antlr4::tree::TerminalNode *LEFT_ANGLE_BRACKET();
    ValueTypeContext *valueType();
    antlr4::tree::TerminalNode *RIGHT_ANGLE_BRACKET();
    antlr4::tree::TerminalNode *LEFT_BRACKET();
    MaxLengthContext *maxLength();
    antlr4::tree::TerminalNode *RIGHT_BRACKET();
    NotNullContext *notNull();
  };

  class  PredefinedTypeLabelContext : public ValueTypeContext {
  public:
    PredefinedTypeLabelContext(ValueTypeContext *ctx);

    PredefinedTypeContext *predefinedType();
  };

  class  RecordTypeLabelContext : public ValueTypeContext {
  public:
    RecordTypeLabelContext(ValueTypeContext *ctx);

    RecordTypeContext *recordType();
  };

  class  OpenDynamicUnionTypeLabelContext : public ValueTypeContext {
  public:
    OpenDynamicUnionTypeLabelContext(ValueTypeContext *ctx);

    antlr4::tree::TerminalNode *ANY();
    antlr4::tree::TerminalNode *VALUE();
    NotNullContext *notNull();
  };


  template<typename ContextT>
  ValueTypeContext* valueType(ContextT* ctx) {
     return valueType(0, ctx);
  }

  template<typename ContextT>
  ValueTypeContext* valueType(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    GQLParser::ValueTypeContext *_localctx = _tracker.createInstance<ValueTypeContext>(_ctx, parentState);
    GQLParser::ValueTypeContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 674;
    enterRecursionRule(_localctx, 674, GQLParser::RuleValueType, precedence);

      size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(3125);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
      case 1: {
        _localctx = _tracker.createInstance<PredefinedTypeLabelContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterPredefinedTypeLabel();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });

        setState(3069);
        {
          auto childCtxHolder = ctx->EnterPredefinedType();
          predefinedType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        _localctx = _tracker.createInstance<PathValueTypeLabelContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterPathValueTypeLabel();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3070);
        {
          auto childCtxHolder = ctx->EnterPathValueType();
          pathValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        _localctx = _tracker.createInstance<ListValueTypeAlt1Context>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterListValueTypeAlt1();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3071);
        {
          auto childCtxHolder = ctx->EnterListValueTypeName();
          listValueTypeName(get_raw_pointer(childCtxHolder));
        }
        setState(3072);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_ANGLE_BRACKET) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_ANGLE_BRACKET);
        setState(3073);
        {
          auto childCtxHolder = ctx->EnterValueType();
          valueType(0, get_raw_pointer(childCtxHolder));
        }
        setState(3074);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_ANGLE_BRACKET) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_ANGLE_BRACKET);
        setState(3079);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 291, _ctx)) {
        case 1: {
          setState(3075);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_BRACKET) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_BRACKET);
          setState(3076);
          {
            auto childCtxHolder = ctx->EnterMaxLength();
            maxLength(get_raw_pointer(childCtxHolder));
          }
          setState(3077);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_BRACKET) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_BRACKET);
          break;
        }

        default:
          break;
        }
        setState(3082);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 292, _ctx)) {
        case 1: {
          setState(3081);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 4: {
        _localctx = _tracker.createInstance<ListValueTypeAlt3Context>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterListValueTypeAlt3();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3084);
        {
          auto childCtxHolder = ctx->EnterListValueTypeName();
          listValueTypeName(get_raw_pointer(childCtxHolder));
        }
        setState(3089);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 293, _ctx)) {
        case 1: {
          setState(3085);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_BRACKET) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_BRACKET);
          setState(3086);
          {
            auto childCtxHolder = ctx->EnterMaxLength();
            maxLength(get_raw_pointer(childCtxHolder));
          }
          setState(3087);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_BRACKET) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_BRACKET);
          break;
        }

        default:
          break;
        }
        setState(3092);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 294, _ctx)) {
        case 1: {
          setState(3091);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 5: {
        _localctx = _tracker.createInstance<RecordTypeLabelContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterRecordTypeLabel();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3094);
        {
          auto childCtxHolder = ctx->EnterRecordType();
          recordType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        _localctx = _tracker.createInstance<OpenDynamicUnionTypeLabelContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterOpenDynamicUnionTypeLabel();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3095);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::ANY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::ANY);
        setState(3097);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 295, _ctx)) {
        case 1: {
          setState(3096);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::VALUE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::VALUE);
          break;
        }

        default:
          break;
        }
        setState(3100);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx)) {
        case 1: {
          setState(3099);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 7: {
        _localctx = _tracker.createInstance<DynamicPropertyValueTypeLabelContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterDynamicPropertyValueTypeLabel();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3103);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::ANY) {
          setState(3102);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ANY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ANY);
        }
        setState(3105);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
        setState(3106);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::VALUE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::VALUE);
        setState(3108);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx)) {
        case 1: {
          setState(3107);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 8: {
        _localctx = _tracker.createInstance<ClosedDynamicUnionTypeAtl1Context>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterClosedDynamicUnionTypeAtl1();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3110);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::ANY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::ANY);
        setState(3112);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::VALUE) {
          setState(3111);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::VALUE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::VALUE);
        }
        setState(3114);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_ANGLE_BRACKET) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_ANGLE_BRACKET);
        setState(3115);
        {
          auto childCtxHolder = ctx->EnterValueType();
          valueType(0, get_raw_pointer(childCtxHolder));
        }
        setState(3120);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == GQLParser::VERTICAL_BAR) {
          setState(3116);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::VERTICAL_BAR) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::VERTICAL_BAR);
          setState(3117);
          {
            auto childCtxHolder = ctx->EnterValueType();
            valueType(0, get_raw_pointer(childCtxHolder));
          }
          setState(3122);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(3123);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_ANGLE_BRACKET) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_ANGLE_BRACKET);
        break;
      }

      default:
        break;
      }
      _ctx->stop = _input->LT(-1);
      setState(3143);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 305, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          setState(3141);
          _errHandler->sync(this);
          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 304, _ctx)) {
          case 1: {
            auto newContext = _tracker.createInstance<ClosedDynamicUnionTypeAtl2Context>(_tracker.createInstance<ValueTypeContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueType);
            auto ctxHolder = ctx->PushClosedDynamicUnionTypeAtl2_ValueType();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3127);

            if (!(precpred(_ctx, 1))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 1)");
            setState(3128);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::VERTICAL_BAR) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::VERTICAL_BAR);
            setState(3129);
            {
              auto childCtxHolder = ctx->EnterValueType();
              valueType(2, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 2: {
            auto newContext = _tracker.createInstance<ListValueTypeAlt2Context>(_tracker.createInstance<ValueTypeContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueType);
            auto ctxHolder = ctx->PushListValueTypeAlt2_ValueType();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3130);

            if (!(precpred(_ctx, 7))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 7)");
            setState(3131);
            {
              auto childCtxHolder = ctx->EnterListValueTypeName();
              listValueTypeName(get_raw_pointer(childCtxHolder));
            }
            setState(3136);
            _errHandler->sync(this);

            switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 302, _ctx)) {
            case 1: {
              setState(3132);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::LEFT_BRACKET) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::LEFT_BRACKET);
              setState(3133);
              {
                auto childCtxHolder = ctx->EnterMaxLength();
                maxLength(get_raw_pointer(childCtxHolder));
              }
              setState(3134);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::RIGHT_BRACKET) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::RIGHT_BRACKET);
              break;
            }

            default:
              break;
            }
            setState(3139);
            _errHandler->sync(this);

            switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx)) {
            case 1: {
              setState(3138);
              {
                auto childCtxHolder = ctx->EnterNotNull();
                notNull(get_raw_pointer(childCtxHolder));
              }
              break;
            }

            default:
              break;
            }
            break;
          }

          default:
            break;
          } 
        }
        setState(3145);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 305, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }

  class  TypedContext : public antlr4::ParserRuleContext {
  public:
    TypedContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DOUBLE_COLON();
    antlr4::tree::TerminalNode *TYPED();

   
  };

  template<typename ContextT>
  TypedContext* typed(ContextT* ctx) {
    TypedContext *_localctx = _tracker.createInstance<TypedContext>(_ctx, getState());
    enterRule(_localctx, 676, GQLParser::RuleTyped);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3146);
      _la = _input->LA(1);
      if (!(_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PredefinedTypeContext : public antlr4::ParserRuleContext {
  public:
    PredefinedTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BooleanTypeContext *booleanType();
    CharacterStringTypeContext *characterStringType();
    ByteStringTypeContext *byteStringType();
    NumericTypeContext *numericType();
    TemporalTypeContext *temporalType();
    ReferenceValueTypeContext *referenceValueType();
    ImmaterialValueTypeContext *immaterialValueType();

   
  };

  template<typename ContextT>
  PredefinedTypeContext* predefinedType(ContextT* ctx) {
    PredefinedTypeContext *_localctx = _tracker.createInstance<PredefinedTypeContext>(_ctx, getState());
    enterRule(_localctx, 678, GQLParser::RulePredefinedType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3155);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BOOL:
        case GQLParser::BOOLEAN: {
          enterOuterAlt(_localctx, 1);
          setState(3148);
          {
            auto childCtxHolder = ctx->EnterBooleanType();
            booleanType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CHAR:
        case GQLParser::STRING:
        case GQLParser::VARCHAR: {
          enterOuterAlt(_localctx, 2);
          setState(3149);
          {
            auto childCtxHolder = ctx->EnterCharacterStringType();
            characterStringType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BINARY:
        case GQLParser::BYTES:
        case GQLParser::VARBINARY: {
          enterOuterAlt(_localctx, 3);
          setState(3150);
          {
            auto childCtxHolder = ctx->EnterByteStringType();
            byteStringType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BIG:
        case GQLParser::BIGINT:
        case GQLParser::DEC:
        case GQLParser::DECIMAL:
        case GQLParser::DOUBLE:
        case GQLParser::FLOAT:
        case GQLParser::FLOAT16:
        case GQLParser::FLOAT32:
        case GQLParser::FLOAT64:
        case GQLParser::FLOAT128:
        case GQLParser::FLOAT256:
        case GQLParser::INT:
        case GQLParser::INTEGER:
        case GQLParser::INT8:
        case GQLParser::INTEGER8:
        case GQLParser::INT16:
        case GQLParser::INTEGER16:
        case GQLParser::INT32:
        case GQLParser::INTEGER32:
        case GQLParser::INT64:
        case GQLParser::INTEGER64:
        case GQLParser::INT128:
        case GQLParser::INTEGER128:
        case GQLParser::INT256:
        case GQLParser::INTEGER256:
        case GQLParser::REAL:
        case GQLParser::SIGNED:
        case GQLParser::SMALL:
        case GQLParser::SMALLINT:
        case GQLParser::UBIGINT:
        case GQLParser::UINT:
        case GQLParser::UINT8:
        case GQLParser::UINT16:
        case GQLParser::UINT32:
        case GQLParser::UINT64:
        case GQLParser::UINT128:
        case GQLParser::UINT256:
        case GQLParser::UNSIGNED:
        case GQLParser::USMALLINT: {
          enterOuterAlt(_localctx, 4);
          setState(3151);
          {
            auto childCtxHolder = ctx->EnterNumericType();
            numericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DATE:
        case GQLParser::DURATION:
        case GQLParser::LOCAL:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::ZONED: {
          enterOuterAlt(_localctx, 5);
          setState(3152);
          {
            auto childCtxHolder = ctx->EnterTemporalType();
            temporalType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ANY:
        case GQLParser::BINDING:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::GRAPH:
        case GQLParser::NODE:
        case GQLParser::PROPERTY:
        case GQLParser::RELATIONSHIP:
        case GQLParser::TABLE:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::LEFT_PAREN: {
          enterOuterAlt(_localctx, 6);
          setState(3153);
          {
            auto childCtxHolder = ctx->EnterReferenceValueType();
            referenceValueType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::NOTHING:
        case GQLParser::NULL_KW: {
          enterOuterAlt(_localctx, 7);
          setState(3154);
          {
            auto childCtxHolder = ctx->EnterImmaterialValueType();
            immaterialValueType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BooleanTypeContext : public antlr4::ParserRuleContext {
  public:
    BooleanTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BOOL();
    antlr4::tree::TerminalNode *BOOLEAN();
    NotNullContext *notNull();

   
  };

  template<typename ContextT>
  BooleanTypeContext* booleanType(ContextT* ctx) {
    BooleanTypeContext *_localctx = _tracker.createInstance<BooleanTypeContext>(_ctx, getState());
    enterRule(_localctx, 680, GQLParser::RuleBooleanType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3157);
      _la = _input->LA(1);
      if (!(_la == GQLParser::BOOL

      || _la == GQLParser::BOOLEAN)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(3159);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 307, _ctx)) {
      case 1: {
        setState(3158);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CharacterStringTypeContext : public antlr4::ParserRuleContext {
  public:
    CharacterStringTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *STRING();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    MaxLengthContext *maxLength();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    NotNullContext *notNull();
    MinLengthContext *minLength();
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *CHAR();
    FixedLengthContext *fixedLength();
    antlr4::tree::TerminalNode *VARCHAR();

   
  };

  template<typename ContextT>
  CharacterStringTypeContext* characterStringType(ContextT* ctx) {
    CharacterStringTypeContext *_localctx = _tracker.createInstance<CharacterStringTypeContext>(_ctx, getState());
    enterRule(_localctx, 682, GQLParser::RuleCharacterStringType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3196);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::STRING: {
          enterOuterAlt(_localctx, 1);
          setState(3161);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::STRING) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::STRING);
          setState(3171);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
          case 1: {
            setState(3162);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3166);
            _errHandler->sync(this);

            switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 308, _ctx)) {
            case 1: {
              setState(3163);
              {
                auto childCtxHolder = ctx->EnterMinLength();
                minLength(get_raw_pointer(childCtxHolder));
              }
              setState(3164);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::COMMA) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::COMMA);
              break;
            }

            default:
              break;
            }
            setState(3168);
            {
              auto childCtxHolder = ctx->EnterMaxLength();
              maxLength(get_raw_pointer(childCtxHolder));
            }
            setState(3169);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3174);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx)) {
          case 1: {
            setState(3173);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::CHAR: {
          enterOuterAlt(_localctx, 2);
          setState(3176);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::CHAR) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::CHAR);
          setState(3181);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 311, _ctx)) {
          case 1: {
            setState(3177);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3178);
            {
              auto childCtxHolder = ctx->EnterFixedLength();
              fixedLength(get_raw_pointer(childCtxHolder));
            }
            setState(3179);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3184);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 312, _ctx)) {
          case 1: {
            setState(3183);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::VARCHAR: {
          enterOuterAlt(_localctx, 3);
          setState(3186);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::VARCHAR) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::VARCHAR);
          setState(3191);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 313, _ctx)) {
          case 1: {
            setState(3187);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3188);
            {
              auto childCtxHolder = ctx->EnterMaxLength();
              maxLength(get_raw_pointer(childCtxHolder));
            }
            setState(3189);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3194);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 314, _ctx)) {
          case 1: {
            setState(3193);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ByteStringTypeContext : public antlr4::ParserRuleContext {
  public:
    ByteStringTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BYTES();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    MaxLengthContext *maxLength();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    NotNullContext *notNull();
    MinLengthContext *minLength();
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *BINARY();
    FixedLengthContext *fixedLength();
    antlr4::tree::TerminalNode *VARBINARY();

   
  };

  template<typename ContextT>
  ByteStringTypeContext* byteStringType(ContextT* ctx) {
    ByteStringTypeContext *_localctx = _tracker.createInstance<ByteStringTypeContext>(_ctx, getState());
    enterRule(_localctx, 684, GQLParser::RuleByteStringType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3233);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BYTES: {
          enterOuterAlt(_localctx, 1);
          setState(3198);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::BYTES) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::BYTES);
          setState(3208);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 317, _ctx)) {
          case 1: {
            setState(3199);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3203);
            _errHandler->sync(this);

            switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 316, _ctx)) {
            case 1: {
              setState(3200);
              {
                auto childCtxHolder = ctx->EnterMinLength();
                minLength(get_raw_pointer(childCtxHolder));
              }
              setState(3201);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::COMMA) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::COMMA);
              break;
            }

            default:
              break;
            }
            setState(3205);
            {
              auto childCtxHolder = ctx->EnterMaxLength();
              maxLength(get_raw_pointer(childCtxHolder));
            }
            setState(3206);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3211);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 318, _ctx)) {
          case 1: {
            setState(3210);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::BINARY: {
          enterOuterAlt(_localctx, 2);
          setState(3213);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::BINARY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::BINARY);
          setState(3218);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 319, _ctx)) {
          case 1: {
            setState(3214);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3215);
            {
              auto childCtxHolder = ctx->EnterFixedLength();
              fixedLength(get_raw_pointer(childCtxHolder));
            }
            setState(3216);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3221);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 320, _ctx)) {
          case 1: {
            setState(3220);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::VARBINARY: {
          enterOuterAlt(_localctx, 3);
          setState(3223);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::VARBINARY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::VARBINARY);
          setState(3228);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 321, _ctx)) {
          case 1: {
            setState(3224);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3225);
            {
              auto childCtxHolder = ctx->EnterMaxLength();
              maxLength(get_raw_pointer(childCtxHolder));
            }
            setState(3226);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3231);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx)) {
          case 1: {
            setState(3230);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  MinLengthContext : public antlr4::ParserRuleContext {
  public:
    MinLengthContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UnsignedIntegerContext *unsignedInteger();

   
  };

  template<typename ContextT>
  MinLengthContext* minLength(ContextT* ctx) {
    MinLengthContext *_localctx = _tracker.createInstance<MinLengthContext>(_ctx, getState());
    enterRule(_localctx, 686, GQLParser::RuleMinLength);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3235);
      {
        auto childCtxHolder = ctx->EnterUnsignedInteger();
        unsignedInteger(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  MaxLengthContext : public antlr4::ParserRuleContext {
  public:
    MaxLengthContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UnsignedIntegerContext *unsignedInteger();

   
  };

  template<typename ContextT>
  MaxLengthContext* maxLength(ContextT* ctx) {
    MaxLengthContext *_localctx = _tracker.createInstance<MaxLengthContext>(_ctx, getState());
    enterRule(_localctx, 688, GQLParser::RuleMaxLength);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3237);
      {
        auto childCtxHolder = ctx->EnterUnsignedInteger();
        unsignedInteger(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FixedLengthContext : public antlr4::ParserRuleContext {
  public:
    FixedLengthContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UnsignedIntegerContext *unsignedInteger();

   
  };

  template<typename ContextT>
  FixedLengthContext* fixedLength(ContextT* ctx) {
    FixedLengthContext *_localctx = _tracker.createInstance<FixedLengthContext>(_ctx, getState());
    enterRule(_localctx, 690, GQLParser::RuleFixedLength);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3239);
      {
        auto childCtxHolder = ctx->EnterUnsignedInteger();
        unsignedInteger(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NumericTypeContext : public antlr4::ParserRuleContext {
  public:
    NumericTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExactNumericTypeContext *exactNumericType();
    ApproximateNumericTypeContext *approximateNumericType();

   
  };

  template<typename ContextT>
  NumericTypeContext* numericType(ContextT* ctx) {
    NumericTypeContext *_localctx = _tracker.createInstance<NumericTypeContext>(_ctx, getState());
    enterRule(_localctx, 692, GQLParser::RuleNumericType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3243);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BIG:
        case GQLParser::BIGINT:
        case GQLParser::DEC:
        case GQLParser::DECIMAL:
        case GQLParser::INT:
        case GQLParser::INTEGER:
        case GQLParser::INT8:
        case GQLParser::INTEGER8:
        case GQLParser::INT16:
        case GQLParser::INTEGER16:
        case GQLParser::INT32:
        case GQLParser::INTEGER32:
        case GQLParser::INT64:
        case GQLParser::INTEGER64:
        case GQLParser::INT128:
        case GQLParser::INTEGER128:
        case GQLParser::INT256:
        case GQLParser::INTEGER256:
        case GQLParser::SIGNED:
        case GQLParser::SMALL:
        case GQLParser::SMALLINT:
        case GQLParser::UBIGINT:
        case GQLParser::UINT:
        case GQLParser::UINT8:
        case GQLParser::UINT16:
        case GQLParser::UINT32:
        case GQLParser::UINT64:
        case GQLParser::UINT128:
        case GQLParser::UINT256:
        case GQLParser::UNSIGNED:
        case GQLParser::USMALLINT: {
          enterOuterAlt(_localctx, 1);
          setState(3241);
          {
            auto childCtxHolder = ctx->EnterExactNumericType();
            exactNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DOUBLE:
        case GQLParser::FLOAT:
        case GQLParser::FLOAT16:
        case GQLParser::FLOAT32:
        case GQLParser::FLOAT64:
        case GQLParser::FLOAT128:
        case GQLParser::FLOAT256:
        case GQLParser::REAL: {
          enterOuterAlt(_localctx, 2);
          setState(3242);
          {
            auto childCtxHolder = ctx->EnterApproximateNumericType();
            approximateNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ExactNumericTypeContext : public antlr4::ParserRuleContext {
  public:
    ExactNumericTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BinaryExactNumericTypeContext *binaryExactNumericType();
    DecimalExactNumericTypeContext *decimalExactNumericType();

   
  };

  template<typename ContextT>
  ExactNumericTypeContext* exactNumericType(ContextT* ctx) {
    ExactNumericTypeContext *_localctx = _tracker.createInstance<ExactNumericTypeContext>(_ctx, getState());
    enterRule(_localctx, 694, GQLParser::RuleExactNumericType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3247);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BIG:
        case GQLParser::BIGINT:
        case GQLParser::INT:
        case GQLParser::INTEGER:
        case GQLParser::INT8:
        case GQLParser::INTEGER8:
        case GQLParser::INT16:
        case GQLParser::INTEGER16:
        case GQLParser::INT32:
        case GQLParser::INTEGER32:
        case GQLParser::INT64:
        case GQLParser::INTEGER64:
        case GQLParser::INT128:
        case GQLParser::INTEGER128:
        case GQLParser::INT256:
        case GQLParser::INTEGER256:
        case GQLParser::SIGNED:
        case GQLParser::SMALL:
        case GQLParser::SMALLINT:
        case GQLParser::UBIGINT:
        case GQLParser::UINT:
        case GQLParser::UINT8:
        case GQLParser::UINT16:
        case GQLParser::UINT32:
        case GQLParser::UINT64:
        case GQLParser::UINT128:
        case GQLParser::UINT256:
        case GQLParser::UNSIGNED:
        case GQLParser::USMALLINT: {
          enterOuterAlt(_localctx, 1);
          setState(3245);
          {
            auto childCtxHolder = ctx->EnterBinaryExactNumericType();
            binaryExactNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DEC:
        case GQLParser::DECIMAL: {
          enterOuterAlt(_localctx, 2);
          setState(3246);
          {
            auto childCtxHolder = ctx->EnterDecimalExactNumericType();
            decimalExactNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BinaryExactNumericTypeContext : public antlr4::ParserRuleContext {
  public:
    BinaryExactNumericTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SignedBinaryExactNumericTypeContext *signedBinaryExactNumericType();
    UnsignedBinaryExactNumericTypeContext *unsignedBinaryExactNumericType();

   
  };

  template<typename ContextT>
  BinaryExactNumericTypeContext* binaryExactNumericType(ContextT* ctx) {
    BinaryExactNumericTypeContext *_localctx = _tracker.createInstance<BinaryExactNumericTypeContext>(_ctx, getState());
    enterRule(_localctx, 696, GQLParser::RuleBinaryExactNumericType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3251);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BIG:
        case GQLParser::BIGINT:
        case GQLParser::INT:
        case GQLParser::INTEGER:
        case GQLParser::INT8:
        case GQLParser::INTEGER8:
        case GQLParser::INT16:
        case GQLParser::INTEGER16:
        case GQLParser::INT32:
        case GQLParser::INTEGER32:
        case GQLParser::INT64:
        case GQLParser::INTEGER64:
        case GQLParser::INT128:
        case GQLParser::INTEGER128:
        case GQLParser::INT256:
        case GQLParser::INTEGER256:
        case GQLParser::SIGNED:
        case GQLParser::SMALL:
        case GQLParser::SMALLINT: {
          enterOuterAlt(_localctx, 1);
          setState(3249);
          {
            auto childCtxHolder = ctx->EnterSignedBinaryExactNumericType();
            signedBinaryExactNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::UBIGINT:
        case GQLParser::UINT:
        case GQLParser::UINT8:
        case GQLParser::UINT16:
        case GQLParser::UINT32:
        case GQLParser::UINT64:
        case GQLParser::UINT128:
        case GQLParser::UINT256:
        case GQLParser::UNSIGNED:
        case GQLParser::USMALLINT: {
          enterOuterAlt(_localctx, 2);
          setState(3250);
          {
            auto childCtxHolder = ctx->EnterUnsignedBinaryExactNumericType();
            unsignedBinaryExactNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SignedBinaryExactNumericTypeContext : public antlr4::ParserRuleContext {
  public:
    SignedBinaryExactNumericTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INT8();
    NotNullContext *notNull();
    antlr4::tree::TerminalNode *INT16();
    antlr4::tree::TerminalNode *INT32();
    antlr4::tree::TerminalNode *INT64();
    antlr4::tree::TerminalNode *INT128();
    antlr4::tree::TerminalNode *INT256();
    antlr4::tree::TerminalNode *SMALLINT();
    antlr4::tree::TerminalNode *INT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    PrecisionContext *precision();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *BIGINT();
    VerboseBinaryExactNumericTypeContext *verboseBinaryExactNumericType();
    antlr4::tree::TerminalNode *SIGNED();

   
  };

  template<typename ContextT>
  SignedBinaryExactNumericTypeContext* signedBinaryExactNumericType(ContextT* ctx) {
    SignedBinaryExactNumericTypeContext *_localctx = _tracker.createInstance<SignedBinaryExactNumericTypeContext>(_ctx, getState());
    enterRule(_localctx, 698, GQLParser::RuleSignedBinaryExactNumericType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3299);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::INT8: {
          enterOuterAlt(_localctx, 1);
          setState(3253);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INT8) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INT8);
          setState(3255);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 327, _ctx)) {
          case 1: {
            setState(3254);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INT16: {
          enterOuterAlt(_localctx, 2);
          setState(3257);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INT16) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INT16);
          setState(3259);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 328, _ctx)) {
          case 1: {
            setState(3258);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INT32: {
          enterOuterAlt(_localctx, 3);
          setState(3261);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INT32) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INT32);
          setState(3263);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 329, _ctx)) {
          case 1: {
            setState(3262);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INT64: {
          enterOuterAlt(_localctx, 4);
          setState(3265);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INT64) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INT64);
          setState(3267);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 330, _ctx)) {
          case 1: {
            setState(3266);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INT128: {
          enterOuterAlt(_localctx, 5);
          setState(3269);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INT128) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INT128);
          setState(3271);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 331, _ctx)) {
          case 1: {
            setState(3270);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INT256: {
          enterOuterAlt(_localctx, 6);
          setState(3273);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INT256) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INT256);
          setState(3275);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 332, _ctx)) {
          case 1: {
            setState(3274);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::SMALLINT: {
          enterOuterAlt(_localctx, 7);
          setState(3277);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::SMALLINT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::SMALLINT);
          setState(3279);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 333, _ctx)) {
          case 1: {
            setState(3278);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INT: {
          enterOuterAlt(_localctx, 8);
          setState(3281);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INT);
          setState(3286);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 334, _ctx)) {
          case 1: {
            setState(3282);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3283);
            {
              auto childCtxHolder = ctx->EnterPrecision();
              precision(get_raw_pointer(childCtxHolder));
            }
            setState(3284);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3289);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 335, _ctx)) {
          case 1: {
            setState(3288);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::BIGINT: {
          enterOuterAlt(_localctx, 9);
          setState(3291);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::BIGINT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::BIGINT);
          setState(3293);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 336, _ctx)) {
          case 1: {
            setState(3292);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::BIG:
        case GQLParser::INTEGER:
        case GQLParser::INTEGER8:
        case GQLParser::INTEGER16:
        case GQLParser::INTEGER32:
        case GQLParser::INTEGER64:
        case GQLParser::INTEGER128:
        case GQLParser::INTEGER256:
        case GQLParser::SIGNED:
        case GQLParser::SMALL: {
          enterOuterAlt(_localctx, 10);
          setState(3296);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::SIGNED) {
            setState(3295);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::SIGNED) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::SIGNED);
          }
          setState(3298);
          {
            auto childCtxHolder = ctx->EnterVerboseBinaryExactNumericType();
            verboseBinaryExactNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  UnsignedBinaryExactNumericTypeContext : public antlr4::ParserRuleContext {
  public:
    UnsignedBinaryExactNumericTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UINT8();
    NotNullContext *notNull();
    antlr4::tree::TerminalNode *UINT16();
    antlr4::tree::TerminalNode *UINT32();
    antlr4::tree::TerminalNode *UINT64();
    antlr4::tree::TerminalNode *UINT128();
    antlr4::tree::TerminalNode *UINT256();
    antlr4::tree::TerminalNode *USMALLINT();
    antlr4::tree::TerminalNode *UINT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    PrecisionContext *precision();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *UBIGINT();
    antlr4::tree::TerminalNode *UNSIGNED();
    VerboseBinaryExactNumericTypeContext *verboseBinaryExactNumericType();

   
  };

  template<typename ContextT>
  UnsignedBinaryExactNumericTypeContext* unsignedBinaryExactNumericType(ContextT* ctx) {
    UnsignedBinaryExactNumericTypeContext *_localctx = _tracker.createInstance<UnsignedBinaryExactNumericTypeContext>(_ctx, getState());
    enterRule(_localctx, 700, GQLParser::RuleUnsignedBinaryExactNumericType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3345);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::UINT8: {
          enterOuterAlt(_localctx, 1);
          setState(3301);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UINT8) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UINT8);
          setState(3303);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx)) {
          case 1: {
            setState(3302);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UINT16: {
          enterOuterAlt(_localctx, 2);
          setState(3305);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UINT16) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UINT16);
          setState(3307);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx)) {
          case 1: {
            setState(3306);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UINT32: {
          enterOuterAlt(_localctx, 3);
          setState(3309);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UINT32) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UINT32);
          setState(3311);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx)) {
          case 1: {
            setState(3310);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UINT64: {
          enterOuterAlt(_localctx, 4);
          setState(3313);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UINT64) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UINT64);
          setState(3315);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 342, _ctx)) {
          case 1: {
            setState(3314);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UINT128: {
          enterOuterAlt(_localctx, 5);
          setState(3317);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UINT128) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UINT128);
          setState(3319);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx)) {
          case 1: {
            setState(3318);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UINT256: {
          enterOuterAlt(_localctx, 6);
          setState(3321);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UINT256) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UINT256);
          setState(3323);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx)) {
          case 1: {
            setState(3322);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::USMALLINT: {
          enterOuterAlt(_localctx, 7);
          setState(3325);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::USMALLINT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::USMALLINT);
          setState(3327);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 345, _ctx)) {
          case 1: {
            setState(3326);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UINT: {
          enterOuterAlt(_localctx, 8);
          setState(3329);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UINT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UINT);
          setState(3334);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 346, _ctx)) {
          case 1: {
            setState(3330);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3331);
            {
              auto childCtxHolder = ctx->EnterPrecision();
              precision(get_raw_pointer(childCtxHolder));
            }
            setState(3332);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3337);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 347, _ctx)) {
          case 1: {
            setState(3336);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UBIGINT: {
          enterOuterAlt(_localctx, 9);
          setState(3339);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UBIGINT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UBIGINT);
          setState(3341);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 348, _ctx)) {
          case 1: {
            setState(3340);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::UNSIGNED: {
          enterOuterAlt(_localctx, 10);
          setState(3343);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UNSIGNED) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UNSIGNED);
          setState(3344);
          {
            auto childCtxHolder = ctx->EnterVerboseBinaryExactNumericType();
            verboseBinaryExactNumericType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  VerboseBinaryExactNumericTypeContext : public antlr4::ParserRuleContext {
  public:
    VerboseBinaryExactNumericTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *INTEGER8();
    NotNullContext *notNull();
    antlr4::tree::TerminalNode *INTEGER16();
    antlr4::tree::TerminalNode *INTEGER32();
    antlr4::tree::TerminalNode *INTEGER64();
    antlr4::tree::TerminalNode *INTEGER128();
    antlr4::tree::TerminalNode *INTEGER256();
    antlr4::tree::TerminalNode *SMALL();
    antlr4::tree::TerminalNode *INTEGER();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    PrecisionContext *precision();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *BIG();

   
  };

  template<typename ContextT>
  VerboseBinaryExactNumericTypeContext* verboseBinaryExactNumericType(ContextT* ctx) {
    VerboseBinaryExactNumericTypeContext *_localctx = _tracker.createInstance<VerboseBinaryExactNumericTypeContext>(_ctx, getState());
    enterRule(_localctx, 702, GQLParser::RuleVerboseBinaryExactNumericType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3391);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::INTEGER8: {
          enterOuterAlt(_localctx, 1);
          setState(3347);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER8) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER8);
          setState(3349);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 350, _ctx)) {
          case 1: {
            setState(3348);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INTEGER16: {
          enterOuterAlt(_localctx, 2);
          setState(3351);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER16) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER16);
          setState(3353);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 351, _ctx)) {
          case 1: {
            setState(3352);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INTEGER32: {
          enterOuterAlt(_localctx, 3);
          setState(3355);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER32) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER32);
          setState(3357);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 352, _ctx)) {
          case 1: {
            setState(3356);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INTEGER64: {
          enterOuterAlt(_localctx, 4);
          setState(3359);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER64) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER64);
          setState(3361);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 353, _ctx)) {
          case 1: {
            setState(3360);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INTEGER128: {
          enterOuterAlt(_localctx, 5);
          setState(3363);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER128) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER128);
          setState(3365);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 354, _ctx)) {
          case 1: {
            setState(3364);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INTEGER256: {
          enterOuterAlt(_localctx, 6);
          setState(3367);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER256) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER256);
          setState(3369);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 355, _ctx)) {
          case 1: {
            setState(3368);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::SMALL: {
          enterOuterAlt(_localctx, 7);
          setState(3371);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::SMALL) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::SMALL);
          setState(3372);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER);
          setState(3374);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 356, _ctx)) {
          case 1: {
            setState(3373);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::INTEGER: {
          enterOuterAlt(_localctx, 8);
          setState(3376);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER);
          setState(3381);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 357, _ctx)) {
          case 1: {
            setState(3377);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3378);
            {
              auto childCtxHolder = ctx->EnterPrecision();
              precision(get_raw_pointer(childCtxHolder));
            }
            setState(3379);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3384);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 358, _ctx)) {
          case 1: {
            setState(3383);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::BIG: {
          enterOuterAlt(_localctx, 9);
          setState(3386);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::BIG) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::BIG);
          setState(3387);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::INTEGER) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::INTEGER);
          setState(3389);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 359, _ctx)) {
          case 1: {
            setState(3388);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DecimalExactNumericTypeContext : public antlr4::ParserRuleContext {
  public:
    DecimalExactNumericTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DECIMAL();
    antlr4::tree::TerminalNode *DEC();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    PrecisionContext *precision();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *COMMA();
    ScaleContext *scale();
    NotNullContext *notNull();

   
  };

  template<typename ContextT>
  DecimalExactNumericTypeContext* decimalExactNumericType(ContextT* ctx) {
    DecimalExactNumericTypeContext *_localctx = _tracker.createInstance<DecimalExactNumericTypeContext>(_ctx, getState());
    enterRule(_localctx, 704, GQLParser::RuleDecimalExactNumericType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3393);
      _la = _input->LA(1);
      if (!(_la == GQLParser::DEC

      || _la == GQLParser::DECIMAL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(3404);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 363, _ctx)) {
      case 1: {
        setState(3394);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(3395);
        {
          auto childCtxHolder = ctx->EnterPrecision();
          precision(get_raw_pointer(childCtxHolder));
        }
        setState(3398);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::COMMA) {
          setState(3396);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COMMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COMMA);
          setState(3397);
          {
            auto childCtxHolder = ctx->EnterScale();
            scale(get_raw_pointer(childCtxHolder));
          }
        }
        setState(3400);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        setState(3402);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 362, _ctx)) {
        case 1: {
          setState(3401);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PrecisionContext : public antlr4::ParserRuleContext {
  public:
    PrecisionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UnsignedDecimalIntegerContext *unsignedDecimalInteger();

   
  };

  template<typename ContextT>
  PrecisionContext* precision(ContextT* ctx) {
    PrecisionContext *_localctx = _tracker.createInstance<PrecisionContext>(_ctx, getState());
    enterRule(_localctx, 706, GQLParser::RulePrecision);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3406);
      {
        auto childCtxHolder = ctx->EnterUnsignedDecimalInteger();
        unsignedDecimalInteger(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ScaleContext : public antlr4::ParserRuleContext {
  public:
    ScaleContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UnsignedDecimalIntegerContext *unsignedDecimalInteger();

   
  };

  template<typename ContextT>
  ScaleContext* scale(ContextT* ctx) {
    ScaleContext *_localctx = _tracker.createInstance<ScaleContext>(_ctx, getState());
    enterRule(_localctx, 708, GQLParser::RuleScale);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3408);
      {
        auto childCtxHolder = ctx->EnterUnsignedDecimalInteger();
        unsignedDecimalInteger(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ApproximateNumericTypeContext : public antlr4::ParserRuleContext {
  public:
    ApproximateNumericTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FLOAT16();
    NotNullContext *notNull();
    antlr4::tree::TerminalNode *FLOAT32();
    antlr4::tree::TerminalNode *FLOAT64();
    antlr4::tree::TerminalNode *FLOAT128();
    antlr4::tree::TerminalNode *FLOAT256();
    antlr4::tree::TerminalNode *FLOAT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    PrecisionContext *precision();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *COMMA();
    ScaleContext *scale();
    antlr4::tree::TerminalNode *REAL();
    antlr4::tree::TerminalNode *DOUBLE();
    antlr4::tree::TerminalNode *PRECISION();

   
  };

  template<typename ContextT>
  ApproximateNumericTypeContext* approximateNumericType(ContextT* ctx) {
    ApproximateNumericTypeContext *_localctx = _tracker.createInstance<ApproximateNumericTypeContext>(_ctx, getState());
    enterRule(_localctx, 710, GQLParser::RuleApproximateNumericType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3455);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::FLOAT16: {
          enterOuterAlt(_localctx, 1);
          setState(3410);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::FLOAT16) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::FLOAT16);
          setState(3412);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 364, _ctx)) {
          case 1: {
            setState(3411);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::FLOAT32: {
          enterOuterAlt(_localctx, 2);
          setState(3414);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::FLOAT32) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::FLOAT32);
          setState(3416);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 365, _ctx)) {
          case 1: {
            setState(3415);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::FLOAT64: {
          enterOuterAlt(_localctx, 3);
          setState(3418);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::FLOAT64) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::FLOAT64);
          setState(3420);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 366, _ctx)) {
          case 1: {
            setState(3419);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::FLOAT128: {
          enterOuterAlt(_localctx, 4);
          setState(3422);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::FLOAT128) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::FLOAT128);
          setState(3424);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 367, _ctx)) {
          case 1: {
            setState(3423);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::FLOAT256: {
          enterOuterAlt(_localctx, 5);
          setState(3426);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::FLOAT256) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::FLOAT256);
          setState(3428);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 368, _ctx)) {
          case 1: {
            setState(3427);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::FLOAT: {
          enterOuterAlt(_localctx, 6);
          setState(3430);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::FLOAT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::FLOAT);
          setState(3439);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 370, _ctx)) {
          case 1: {
            setState(3431);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::LEFT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::LEFT_PAREN);
            setState(3432);
            {
              auto childCtxHolder = ctx->EnterPrecision();
              precision(get_raw_pointer(childCtxHolder));
            }
            setState(3435);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == GQLParser::COMMA) {
              setState(3433);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::COMMA) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::COMMA);
              setState(3434);
              {
                auto childCtxHolder = ctx->EnterScale();
                scale(get_raw_pointer(childCtxHolder));
              }
            }
            setState(3437);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::RIGHT_PAREN);
            break;
          }

          default:
            break;
          }
          setState(3442);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 371, _ctx)) {
          case 1: {
            setState(3441);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::REAL: {
          enterOuterAlt(_localctx, 7);
          setState(3444);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::REAL) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::REAL);
          setState(3446);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 372, _ctx)) {
          case 1: {
            setState(3445);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::DOUBLE: {
          enterOuterAlt(_localctx, 8);
          setState(3448);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::DOUBLE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::DOUBLE);
          setState(3450);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 373, _ctx)) {
          case 1: {
            setState(3449);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::PRECISION) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::PRECISION);
            break;
          }

          default:
            break;
          }
          setState(3453);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 374, _ctx)) {
          case 1: {
            setState(3452);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TemporalTypeContext : public antlr4::ParserRuleContext {
  public:
    TemporalTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    TemporalInstantTypeContext *temporalInstantType();
    TemporalDurationTypeContext *temporalDurationType();

   
  };

  template<typename ContextT>
  TemporalTypeContext* temporalType(ContextT* ctx) {
    TemporalTypeContext *_localctx = _tracker.createInstance<TemporalTypeContext>(_ctx, getState());
    enterRule(_localctx, 712, GQLParser::RuleTemporalType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3459);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::DATE:
        case GQLParser::LOCAL:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::ZONED: {
          enterOuterAlt(_localctx, 1);
          setState(3457);
          {
            auto childCtxHolder = ctx->EnterTemporalInstantType();
            temporalInstantType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DURATION: {
          enterOuterAlt(_localctx, 2);
          setState(3458);
          {
            auto childCtxHolder = ctx->EnterTemporalDurationType();
            temporalDurationType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TemporalInstantTypeContext : public antlr4::ParserRuleContext {
  public:
    TemporalInstantTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DatetimeTypeContext *datetimeType();
    LocaldatetimeTypeContext *localdatetimeType();
    DateTypeContext *dateType();
    TimeTypeContext *timeType();
    LocaltimeTypeContext *localtimeType();

   
  };

  template<typename ContextT>
  TemporalInstantTypeContext* temporalInstantType(ContextT* ctx) {
    TemporalInstantTypeContext *_localctx = _tracker.createInstance<TemporalInstantTypeContext>(_ctx, getState());
    enterRule(_localctx, 714, GQLParser::RuleTemporalInstantType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3466);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 377, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3461);
        {
          auto childCtxHolder = ctx->EnterDatetimeType();
          datetimeType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3462);
        {
          auto childCtxHolder = ctx->EnterLocaldatetimeType();
          localdatetimeType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3463);
        {
          auto childCtxHolder = ctx->EnterDateType();
          dateType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(3464);
        {
          auto childCtxHolder = ctx->EnterTimeType();
          timeType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(3465);
        {
          auto childCtxHolder = ctx->EnterLocaltimeType();
          localtimeType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DatetimeTypeContext : public antlr4::ParserRuleContext {
  public:
    DatetimeTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ZONED();
    antlr4::tree::TerminalNode *DATETIME();
    NotNullContext *notNull();
    antlr4::tree::TerminalNode *TIMESTAMP();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *ZONE();

   
  };

  template<typename ContextT>
  DatetimeTypeContext* datetimeType(ContextT* ctx) {
    DatetimeTypeContext *_localctx = _tracker.createInstance<DatetimeTypeContext>(_ctx, getState());
    enterRule(_localctx, 716, GQLParser::RuleDatetimeType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3480);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ZONED: {
          enterOuterAlt(_localctx, 1);
          setState(3468);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONED) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONED);
          setState(3469);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::DATETIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::DATETIME);
          setState(3471);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 378, _ctx)) {
          case 1: {
            setState(3470);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::TIMESTAMP: {
          enterOuterAlt(_localctx, 2);
          setState(3473);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIMESTAMP) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIMESTAMP);
          setState(3474);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::WITH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::WITH);
          setState(3475);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(3476);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONE);
          setState(3478);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 379, _ctx)) {
          case 1: {
            setState(3477);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LocaldatetimeTypeContext : public antlr4::ParserRuleContext {
  public:
    LocaldatetimeTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOCAL();
    antlr4::tree::TerminalNode *DATETIME();
    NotNullContext *notNull();
    antlr4::tree::TerminalNode *TIMESTAMP();
    antlr4::tree::TerminalNode *WITHOUT();
    antlr4::tree::TerminalNode *TIME();
    antlr4::tree::TerminalNode *ZONE();

   
  };

  template<typename ContextT>
  LocaldatetimeTypeContext* localdatetimeType(ContextT* ctx) {
    LocaldatetimeTypeContext *_localctx = _tracker.createInstance<LocaldatetimeTypeContext>(_ctx, getState());
    enterRule(_localctx, 718, GQLParser::RuleLocaldatetimeType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3496);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LOCAL: {
          enterOuterAlt(_localctx, 1);
          setState(3482);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LOCAL) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LOCAL);
          setState(3483);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::DATETIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::DATETIME);
          setState(3485);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 381, _ctx)) {
          case 1: {
            setState(3484);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::TIMESTAMP: {
          enterOuterAlt(_localctx, 2);
          setState(3487);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIMESTAMP) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIMESTAMP);
          setState(3491);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 382, _ctx)) {
          case 1: {
            setState(3488);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::WITHOUT) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::WITHOUT);
            setState(3489);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::TIME) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::TIME);
            setState(3490);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::ZONE) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::ZONE);
            break;
          }

          default:
            break;
          }
          setState(3494);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 383, _ctx)) {
          case 1: {
            setState(3493);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DateTypeContext : public antlr4::ParserRuleContext {
  public:
    DateTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATE();
    NotNullContext *notNull();

   
  };

  template<typename ContextT>
  DateTypeContext* dateType(ContextT* ctx) {
    DateTypeContext *_localctx = _tracker.createInstance<DateTypeContext>(_ctx, getState());
    enterRule(_localctx, 720, GQLParser::RuleDateType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3498);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DATE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DATE);
      setState(3500);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 385, _ctx)) {
      case 1: {
        setState(3499);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TimeTypeContext : public antlr4::ParserRuleContext {
  public:
    TimeTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ZONED();
    std::vector<antlr4::tree::TerminalNode *> TIME();
    antlr4::tree::TerminalNode* TIME(size_t i);
    NotNullContext *notNull();
    antlr4::tree::TerminalNode *WITH();
    antlr4::tree::TerminalNode *ZONE();

   
  };

  template<typename ContextT>
  TimeTypeContext* timeType(ContextT* ctx) {
    TimeTypeContext *_localctx = _tracker.createInstance<TimeTypeContext>(_ctx, getState());
    enterRule(_localctx, 722, GQLParser::RuleTimeType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3514);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ZONED: {
          enterOuterAlt(_localctx, 1);
          setState(3502);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONED) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONED);
          setState(3503);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(3505);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 386, _ctx)) {
          case 1: {
            setState(3504);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::TIME: {
          enterOuterAlt(_localctx, 2);
          setState(3507);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(3508);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::WITH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::WITH);
          setState(3509);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(3510);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONE);
          setState(3512);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 387, _ctx)) {
          case 1: {
            setState(3511);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LocaltimeTypeContext : public antlr4::ParserRuleContext {
  public:
    LocaltimeTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOCAL();
    std::vector<antlr4::tree::TerminalNode *> TIME();
    antlr4::tree::TerminalNode* TIME(size_t i);
    NotNullContext *notNull();
    antlr4::tree::TerminalNode *WITHOUT();
    antlr4::tree::TerminalNode *ZONE();

   
  };

  template<typename ContextT>
  LocaltimeTypeContext* localtimeType(ContextT* ctx) {
    LocaltimeTypeContext *_localctx = _tracker.createInstance<LocaltimeTypeContext>(_ctx, getState());
    enterRule(_localctx, 724, GQLParser::RuleLocaltimeType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3528);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LOCAL: {
          enterOuterAlt(_localctx, 1);
          setState(3516);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LOCAL) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LOCAL);
          setState(3517);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(3519);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 389, _ctx)) {
          case 1: {
            setState(3518);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

        case GQLParser::TIME: {
          enterOuterAlt(_localctx, 2);
          setState(3521);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(3522);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::WITHOUT) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::WITHOUT);
          setState(3523);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TIME);
          setState(3524);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONE);
          setState(3526);
          _errHandler->sync(this);

          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 390, _ctx)) {
          case 1: {
            setState(3525);
            {
              auto childCtxHolder = ctx->EnterNotNull();
              notNull(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TemporalDurationTypeContext : public antlr4::ParserRuleContext {
  public:
    TemporalDurationTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DURATION();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    TemporalDurationQualifierContext *temporalDurationQualifier();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    NotNullContext *notNull();

   
  };

  template<typename ContextT>
  TemporalDurationTypeContext* temporalDurationType(ContextT* ctx) {
    TemporalDurationTypeContext *_localctx = _tracker.createInstance<TemporalDurationTypeContext>(_ctx, getState());
    enterRule(_localctx, 726, GQLParser::RuleTemporalDurationType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3530);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DURATION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DURATION);
      setState(3531);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3532);
      {
        auto childCtxHolder = ctx->EnterTemporalDurationQualifier();
        temporalDurationQualifier(get_raw_pointer(childCtxHolder));
      }
      setState(3533);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
      setState(3535);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 392, _ctx)) {
      case 1: {
        setState(3534);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TemporalDurationQualifierContext : public antlr4::ParserRuleContext {
  public:
    TemporalDurationQualifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *YEAR();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *MONTH();
    antlr4::tree::TerminalNode *DAY();
    antlr4::tree::TerminalNode *SECOND();

   
  };

  template<typename ContextT>
  TemporalDurationQualifierContext* temporalDurationQualifier(ContextT* ctx) {
    TemporalDurationQualifierContext *_localctx = _tracker.createInstance<TemporalDurationQualifierContext>(_ctx, getState());
    enterRule(_localctx, 728, GQLParser::RuleTemporalDurationQualifier);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3543);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::YEAR: {
          enterOuterAlt(_localctx, 1);
          setState(3537);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::YEAR) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::YEAR);
          setState(3538);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TO) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TO);
          setState(3539);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::MONTH) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::MONTH);
          break;
        }

        case GQLParser::DAY: {
          enterOuterAlt(_localctx, 2);
          setState(3540);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::DAY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::DAY);
          setState(3541);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::TO) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::TO);
          setState(3542);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::SECOND) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::SECOND);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ReferenceValueTypeContext : public antlr4::ParserRuleContext {
  public:
    ReferenceValueTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    GraphReferenceValueTypeContext *graphReferenceValueType();
    BindingTableReferenceValueTypeContext *bindingTableReferenceValueType();
    NodeReferenceValueTypeContext *nodeReferenceValueType();
    EdgeReferenceValueTypeContext *edgeReferenceValueType();

   
  };

  template<typename ContextT>
  ReferenceValueTypeContext* referenceValueType(ContextT* ctx) {
    ReferenceValueTypeContext *_localctx = _tracker.createInstance<ReferenceValueTypeContext>(_ctx, getState());
    enterRule(_localctx, 730, GQLParser::RuleReferenceValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3549);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 394, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3545);
        {
          auto childCtxHolder = ctx->EnterGraphReferenceValueType();
          graphReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3546);
        {
          auto childCtxHolder = ctx->EnterBindingTableReferenceValueType();
          bindingTableReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3547);
        {
          auto childCtxHolder = ctx->EnterNodeReferenceValueType();
          nodeReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(3548);
        {
          auto childCtxHolder = ctx->EnterEdgeReferenceValueType();
          edgeReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ImmaterialValueTypeContext : public antlr4::ParserRuleContext {
  public:
    ImmaterialValueTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NullTypeContext *nullType();
    EmptyTypeContext *emptyType();

   
  };

  template<typename ContextT>
  ImmaterialValueTypeContext* immaterialValueType(ContextT* ctx) {
    ImmaterialValueTypeContext *_localctx = _tracker.createInstance<ImmaterialValueTypeContext>(_ctx, getState());
    enterRule(_localctx, 732, GQLParser::RuleImmaterialValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3553);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 395, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3551);
        {
          auto childCtxHolder = ctx->EnterNullType();
          nullType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3552);
        {
          auto childCtxHolder = ctx->EnterEmptyType();
          emptyType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NullTypeContext : public antlr4::ParserRuleContext {
  public:
    NullTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NULL_KW();

   
  };

  template<typename ContextT>
  NullTypeContext* nullType(ContextT* ctx) {
    NullTypeContext *_localctx = _tracker.createInstance<NullTypeContext>(_ctx, getState());
    enterRule(_localctx, 734, GQLParser::RuleNullType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3555);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NULL_KW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NULL_KW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EmptyTypeContext : public antlr4::ParserRuleContext {
  public:
    EmptyTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NULL_KW();
    NotNullContext *notNull();
    antlr4::tree::TerminalNode *NOTHING();

   
  };

  template<typename ContextT>
  EmptyTypeContext* emptyType(ContextT* ctx) {
    EmptyTypeContext *_localctx = _tracker.createInstance<EmptyTypeContext>(_ctx, getState());
    enterRule(_localctx, 736, GQLParser::RuleEmptyType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3560);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::NULL_KW: {
          enterOuterAlt(_localctx, 1);
          setState(3557);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::NULL_KW) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::NULL_KW);
          setState(3558);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::NOTHING: {
          enterOuterAlt(_localctx, 2);
          setState(3559);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::NOTHING) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::NOTHING);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphReferenceValueTypeContext : public antlr4::ParserRuleContext {
  public:
    GraphReferenceValueTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    OpenGraphReferenceValueTypeContext *openGraphReferenceValueType();
    ClosedGraphReferenceValueTypeContext *closedGraphReferenceValueType();

   
  };

  template<typename ContextT>
  GraphReferenceValueTypeContext* graphReferenceValueType(ContextT* ctx) {
    GraphReferenceValueTypeContext *_localctx = _tracker.createInstance<GraphReferenceValueTypeContext>(_ctx, getState());
    enterRule(_localctx, 738, GQLParser::RuleGraphReferenceValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3564);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ANY: {
          enterOuterAlt(_localctx, 1);
          setState(3562);
          {
            auto childCtxHolder = ctx->EnterOpenGraphReferenceValueType();
            openGraphReferenceValueType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::GRAPH:
        case GQLParser::PROPERTY: {
          enterOuterAlt(_localctx, 2);
          setState(3563);
          {
            auto childCtxHolder = ctx->EnterClosedGraphReferenceValueType();
            closedGraphReferenceValueType(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ClosedGraphReferenceValueTypeContext : public antlr4::ParserRuleContext {
  public:
    ClosedGraphReferenceValueTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GRAPH();
    NestedGraphTypeSpecificationContext *nestedGraphTypeSpecification();
    antlr4::tree::TerminalNode *PROPERTY();
    NotNullContext *notNull();

   
  };

  template<typename ContextT>
  ClosedGraphReferenceValueTypeContext* closedGraphReferenceValueType(ContextT* ctx) {
    ClosedGraphReferenceValueTypeContext *_localctx = _tracker.createInstance<ClosedGraphReferenceValueTypeContext>(_ctx, getState());
    enterRule(_localctx, 740, GQLParser::RuleClosedGraphReferenceValueType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3567);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PROPERTY) {
        setState(3566);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
      }
      setState(3569);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GRAPH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GRAPH);
      setState(3570);
      {
        auto childCtxHolder = ctx->EnterNestedGraphTypeSpecification();
        nestedGraphTypeSpecification(get_raw_pointer(childCtxHolder));
      }
      setState(3572);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 399, _ctx)) {
      case 1: {
        setState(3571);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  OpenGraphReferenceValueTypeContext : public antlr4::ParserRuleContext {
  public:
    OpenGraphReferenceValueTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ANY();
    antlr4::tree::TerminalNode *GRAPH();
    antlr4::tree::TerminalNode *PROPERTY();
    NotNullContext *notNull();

   
  };

  template<typename ContextT>
  OpenGraphReferenceValueTypeContext* openGraphReferenceValueType(ContextT* ctx) {
    OpenGraphReferenceValueTypeContext *_localctx = _tracker.createInstance<OpenGraphReferenceValueTypeContext>(_ctx, getState());
    enterRule(_localctx, 742, GQLParser::RuleOpenGraphReferenceValueType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3574);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ANY) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ANY);
      setState(3576);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::PROPERTY) {
        setState(3575);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PROPERTY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PROPERTY);
      }
      setState(3578);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GRAPH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GRAPH);
      setState(3580);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 401, _ctx)) {
      case 1: {
        setState(3579);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BindingTableReferenceValueTypeContext : public antlr4::ParserRuleContext {
  public:
    BindingTableReferenceValueTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BindingTableTypeContext *bindingTableType();
    NotNullContext *notNull();

   
  };

  template<typename ContextT>
  BindingTableReferenceValueTypeContext* bindingTableReferenceValueType(ContextT* ctx) {
    BindingTableReferenceValueTypeContext *_localctx = _tracker.createInstance<BindingTableReferenceValueTypeContext>(_ctx, getState());
    enterRule(_localctx, 744, GQLParser::RuleBindingTableReferenceValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3582);
      {
        auto childCtxHolder = ctx->EnterBindingTableType();
        bindingTableType(get_raw_pointer(childCtxHolder));
      }
      setState(3584);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 402, _ctx)) {
      case 1: {
        setState(3583);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NodeReferenceValueTypeContext : public antlr4::ParserRuleContext {
  public:
    NodeReferenceValueTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    OpenNodeReferenceValueTypeContext *openNodeReferenceValueType();
    ClosedNodeReferenceValueTypeContext *closedNodeReferenceValueType();

   
  };

  template<typename ContextT>
  NodeReferenceValueTypeContext* nodeReferenceValueType(ContextT* ctx) {
    NodeReferenceValueTypeContext *_localctx = _tracker.createInstance<NodeReferenceValueTypeContext>(_ctx, getState());
    enterRule(_localctx, 746, GQLParser::RuleNodeReferenceValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3588);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 403, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3586);
        {
          auto childCtxHolder = ctx->EnterOpenNodeReferenceValueType();
          openNodeReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3587);
        {
          auto childCtxHolder = ctx->EnterClosedNodeReferenceValueType();
          closedNodeReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ClosedNodeReferenceValueTypeContext : public antlr4::ParserRuleContext {
  public:
    ClosedNodeReferenceValueTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NodeTypeSpecificationContext *nodeTypeSpecification();
    NotNullContext *notNull();

   
  };

  template<typename ContextT>
  ClosedNodeReferenceValueTypeContext* closedNodeReferenceValueType(ContextT* ctx) {
    ClosedNodeReferenceValueTypeContext *_localctx = _tracker.createInstance<ClosedNodeReferenceValueTypeContext>(_ctx, getState());
    enterRule(_localctx, 748, GQLParser::RuleClosedNodeReferenceValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3590);
      {
        auto childCtxHolder = ctx->EnterNodeTypeSpecification();
        nodeTypeSpecification(get_raw_pointer(childCtxHolder));
      }
      setState(3592);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 404, _ctx)) {
      case 1: {
        setState(3591);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  OpenNodeReferenceValueTypeContext : public antlr4::ParserRuleContext {
  public:
    OpenNodeReferenceValueTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NodeSynonymContext *nodeSynonym();
    antlr4::tree::TerminalNode *ANY();
    NotNullContext *notNull();

   
  };

  template<typename ContextT>
  OpenNodeReferenceValueTypeContext* openNodeReferenceValueType(ContextT* ctx) {
    OpenNodeReferenceValueTypeContext *_localctx = _tracker.createInstance<OpenNodeReferenceValueTypeContext>(_ctx, getState());
    enterRule(_localctx, 750, GQLParser::RuleOpenNodeReferenceValueType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3595);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ANY) {
        setState(3594);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::ANY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::ANY);
      }
      setState(3597);
      {
        auto childCtxHolder = ctx->EnterNodeSynonym();
        nodeSynonym(get_raw_pointer(childCtxHolder));
      }
      setState(3599);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx)) {
      case 1: {
        setState(3598);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeReferenceValueTypeContext : public antlr4::ParserRuleContext {
  public:
    EdgeReferenceValueTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    OpenEdgeReferenceValueTypeContext *openEdgeReferenceValueType();
    ClosedEdgeReferenceValueTypeContext *closedEdgeReferenceValueType();

   
  };

  template<typename ContextT>
  EdgeReferenceValueTypeContext* edgeReferenceValueType(ContextT* ctx) {
    EdgeReferenceValueTypeContext *_localctx = _tracker.createInstance<EdgeReferenceValueTypeContext>(_ctx, getState());
    enterRule(_localctx, 752, GQLParser::RuleEdgeReferenceValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3603);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 407, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3601);
        {
          auto childCtxHolder = ctx->EnterOpenEdgeReferenceValueType();
          openEdgeReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3602);
        {
          auto childCtxHolder = ctx->EnterClosedEdgeReferenceValueType();
          closedEdgeReferenceValueType(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ClosedEdgeReferenceValueTypeContext : public antlr4::ParserRuleContext {
  public:
    ClosedEdgeReferenceValueTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    EdgeTypeSpecificationContext *edgeTypeSpecification();
    NotNullContext *notNull();

   
  };

  template<typename ContextT>
  ClosedEdgeReferenceValueTypeContext* closedEdgeReferenceValueType(ContextT* ctx) {
    ClosedEdgeReferenceValueTypeContext *_localctx = _tracker.createInstance<ClosedEdgeReferenceValueTypeContext>(_ctx, getState());
    enterRule(_localctx, 754, GQLParser::RuleClosedEdgeReferenceValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3605);
      {
        auto childCtxHolder = ctx->EnterEdgeTypeSpecification();
        edgeTypeSpecification(get_raw_pointer(childCtxHolder));
      }
      setState(3607);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 408, _ctx)) {
      case 1: {
        setState(3606);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  OpenEdgeReferenceValueTypeContext : public antlr4::ParserRuleContext {
  public:
    OpenEdgeReferenceValueTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    EdgeSynonymContext *edgeSynonym();
    antlr4::tree::TerminalNode *ANY();
    NotNullContext *notNull();

   
  };

  template<typename ContextT>
  OpenEdgeReferenceValueTypeContext* openEdgeReferenceValueType(ContextT* ctx) {
    OpenEdgeReferenceValueTypeContext *_localctx = _tracker.createInstance<OpenEdgeReferenceValueTypeContext>(_ctx, getState());
    enterRule(_localctx, 756, GQLParser::RuleOpenEdgeReferenceValueType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3610);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ANY) {
        setState(3609);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::ANY) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::ANY);
      }
      setState(3612);
      {
        auto childCtxHolder = ctx->EnterEdgeSynonym();
        edgeSynonym(get_raw_pointer(childCtxHolder));
      }
      setState(3614);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 410, _ctx)) {
      case 1: {
        setState(3613);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathValueTypeContext : public antlr4::ParserRuleContext {
  public:
    PathValueTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PATH();
    NotNullContext *notNull();

   
  };

  template<typename ContextT>
  PathValueTypeContext* pathValueType(ContextT* ctx) {
    PathValueTypeContext *_localctx = _tracker.createInstance<PathValueTypeContext>(_ctx, getState());
    enterRule(_localctx, 758, GQLParser::RulePathValueType);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3616);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::PATH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::PATH);
      setState(3618);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 411, _ctx)) {
      case 1: {
        setState(3617);
        {
          auto childCtxHolder = ctx->EnterNotNull();
          notNull(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ListValueTypeNameContext : public antlr4::ParserRuleContext {
  public:
    ListValueTypeNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ListValueTypeNameSynonymContext *listValueTypeNameSynonym();
    antlr4::tree::TerminalNode *GROUP();

   
  };

  template<typename ContextT>
  ListValueTypeNameContext* listValueTypeName(ContextT* ctx) {
    ListValueTypeNameContext *_localctx = _tracker.createInstance<ListValueTypeNameContext>(_ctx, getState());
    enterRule(_localctx, 760, GQLParser::RuleListValueTypeName);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3621);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::GROUP) {
        setState(3620);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::GROUP) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::GROUP);
      }
      setState(3623);
      {
        auto childCtxHolder = ctx->EnterListValueTypeNameSynonym();
        listValueTypeNameSynonym(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ListValueTypeNameSynonymContext : public antlr4::ParserRuleContext {
  public:
    ListValueTypeNameSynonymContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LIST();
    antlr4::tree::TerminalNode *ARRAY();

   
  };

  template<typename ContextT>
  ListValueTypeNameSynonymContext* listValueTypeNameSynonym(ContextT* ctx) {
    ListValueTypeNameSynonymContext *_localctx = _tracker.createInstance<ListValueTypeNameSynonymContext>(_ctx, getState());
    enterRule(_localctx, 762, GQLParser::RuleListValueTypeNameSynonym);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3625);
      _la = _input->LA(1);
      if (!(_la == GQLParser::ARRAY || _la == GQLParser::LIST)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  RecordTypeContext : public antlr4::ParserRuleContext {
  public:
    RecordTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *RECORD();
    antlr4::tree::TerminalNode *ANY();
    NotNullContext *notNull();
    FieldTypesSpecificationContext *fieldTypesSpecification();

   
  };

  template<typename ContextT>
  RecordTypeContext* recordType(ContextT* ctx) {
    RecordTypeContext *_localctx = _tracker.createInstance<RecordTypeContext>(_ctx, getState());
    enterRule(_localctx, 764, GQLParser::RuleRecordType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3641);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 417, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3628);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::ANY) {
          setState(3627);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ANY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ANY);
        }
        setState(3630);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RECORD) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RECORD);
        setState(3632);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 414, _ctx)) {
        case 1: {
          setState(3631);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3635);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::RECORD) {
          setState(3634);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RECORD) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RECORD);
        }
        setState(3637);
        {
          auto childCtxHolder = ctx->EnterFieldTypesSpecification();
          fieldTypesSpecification(get_raw_pointer(childCtxHolder));
        }
        setState(3639);
        _errHandler->sync(this);

        switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 416, _ctx)) {
        case 1: {
          setState(3638);
          {
            auto childCtxHolder = ctx->EnterNotNull();
            notNull(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        default:
          break;
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FieldTypesSpecificationContext : public antlr4::ParserRuleContext {
  public:
    FieldTypesSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_BRACE();
    antlr4::tree::TerminalNode *RIGHT_BRACE();
    FieldTypeListContext *fieldTypeList();

   
  };

  template<typename ContextT>
  FieldTypesSpecificationContext* fieldTypesSpecification(ContextT* ctx) {
    FieldTypesSpecificationContext *_localctx = _tracker.createInstance<FieldTypesSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 766, GQLParser::RuleFieldTypesSpecification);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3643);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(3645);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE

      || _la == GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0)) {
        setState(3644);
        {
          auto childCtxHolder = ctx->EnterFieldTypeList();
          fieldTypeList(get_raw_pointer(childCtxHolder));
        }
      }
      setState(3647);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FieldTypeListContext : public antlr4::ParserRuleContext {
  public:
    FieldTypeListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<FieldTypeContext *> fieldType();
    FieldTypeContext* fieldType(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  FieldTypeListContext* fieldTypeList(ContextT* ctx) {
    FieldTypeListContext *_localctx = _tracker.createInstance<FieldTypeListContext>(_ctx, getState());
    enterRule(_localctx, 768, GQLParser::RuleFieldTypeList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3649);
      {
        auto childCtxHolder = ctx->EnterFieldType();
        fieldType(get_raw_pointer(childCtxHolder));
      }
      setState(3654);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(3650);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(3651);
        {
          auto childCtxHolder = ctx->EnterFieldType();
          fieldType(get_raw_pointer(childCtxHolder));
        }
        setState(3656);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NotNullContext : public antlr4::ParserRuleContext {
  public:
    NotNullContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *NULL_KW();

   
  };

  template<typename ContextT>
  NotNullContext* notNull(ContextT* ctx) {
    NotNullContext *_localctx = _tracker.createInstance<NotNullContext>(_ctx, getState());
    enterRule(_localctx, 770, GQLParser::RuleNotNull);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3657);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NOT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NOT);
      setState(3658);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NULL_KW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NULL_KW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FieldTypeContext : public antlr4::ParserRuleContext {
  public:
    FieldTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    FieldNameContext *fieldName();
    ValueTypeContext *valueType();
    TypedContext *typed();

   
  };

  template<typename ContextT>
  FieldTypeContext* fieldType(ContextT* ctx) {
    FieldTypeContext *_localctx = _tracker.createInstance<FieldTypeContext>(_ctx, getState());
    enterRule(_localctx, 772, GQLParser::RuleFieldType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3660);
      {
        auto childCtxHolder = ctx->EnterFieldName();
        fieldName(get_raw_pointer(childCtxHolder));
      }
      setState(3662);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::TYPED || _la == GQLParser::DOUBLE_COLON) {
        setState(3661);
        {
          auto childCtxHolder = ctx->EnterTyped();
          typed(get_raw_pointer(childCtxHolder));
        }
      }
      setState(3664);
      {
        auto childCtxHolder = ctx->EnterValueType();
        valueType(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SearchConditionContext : public antlr4::ParserRuleContext {
  public:
    SearchConditionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BooleanValueExpressionContext *booleanValueExpression();

   
  };

  template<typename ContextT>
  SearchConditionContext* searchCondition(ContextT* ctx) {
    SearchConditionContext *_localctx = _tracker.createInstance<SearchConditionContext>(_ctx, getState());
    enterRule(_localctx, 774, GQLParser::RuleSearchCondition);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3666);
      {
        auto childCtxHolder = ctx->EnterBooleanValueExpression();
        booleanValueExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PredicateContext : public antlr4::ParserRuleContext {
  public:
    PredicateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExistsPredicateContext *existsPredicate();
    NullPredicateContext *nullPredicate();
    ValueTypePredicateContext *valueTypePredicate();
    DirectedPredicateContext *directedPredicate();
    LabeledPredicateContext *labeledPredicate();
    SourceDestinationPredicateContext *sourceDestinationPredicate();
    All_differentPredicateContext *all_differentPredicate();
    SamePredicateContext *samePredicate();
    Property_existsPredicateContext *property_existsPredicate();

   
  };

  template<typename ContextT>
  PredicateContext* predicate(ContextT* ctx) {
    PredicateContext *_localctx = _tracker.createInstance<PredicateContext>(_ctx, getState());
    enterRule(_localctx, 776, GQLParser::RulePredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3677);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 421, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3668);
        {
          auto childCtxHolder = ctx->EnterExistsPredicate();
          existsPredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3669);
        {
          auto childCtxHolder = ctx->EnterNullPredicate();
          nullPredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3670);
        {
          auto childCtxHolder = ctx->EnterValueTypePredicate();
          valueTypePredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(3671);
        {
          auto childCtxHolder = ctx->EnterDirectedPredicate();
          directedPredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(3672);
        {
          auto childCtxHolder = ctx->EnterLabeledPredicate();
          labeledPredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(3673);
        {
          auto childCtxHolder = ctx->EnterSourceDestinationPredicate();
          sourceDestinationPredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(3674);
        {
          auto childCtxHolder = ctx->EnterAll_differentPredicate();
          all_differentPredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(3675);
        {
          auto childCtxHolder = ctx->EnterSamePredicate();
          samePredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(3676);
        {
          auto childCtxHolder = ctx->EnterProperty_existsPredicate();
          property_existsPredicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CompOpContext : public antlr4::ParserRuleContext {
  public:
    CompOpContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EQUALS_OPERATOR();
    antlr4::tree::TerminalNode *NOT_EQUALS_OPERATOR();
    antlr4::tree::TerminalNode *LEFT_ANGLE_BRACKET();
    antlr4::tree::TerminalNode *RIGHT_ANGLE_BRACKET();
    antlr4::tree::TerminalNode *LESS_THAN_OR_EQUALS_OPERATOR();
    antlr4::tree::TerminalNode *GREATER_THAN_OR_EQUALS_OPERATOR();

   
  };

  template<typename ContextT>
  CompOpContext* compOp(ContextT* ctx) {
    CompOpContext *_localctx = _tracker.createInstance<CompOpContext>(_ctx, getState());
    enterRule(_localctx, 778, GQLParser::RuleCompOp);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3679);
      _la = _input->LA(1);
      if (!(((((_la - 335) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 335)) & 142807664897) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ExistsPredicateContext : public antlr4::ParserRuleContext {
  public:
    ExistsPredicateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXISTS();
    antlr4::tree::TerminalNode *LEFT_BRACE();
    GraphPatternContext *graphPattern();
    antlr4::tree::TerminalNode *RIGHT_BRACE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    MatchStatementBlockContext *matchStatementBlock();
    NestedQuerySpecificationContext *nestedQuerySpecification();

   
  };

  template<typename ContextT>
  ExistsPredicateContext* existsPredicate(ContextT* ctx) {
    ExistsPredicateContext *_localctx = _tracker.createInstance<ExistsPredicateContext>(_ctx, getState());
    enterRule(_localctx, 780, GQLParser::RuleExistsPredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3681);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EXISTS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EXISTS);
      setState(3699);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 422, _ctx)) {
      case 1: {
        setState(3682);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_BRACE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_BRACE);
        setState(3683);
        {
          auto childCtxHolder = ctx->EnterGraphPattern();
          graphPattern(get_raw_pointer(childCtxHolder));
        }
        setState(3684);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_BRACE);
        break;
      }

      case 2: {
        setState(3686);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(3687);
        {
          auto childCtxHolder = ctx->EnterGraphPattern();
          graphPattern(get_raw_pointer(childCtxHolder));
        }
        setState(3688);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      case 3: {
        setState(3690);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_BRACE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_BRACE);
        setState(3691);
        {
          auto childCtxHolder = ctx->EnterMatchStatementBlock();
          matchStatementBlock(get_raw_pointer(childCtxHolder));
        }
        setState(3692);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_BRACE);
        break;
      }

      case 4: {
        setState(3694);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(3695);
        {
          auto childCtxHolder = ctx->EnterMatchStatementBlock();
          matchStatementBlock(get_raw_pointer(childCtxHolder));
        }
        setState(3696);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      case 5: {
        setState(3698);
        {
          auto childCtxHolder = ctx->EnterNestedQuerySpecification();
          nestedQuerySpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NullPredicateContext : public antlr4::ParserRuleContext {
  public:
    NullPredicateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionPrimaryContext *valueExpressionPrimary();
    NullPredicatePart2Context *nullPredicatePart2();

   
  };

  template<typename ContextT>
  NullPredicateContext* nullPredicate(ContextT* ctx) {
    NullPredicateContext *_localctx = _tracker.createInstance<NullPredicateContext>(_ctx, getState());
    enterRule(_localctx, 782, GQLParser::RuleNullPredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3701);
      {
        auto childCtxHolder = ctx->EnterValueExpressionPrimary();
        valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
      }
      setState(3702);
      {
        auto childCtxHolder = ctx->EnterNullPredicatePart2();
        nullPredicatePart2(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NullPredicatePart2Context : public antlr4::ParserRuleContext {
  public:
    NullPredicatePart2Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *NULL_KW();
    antlr4::tree::TerminalNode *NOT();

   
  };

  template<typename ContextT>
  NullPredicatePart2Context* nullPredicatePart2(ContextT* ctx) {
    NullPredicatePart2Context *_localctx = _tracker.createInstance<NullPredicatePart2Context>(_ctx, getState());
    enterRule(_localctx, 784, GQLParser::RuleNullPredicatePart2);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3704);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IS);
      setState(3706);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::NOT) {
        setState(3705);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
      }
      setState(3708);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NULL_KW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NULL_KW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ValueTypePredicateContext : public antlr4::ParserRuleContext {
  public:
    ValueTypePredicateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionPrimaryContext *valueExpressionPrimary();
    ValueTypePredicatePart2Context *valueTypePredicatePart2();

   
  };

  template<typename ContextT>
  ValueTypePredicateContext* valueTypePredicate(ContextT* ctx) {
    ValueTypePredicateContext *_localctx = _tracker.createInstance<ValueTypePredicateContext>(_ctx, getState());
    enterRule(_localctx, 786, GQLParser::RuleValueTypePredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3710);
      {
        auto childCtxHolder = ctx->EnterValueExpressionPrimary();
        valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
      }
      setState(3711);
      {
        auto childCtxHolder = ctx->EnterValueTypePredicatePart2();
        valueTypePredicatePart2(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ValueTypePredicatePart2Context : public antlr4::ParserRuleContext {
  public:
    ValueTypePredicatePart2Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IS();
    TypedContext *typed();
    ValueTypeContext *valueType();
    antlr4::tree::TerminalNode *NOT();

   
  };

  template<typename ContextT>
  ValueTypePredicatePart2Context* valueTypePredicatePart2(ContextT* ctx) {
    ValueTypePredicatePart2Context *_localctx = _tracker.createInstance<ValueTypePredicatePart2Context>(_ctx, getState());
    enterRule(_localctx, 788, GQLParser::RuleValueTypePredicatePart2);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3713);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IS);
      setState(3715);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::NOT) {
        setState(3714);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
      }
      setState(3717);
      {
        auto childCtxHolder = ctx->EnterTyped();
        typed(get_raw_pointer(childCtxHolder));
      }
      setState(3718);
      {
        auto childCtxHolder = ctx->EnterValueType();
        valueType(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NormalizedPredicatePart2Context : public antlr4::ParserRuleContext {
  public:
    NormalizedPredicatePart2Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *NORMALIZED();
    antlr4::tree::TerminalNode *NOT();
    NormalFormContext *normalForm();

   
  };

  template<typename ContextT>
  NormalizedPredicatePart2Context* normalizedPredicatePart2(ContextT* ctx) {
    NormalizedPredicatePart2Context *_localctx = _tracker.createInstance<NormalizedPredicatePart2Context>(_ctx, getState());
    enterRule(_localctx, 790, GQLParser::RuleNormalizedPredicatePart2);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3720);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IS);
      setState(3722);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::NOT) {
        setState(3721);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
      }
      setState(3725);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 296) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 296)) & 15) != 0)) {
        setState(3724);
        {
          auto childCtxHolder = ctx->EnterNormalForm();
          normalForm(get_raw_pointer(childCtxHolder));
        }
      }
      setState(3727);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NORMALIZED) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NORMALIZED);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DirectedPredicateContext : public antlr4::ParserRuleContext {
  public:
    DirectedPredicateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ElementVariableReferenceContext *elementVariableReference();
    DirectedPredicatePart2Context *directedPredicatePart2();

   
  };

  template<typename ContextT>
  DirectedPredicateContext* directedPredicate(ContextT* ctx) {
    DirectedPredicateContext *_localctx = _tracker.createInstance<DirectedPredicateContext>(_ctx, getState());
    enterRule(_localctx, 792, GQLParser::RuleDirectedPredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3729);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(3730);
      {
        auto childCtxHolder = ctx->EnterDirectedPredicatePart2();
        directedPredicatePart2(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DirectedPredicatePart2Context : public antlr4::ParserRuleContext {
  public:
    DirectedPredicatePart2Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *DIRECTED();
    antlr4::tree::TerminalNode *NOT();

   
  };

  template<typename ContextT>
  DirectedPredicatePart2Context* directedPredicatePart2(ContextT* ctx) {
    DirectedPredicatePart2Context *_localctx = _tracker.createInstance<DirectedPredicatePart2Context>(_ctx, getState());
    enterRule(_localctx, 794, GQLParser::RuleDirectedPredicatePart2);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3732);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IS);
      setState(3734);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::NOT) {
        setState(3733);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
      }
      setState(3736);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DIRECTED) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DIRECTED);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LabeledPredicateContext : public antlr4::ParserRuleContext {
  public:
    LabeledPredicateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ElementVariableReferenceContext *elementVariableReference();
    LabeledPredicatePart2Context *labeledPredicatePart2();

   
  };

  template<typename ContextT>
  LabeledPredicateContext* labeledPredicate(ContextT* ctx) {
    LabeledPredicateContext *_localctx = _tracker.createInstance<LabeledPredicateContext>(_ctx, getState());
    enterRule(_localctx, 796, GQLParser::RuleLabeledPredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3738);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(3739);
      {
        auto childCtxHolder = ctx->EnterLabeledPredicatePart2();
        labeledPredicatePart2(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LabeledPredicatePart2Context : public antlr4::ParserRuleContext {
  public:
    LabeledPredicatePart2Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IsLabeledOrColonContext *isLabeledOrColon();
    LabelExpressionContext *labelExpression();

   
  };

  template<typename ContextT>
  LabeledPredicatePart2Context* labeledPredicatePart2(ContextT* ctx) {
    LabeledPredicatePart2Context *_localctx = _tracker.createInstance<LabeledPredicatePart2Context>(_ctx, getState());
    enterRule(_localctx, 798, GQLParser::RuleLabeledPredicatePart2);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3741);
      {
        auto childCtxHolder = ctx->EnterIsLabeledOrColon();
        isLabeledOrColon(get_raw_pointer(childCtxHolder));
      }
      setState(3742);
      {
        auto childCtxHolder = ctx->EnterLabelExpression();
        labelExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  IsLabeledOrColonContext : public antlr4::ParserRuleContext {
  public:
    IsLabeledOrColonContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *LABELED();
    antlr4::tree::TerminalNode *NOT();
    antlr4::tree::TerminalNode *COLON();

   
  };

  template<typename ContextT>
  IsLabeledOrColonContext* isLabeledOrColon(ContextT* ctx) {
    IsLabeledOrColonContext *_localctx = _tracker.createInstance<IsLabeledOrColonContext>(_ctx, getState());
    enterRule(_localctx, 800, GQLParser::RuleIsLabeledOrColon);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3750);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::IS: {
          enterOuterAlt(_localctx, 1);
          setState(3744);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::IS) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::IS);
          setState(3746);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::NOT) {
            setState(3745);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::NOT) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::NOT);
          }
          setState(3748);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LABELED) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LABELED);
          break;
        }

        case GQLParser::COLON: {
          enterOuterAlt(_localctx, 2);
          setState(3749);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COLON) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COLON);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SourceDestinationPredicateContext : public antlr4::ParserRuleContext {
  public:
    SourceDestinationPredicateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NodeReferenceContext *nodeReference();
    SourcePredicatePart2Context *sourcePredicatePart2();
    DestinationPredicatePart2Context *destinationPredicatePart2();

   
  };

  template<typename ContextT>
  SourceDestinationPredicateContext* sourceDestinationPredicate(ContextT* ctx) {
    SourceDestinationPredicateContext *_localctx = _tracker.createInstance<SourceDestinationPredicateContext>(_ctx, getState());
    enterRule(_localctx, 802, GQLParser::RuleSourceDestinationPredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3758);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 430, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3752);
        {
          auto childCtxHolder = ctx->EnterNodeReference();
          nodeReference(get_raw_pointer(childCtxHolder));
        }
        setState(3753);
        {
          auto childCtxHolder = ctx->EnterSourcePredicatePart2();
          sourcePredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3755);
        {
          auto childCtxHolder = ctx->EnterNodeReference();
          nodeReference(get_raw_pointer(childCtxHolder));
        }
        setState(3756);
        {
          auto childCtxHolder = ctx->EnterDestinationPredicatePart2();
          destinationPredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NodeReferenceContext : public antlr4::ParserRuleContext {
  public:
    NodeReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ElementVariableReferenceContext *elementVariableReference();

   
  };

  template<typename ContextT>
  NodeReferenceContext* nodeReference(ContextT* ctx) {
    NodeReferenceContext *_localctx = _tracker.createInstance<NodeReferenceContext>(_ctx, getState());
    enterRule(_localctx, 804, GQLParser::RuleNodeReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3760);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SourcePredicatePart2Context : public antlr4::ParserRuleContext {
  public:
    SourcePredicatePart2Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *SOURCE();
    antlr4::tree::TerminalNode *OF();
    EdgeReferenceContext *edgeReference();
    antlr4::tree::TerminalNode *NOT();

   
  };

  template<typename ContextT>
  SourcePredicatePart2Context* sourcePredicatePart2(ContextT* ctx) {
    SourcePredicatePart2Context *_localctx = _tracker.createInstance<SourcePredicatePart2Context>(_ctx, getState());
    enterRule(_localctx, 806, GQLParser::RuleSourcePredicatePart2);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3762);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IS);
      setState(3764);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::NOT) {
        setState(3763);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
      }
      setState(3766);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SOURCE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SOURCE);
      setState(3767);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::OF) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::OF);
      setState(3768);
      {
        auto childCtxHolder = ctx->EnterEdgeReference();
        edgeReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DestinationPredicatePart2Context : public antlr4::ParserRuleContext {
  public:
    DestinationPredicatePart2Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *IS();
    antlr4::tree::TerminalNode *DESTINATION();
    antlr4::tree::TerminalNode *OF();
    EdgeReferenceContext *edgeReference();
    antlr4::tree::TerminalNode *NOT();

   
  };

  template<typename ContextT>
  DestinationPredicatePart2Context* destinationPredicatePart2(ContextT* ctx) {
    DestinationPredicatePart2Context *_localctx = _tracker.createInstance<DestinationPredicatePart2Context>(_ctx, getState());
    enterRule(_localctx, 808, GQLParser::RuleDestinationPredicatePart2);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3770);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IS);
      setState(3772);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::NOT) {
        setState(3771);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
      }
      setState(3774);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DESTINATION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DESTINATION);
      setState(3775);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::OF) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::OF);
      setState(3776);
      {
        auto childCtxHolder = ctx->EnterEdgeReference();
        edgeReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeReferenceContext : public antlr4::ParserRuleContext {
  public:
    EdgeReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ElementVariableReferenceContext *elementVariableReference();

   
  };

  template<typename ContextT>
  EdgeReferenceContext* edgeReference(ContextT* ctx) {
    EdgeReferenceContext *_localctx = _tracker.createInstance<EdgeReferenceContext>(_ctx, getState());
    enterRule(_localctx, 810, GQLParser::RuleEdgeReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3778);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  All_differentPredicateContext : public antlr4::ParserRuleContext {
  public:
    All_differentPredicateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ALL_DIFFERENT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ElementVariableReferenceContext *> elementVariableReference();
    ElementVariableReferenceContext* elementVariableReference(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  All_differentPredicateContext* all_differentPredicate(ContextT* ctx) {
    All_differentPredicateContext *_localctx = _tracker.createInstance<All_differentPredicateContext>(_ctx, getState());
    enterRule(_localctx, 812, GQLParser::RuleAll_differentPredicate);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3780);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ALL_DIFFERENT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ALL_DIFFERENT);
      setState(3781);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3782);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(3783);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(3784);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(3789);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(3785);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(3786);
        {
          auto childCtxHolder = ctx->EnterElementVariableReference();
          elementVariableReference(get_raw_pointer(childCtxHolder));
        }
        setState(3791);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3792);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SamePredicateContext : public antlr4::ParserRuleContext {
  public:
    SamePredicateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SAME();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ElementVariableReferenceContext *> elementVariableReference();
    ElementVariableReferenceContext* elementVariableReference(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  SamePredicateContext* samePredicate(ContextT* ctx) {
    SamePredicateContext *_localctx = _tracker.createInstance<SamePredicateContext>(_ctx, getState());
    enterRule(_localctx, 814, GQLParser::RuleSamePredicate);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3794);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SAME) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SAME);
      setState(3795);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3796);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(3797);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(3798);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(3803);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(3799);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(3800);
        {
          auto childCtxHolder = ctx->EnterElementVariableReference();
          elementVariableReference(get_raw_pointer(childCtxHolder));
        }
        setState(3805);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(3806);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  Property_existsPredicateContext : public antlr4::ParserRuleContext {
  public:
    Property_existsPredicateContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PROPERTY_EXISTS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ElementVariableReferenceContext *elementVariableReference();
    antlr4::tree::TerminalNode *COMMA();
    PropertyNameContext *propertyName();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  Property_existsPredicateContext* property_existsPredicate(ContextT* ctx) {
    Property_existsPredicateContext *_localctx = _tracker.createInstance<Property_existsPredicateContext>(_ctx, getState());
    enterRule(_localctx, 816, GQLParser::RuleProperty_existsPredicate);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3808);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::PROPERTY_EXISTS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::PROPERTY_EXISTS);
      setState(3809);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3810);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(3811);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(3812);
      {
        auto childCtxHolder = ctx->EnterPropertyName();
        propertyName(get_raw_pointer(childCtxHolder));
      }
      setState(3813);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    ValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
   
    ValueExpressionContext() = default;
    void copyFrom(ValueExpressionContext *context);
    using antlr4::ParserRuleContext::copyFrom;

    virtual size_t getRuleIndex() const override;

   
  };

  class  ConjunctiveExprAltContext : public ValueExpressionContext {
  public:
    ConjunctiveExprAltContext(ValueExpressionContext *ctx);

    std::vector<ValueExpressionContext *> valueExpression();
    ValueExpressionContext* valueExpression(size_t i);
    antlr4::tree::TerminalNode *AND();
  };

  class  PropertyGraphExprAltContext : public ValueExpressionContext {
  public:
    PropertyGraphExprAltContext(ValueExpressionContext *ctx);

    antlr4::tree::TerminalNode *GRAPH();
    GraphExpressionContext *graphExpression();
    antlr4::tree::TerminalNode *PROPERTY();
  };

  class  MultDivExprAltContext : public ValueExpressionContext {
  public:
    MultDivExprAltContext(ValueExpressionContext *ctx);

    antlr4::Token *operator_ = nullptr;
    std::vector<ValueExpressionContext *> valueExpression();
    ValueExpressionContext* valueExpression(size_t i);
    antlr4::tree::TerminalNode *ASTERISK();
    antlr4::tree::TerminalNode *SOLIDUS();
  };

  class  BindingTableExprAltContext : public ValueExpressionContext {
  public:
    BindingTableExprAltContext(ValueExpressionContext *ctx);

    antlr4::tree::TerminalNode *TABLE();
    BindingTableExpressionContext *bindingTableExpression();
    antlr4::tree::TerminalNode *BINDING();
  };

  class  SignedExprAltContext : public ValueExpressionContext {
  public:
    SignedExprAltContext(ValueExpressionContext *ctx);

    antlr4::Token *sign = nullptr;
    ValueExpressionContext *valueExpression();
    antlr4::tree::TerminalNode *PLUS_SIGN();
    antlr4::tree::TerminalNode *MINUS_SIGN();
  };

  class  IsNotExprAltContext : public ValueExpressionContext {
  public:
    IsNotExprAltContext(ValueExpressionContext *ctx);

    ValueExpressionContext *valueExpression();
    antlr4::tree::TerminalNode *IS();
    TruthValueContext *truthValue();
    antlr4::tree::TerminalNode *NOT();
  };

  class  NormalizedPredicateExprAltContext : public ValueExpressionContext {
  public:
    NormalizedPredicateExprAltContext(ValueExpressionContext *ctx);

    ValueExpressionContext *valueExpression();
    NormalizedPredicatePart2Context *normalizedPredicatePart2();
  };

  class  NotExprAltContext : public ValueExpressionContext {
  public:
    NotExprAltContext(ValueExpressionContext *ctx);

    antlr4::tree::TerminalNode *NOT();
    ValueExpressionContext *valueExpression();
  };

  class  ValueFunctionExprAltContext : public ValueExpressionContext {
  public:
    ValueFunctionExprAltContext(ValueExpressionContext *ctx);

    ValueFunctionContext *valueFunction();
  };

  class  ConcatenationExprAltContext : public ValueExpressionContext {
  public:
    ConcatenationExprAltContext(ValueExpressionContext *ctx);

    std::vector<ValueExpressionContext *> valueExpression();
    ValueExpressionContext* valueExpression(size_t i);
    antlr4::tree::TerminalNode *CONCATENATION_OPERATOR();
  };

  class  DisjunctiveExprAltContext : public ValueExpressionContext {
  public:
    DisjunctiveExprAltContext(ValueExpressionContext *ctx);

    antlr4::Token *operator_ = nullptr;
    std::vector<ValueExpressionContext *> valueExpression();
    ValueExpressionContext* valueExpression(size_t i);
    antlr4::tree::TerminalNode *OR();
    antlr4::tree::TerminalNode *XOR();
  };

  class  ComparisonExprAltContext : public ValueExpressionContext {
  public:
    ComparisonExprAltContext(ValueExpressionContext *ctx);

    std::vector<ValueExpressionContext *> valueExpression();
    ValueExpressionContext* valueExpression(size_t i);
    CompOpContext *compOp();
  };

  class  PrimaryExprAltContext : public ValueExpressionContext {
  public:
    PrimaryExprAltContext(ValueExpressionContext *ctx);

    ValueExpressionPrimaryContext *valueExpressionPrimary();
  };

  class  AddSubtractExprAltContext : public ValueExpressionContext {
  public:
    AddSubtractExprAltContext(ValueExpressionContext *ctx);

    antlr4::Token *operator_ = nullptr;
    std::vector<ValueExpressionContext *> valueExpression();
    ValueExpressionContext* valueExpression(size_t i);
    antlr4::tree::TerminalNode *PLUS_SIGN();
    antlr4::tree::TerminalNode *MINUS_SIGN();
  };

  class  PredicateExprAltContext : public ValueExpressionContext {
  public:
    PredicateExprAltContext(ValueExpressionContext *ctx);

    PredicateContext *predicate();
  };


  template<typename ContextT>
  ValueExpressionContext* valueExpression(ContextT* ctx) {
     return valueExpression(0, ctx);
  }

  template<typename ContextT>
  ValueExpressionContext* valueExpression(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    GQLParser::ValueExpressionContext *_localctx = _tracker.createInstance<ValueExpressionContext>(_ctx, parentState);
    GQLParser::ValueExpressionContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 818;
    enterRecursionRule(_localctx, 818, GQLParser::RuleValueExpression, precedence);

      size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(3833);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 437, _ctx)) {
      case 1: {
        _localctx = _tracker.createInstance<SignedExprAltContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterSignedExprAlt();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });

        setState(3816);
        antlrcpp::downCast<SignedExprAltContext *>(_localctx)->sign = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == GQLParser::MINUS_SIGN

        || _la == GQLParser::PLUS_SIGN)) {
          antlrcpp::downCast<SignedExprAltContext *>(_localctx)->sign = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          antlr4::Token * token = consume();
          ctx->OnToken(token);
        }
        setState(3817);
        {
          auto childCtxHolder = ctx->EnterValueExpression();
          valueExpression(15, get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        _localctx = _tracker.createInstance<PredicateExprAltContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterPredicateExprAlt();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3818);
        {
          auto childCtxHolder = ctx->EnterPredicate();
          predicate(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        _localctx = _tracker.createInstance<NotExprAltContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterNotExprAlt();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3819);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::NOT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::NOT);
        setState(3820);
        {
          auto childCtxHolder = ctx->EnterValueExpression();
          valueExpression(7, get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        _localctx = _tracker.createInstance<PropertyGraphExprAltContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterPropertyGraphExprAlt();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3822);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::PROPERTY) {
          setState(3821);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::PROPERTY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::PROPERTY);
        }
        setState(3824);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::GRAPH) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::GRAPH);
        setState(3825);
        {
          auto childCtxHolder = ctx->EnterGraphExpression();
          graphExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        _localctx = _tracker.createInstance<BindingTableExprAltContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterBindingTableExprAlt();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3827);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::BINDING) {
          setState(3826);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::BINDING) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::BINDING);
        }
        setState(3829);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::TABLE) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::TABLE);
        setState(3830);
        {
          auto childCtxHolder = ctx->EnterBindingTableExpression();
          bindingTableExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        _localctx = _tracker.createInstance<ValueFunctionExprAltContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterValueFunctionExprAlt();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3831);
        {
          auto childCtxHolder = ctx->EnterValueFunction();
          valueFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 7: {
        _localctx = _tracker.createInstance<PrimaryExprAltContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        auto ctxHolder = ctx->EnterPrimaryExprAlt();
        auto ctx = get_raw_pointer(ctxHolder);
        auto onExit = antlrcpp::finally([ctx, _localctx] {
          (void)_localctx;
          if constexpr (has_ExitRule<decltype(ctx)>::value)
            ctx->ExitRule(_localctx);
          else
            (void)ctx;
        });
        setState(3832);
        {
          auto childCtxHolder = ctx->EnterValueExpressionPrimary();
          valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
      _ctx->stop = _input->LT(-1);
      setState(3864);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 440, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          setState(3862);
          _errHandler->sync(this);
          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 439, _ctx)) {
          case 1: {
            auto newContext = _tracker.createInstance<MultDivExprAltContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushMultDivExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3835);

            if (!(precpred(_ctx, 14))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 14)");
            setState(3836);
            antlrcpp::downCast<MultDivExprAltContext *>(_localctx)->operator_ = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == GQLParser::ASTERISK

            || _la == GQLParser::SOLIDUS)) {
              antlrcpp::downCast<MultDivExprAltContext *>(_localctx)->operator_ = _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              antlr4::Token * token = consume();
              ctx->OnToken(token);
            }
            setState(3837);
            {
              auto childCtxHolder = ctx->EnterValueExpression();
              valueExpression(15, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 2: {
            auto newContext = _tracker.createInstance<AddSubtractExprAltContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushAddSubtractExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3838);

            if (!(precpred(_ctx, 13))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 13)");
            setState(3839);
            antlrcpp::downCast<AddSubtractExprAltContext *>(_localctx)->operator_ = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == GQLParser::MINUS_SIGN

            || _la == GQLParser::PLUS_SIGN)) {
              antlrcpp::downCast<AddSubtractExprAltContext *>(_localctx)->operator_ = _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              antlr4::Token * token = consume();
              ctx->OnToken(token);
            }
            setState(3840);
            {
              auto childCtxHolder = ctx->EnterValueExpression();
              valueExpression(14, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 3: {
            auto newContext = _tracker.createInstance<ConcatenationExprAltContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushConcatenationExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3841);

            if (!(precpred(_ctx, 12))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 12)");
            setState(3842);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::CONCATENATION_OPERATOR) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::CONCATENATION_OPERATOR);
            setState(3843);
            {
              auto childCtxHolder = ctx->EnterValueExpression();
              valueExpression(13, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 4: {
            auto newContext = _tracker.createInstance<ComparisonExprAltContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushComparisonExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3844);

            if (!(precpred(_ctx, 11))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 11)");
            setState(3845);
            {
              auto childCtxHolder = ctx->EnterCompOp();
              compOp(get_raw_pointer(childCtxHolder));
            }
            setState(3846);
            {
              auto childCtxHolder = ctx->EnterValueExpression();
              valueExpression(12, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 5: {
            auto newContext = _tracker.createInstance<ConjunctiveExprAltContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushConjunctiveExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3848);

            if (!(precpred(_ctx, 6))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 6)");
            setState(3849);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::AND) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::AND);
            setState(3850);
            {
              auto childCtxHolder = ctx->EnterValueExpression();
              valueExpression(7, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 6: {
            auto newContext = _tracker.createInstance<DisjunctiveExprAltContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushDisjunctiveExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3851);

            if (!(precpred(_ctx, 5))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 5)");
            setState(3852);
            antlrcpp::downCast<DisjunctiveExprAltContext *>(_localctx)->operator_ = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == GQLParser::OR || _la == GQLParser::XOR)) {
              antlrcpp::downCast<DisjunctiveExprAltContext *>(_localctx)->operator_ = _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              antlr4::Token * token = consume();
              ctx->OnToken(token);
            }
            setState(3853);
            {
              auto childCtxHolder = ctx->EnterValueExpression();
              valueExpression(6, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 7: {
            auto newContext = _tracker.createInstance<NormalizedPredicateExprAltContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushNormalizedPredicateExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3854);

            if (!(precpred(_ctx, 9))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 9)");
            setState(3855);
            {
              auto childCtxHolder = ctx->EnterNormalizedPredicatePart2();
              normalizedPredicatePart2(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 8: {
            auto newContext = _tracker.createInstance<IsNotExprAltContext>(_tracker.createInstance<ValueExpressionContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleValueExpression);
            auto ctxHolder = ctx->PushIsNotExprAlt_ValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(3856);

            if (!(precpred(_ctx, 8))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 8)");
            setState(3857);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::IS) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::IS);
            setState(3859);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == GQLParser::NOT) {
              setState(3858);
              if constexpr (has_OnToken<decltype(ctx)>::value) {
                if (_input->LA(1) == GQLParser::NOT) {
                  ctx->OnToken(_input->LT(1));
                }
              }
              match(GQLParser::NOT);
            }
            setState(3861);
            {
              auto childCtxHolder = ctx->EnterTruthValue();
              truthValue(get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          } 
        }
        setState(3866);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 440, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }

  class  ValueFunctionContext : public antlr4::ParserRuleContext {
  public:
    ValueFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NumericValueFunctionContext *numericValueFunction();
    DatetimeSubtractionContext *datetimeSubtraction();
    DatetimeValueFunctionContext *datetimeValueFunction();
    DurationValueFunctionContext *durationValueFunction();
    CharacterOrByteStringFunctionContext *characterOrByteStringFunction();
    ListValueFunctionContext *listValueFunction();

   
  };

  template<typename ContextT>
  ValueFunctionContext* valueFunction(ContextT* ctx) {
    ValueFunctionContext *_localctx = _tracker.createInstance<ValueFunctionContext>(_ctx, getState());
    enterRule(_localctx, 820, GQLParser::RuleValueFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3873);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 441, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3867);
        {
          auto childCtxHolder = ctx->EnterNumericValueFunction();
          numericValueFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3868);
        {
          auto childCtxHolder = ctx->EnterDatetimeSubtraction();
          datetimeSubtraction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3869);
        {
          auto childCtxHolder = ctx->EnterDatetimeValueFunction();
          datetimeValueFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(3870);
        {
          auto childCtxHolder = ctx->EnterDurationValueFunction();
          durationValueFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(3871);
        {
          auto childCtxHolder = ctx->EnterCharacterOrByteStringFunction();
          characterOrByteStringFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(3872);
        {
          auto childCtxHolder = ctx->EnterListValueFunction();
          listValueFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BooleanValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    BooleanValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  BooleanValueExpressionContext* booleanValueExpression(ContextT* ctx) {
    BooleanValueExpressionContext *_localctx = _tracker.createInstance<BooleanValueExpressionContext>(_ctx, getState());
    enterRule(_localctx, 822, GQLParser::RuleBooleanValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3875);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CharacterOrByteStringFunctionContext : public antlr4::ParserRuleContext {
  public:
    CharacterOrByteStringFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SubCharacterOrByteStringContext *subCharacterOrByteString();
    TrimSingleCharacterOrByteStringContext *trimSingleCharacterOrByteString();
    FoldCharacterStringContext *foldCharacterString();
    TrimMultiCharacterCharacterStringContext *trimMultiCharacterCharacterString();
    NormalizeCharacterStringContext *normalizeCharacterString();

   
  };

  template<typename ContextT>
  CharacterOrByteStringFunctionContext* characterOrByteStringFunction(ContextT* ctx) {
    CharacterOrByteStringFunctionContext *_localctx = _tracker.createInstance<CharacterOrByteStringFunctionContext>(_ctx, getState());
    enterRule(_localctx, 824, GQLParser::RuleCharacterOrByteStringFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3882);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LEFT:
        case GQLParser::RIGHT: {
          enterOuterAlt(_localctx, 1);
          setState(3877);
          {
            auto childCtxHolder = ctx->EnterSubCharacterOrByteString();
            subCharacterOrByteString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::TRIM: {
          enterOuterAlt(_localctx, 2);
          setState(3878);
          {
            auto childCtxHolder = ctx->EnterTrimSingleCharacterOrByteString();
            trimSingleCharacterOrByteString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LOWER:
        case GQLParser::UPPER: {
          enterOuterAlt(_localctx, 3);
          setState(3879);
          {
            auto childCtxHolder = ctx->EnterFoldCharacterString();
            foldCharacterString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BTRIM:
        case GQLParser::LTRIM:
        case GQLParser::RTRIM: {
          enterOuterAlt(_localctx, 4);
          setState(3880);
          {
            auto childCtxHolder = ctx->EnterTrimMultiCharacterCharacterString();
            trimMultiCharacterCharacterString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::NORMALIZE: {
          enterOuterAlt(_localctx, 5);
          setState(3881);
          {
            auto childCtxHolder = ctx->EnterNormalizeCharacterString();
            normalizeCharacterString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SubCharacterOrByteStringContext : public antlr4::ParserRuleContext {
  public:
    SubCharacterOrByteStringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ValueExpressionContext *valueExpression();
    antlr4::tree::TerminalNode *COMMA();
    StringLengthContext *stringLength();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *LEFT();
    antlr4::tree::TerminalNode *RIGHT();

   
  };

  template<typename ContextT>
  SubCharacterOrByteStringContext* subCharacterOrByteString(ContextT* ctx) {
    SubCharacterOrByteStringContext *_localctx = _tracker.createInstance<SubCharacterOrByteStringContext>(_ctx, getState());
    enterRule(_localctx, 826, GQLParser::RuleSubCharacterOrByteString);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3884);
      _la = _input->LA(1);
      if (!(_la == GQLParser::LEFT

      || _la == GQLParser::RIGHT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(3885);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3886);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(3887);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(3888);
      {
        auto childCtxHolder = ctx->EnterStringLength();
        stringLength(get_raw_pointer(childCtxHolder));
      }
      setState(3889);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TrimSingleCharacterOrByteStringContext : public antlr4::ParserRuleContext {
  public:
    TrimSingleCharacterOrByteStringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TRIM();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    TrimOperandsContext *trimOperands();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  TrimSingleCharacterOrByteStringContext* trimSingleCharacterOrByteString(ContextT* ctx) {
    TrimSingleCharacterOrByteStringContext *_localctx = _tracker.createInstance<TrimSingleCharacterOrByteStringContext>(_ctx, getState());
    enterRule(_localctx, 828, GQLParser::RuleTrimSingleCharacterOrByteString);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3891);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TRIM) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TRIM);
      setState(3892);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3893);
      {
        auto childCtxHolder = ctx->EnterTrimOperands();
        trimOperands(get_raw_pointer(childCtxHolder));
      }
      setState(3894);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FoldCharacterStringContext : public antlr4::ParserRuleContext {
  public:
    FoldCharacterStringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ValueExpressionContext *valueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *UPPER();
    antlr4::tree::TerminalNode *LOWER();

   
  };

  template<typename ContextT>
  FoldCharacterStringContext* foldCharacterString(ContextT* ctx) {
    FoldCharacterStringContext *_localctx = _tracker.createInstance<FoldCharacterStringContext>(_ctx, getState());
    enterRule(_localctx, 830, GQLParser::RuleFoldCharacterString);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3896);
      _la = _input->LA(1);
      if (!(_la == GQLParser::LOWER || _la == GQLParser::UPPER)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(3897);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3898);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(3899);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TrimMultiCharacterCharacterStringContext : public antlr4::ParserRuleContext {
  public:
    TrimMultiCharacterCharacterStringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ValueExpressionContext *> valueExpression();
    ValueExpressionContext* valueExpression(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *BTRIM();
    antlr4::tree::TerminalNode *LTRIM();
    antlr4::tree::TerminalNode *RTRIM();
    antlr4::tree::TerminalNode *COMMA();

   
  };

  template<typename ContextT>
  TrimMultiCharacterCharacterStringContext* trimMultiCharacterCharacterString(ContextT* ctx) {
    TrimMultiCharacterCharacterStringContext *_localctx = _tracker.createInstance<TrimMultiCharacterCharacterStringContext>(_ctx, getState());
    enterRule(_localctx, 832, GQLParser::RuleTrimMultiCharacterCharacterString);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3901);
      _la = _input->LA(1);
      if (!(_la == GQLParser::BTRIM || _la == GQLParser::LTRIM

      || _la == GQLParser::RTRIM)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(3902);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3903);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(3906);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::COMMA) {
        setState(3904);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(3905);
        {
          auto childCtxHolder = ctx->EnterValueExpression();
          valueExpression(0, get_raw_pointer(childCtxHolder));
        }
      }
      setState(3908);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NormalizeCharacterStringContext : public antlr4::ParserRuleContext {
  public:
    NormalizeCharacterStringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NORMALIZE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ValueExpressionContext *valueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *COMMA();
    NormalFormContext *normalForm();

   
  };

  template<typename ContextT>
  NormalizeCharacterStringContext* normalizeCharacterString(ContextT* ctx) {
    NormalizeCharacterStringContext *_localctx = _tracker.createInstance<NormalizeCharacterStringContext>(_ctx, getState());
    enterRule(_localctx, 834, GQLParser::RuleNormalizeCharacterString);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3910);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NORMALIZE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NORMALIZE);
      setState(3911);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3912);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(3915);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::COMMA) {
        setState(3913);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(3914);
        {
          auto childCtxHolder = ctx->EnterNormalForm();
          normalForm(get_raw_pointer(childCtxHolder));
        }
      }
      setState(3917);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NodeReferenceValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    NodeReferenceValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionPrimaryContext *valueExpressionPrimary();

   
  };

  template<typename ContextT>
  NodeReferenceValueExpressionContext* nodeReferenceValueExpression(ContextT* ctx) {
    NodeReferenceValueExpressionContext *_localctx = _tracker.createInstance<NodeReferenceValueExpressionContext>(_ctx, getState());
    enterRule(_localctx, 836, GQLParser::RuleNodeReferenceValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3919);
      {
        auto childCtxHolder = ctx->EnterValueExpressionPrimary();
        valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeReferenceValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    EdgeReferenceValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionPrimaryContext *valueExpressionPrimary();

   
  };

  template<typename ContextT>
  EdgeReferenceValueExpressionContext* edgeReferenceValueExpression(ContextT* ctx) {
    EdgeReferenceValueExpressionContext *_localctx = _tracker.createInstance<EdgeReferenceValueExpressionContext>(_ctx, getState());
    enterRule(_localctx, 838, GQLParser::RuleEdgeReferenceValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3921);
      {
        auto childCtxHolder = ctx->EnterValueExpressionPrimary();
        valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  AggregatingValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    AggregatingValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  AggregatingValueExpressionContext* aggregatingValueExpression(ContextT* ctx) {
    AggregatingValueExpressionContext *_localctx = _tracker.createInstance<AggregatingValueExpressionContext>(_ctx, getState());
    enterRule(_localctx, 840, GQLParser::RuleAggregatingValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3923);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ValueExpressionPrimaryContext : public antlr4::ParserRuleContext {
  public:
    ValueExpressionPrimaryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ParenthesizedValueExpressionContext *parenthesizedValueExpression();
    AggregateFunctionContext *aggregateFunction();
    UnsignedValueSpecificationContext *unsignedValueSpecification();
    PathValueConstructorContext *pathValueConstructor();
    ValueQueryExpressionContext *valueQueryExpression();
    CaseExpressionContext *caseExpression();
    CastSpecificationContext *castSpecification();
    Element_idFunctionContext *element_idFunction();
    LetValueExpressionContext *letValueExpression();
    BindingVariableReferenceContext *bindingVariableReference();
    ValueExpressionPrimaryContext *valueExpressionPrimary();
    antlr4::tree::TerminalNode *PERIOD();
    PropertyNameContext *propertyName();

   
  };


  template<typename ContextT>
  ValueExpressionPrimaryContext* valueExpressionPrimary(ContextT* ctx) {
     return valueExpressionPrimary(0, ctx);
  }

  template<typename ContextT>
  ValueExpressionPrimaryContext* valueExpressionPrimary(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    GQLParser::ValueExpressionPrimaryContext *_localctx = _tracker.createInstance<ValueExpressionPrimaryContext>(_ctx, parentState);
    GQLParser::ValueExpressionPrimaryContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 842;
    enterRecursionRule(_localctx, 842, GQLParser::RuleValueExpressionPrimary, precedence);

      

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(3936);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LEFT_PAREN: {
          setState(3926);
          {
            auto childCtxHolder = ctx->EnterParenthesizedValueExpression();
            parenthesizedValueExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::AVG:
        case GQLParser::COLLECT_LIST:
        case GQLParser::COUNT:
        case GQLParser::MAX:
        case GQLParser::MIN:
        case GQLParser::PERCENTILE_CONT:
        case GQLParser::PERCENTILE_DISC:
        case GQLParser::STDDEV_POP:
        case GQLParser::STDDEV_SAMP:
        case GQLParser::SUM: {
          setState(3927);
          {
            auto childCtxHolder = ctx->EnterAggregateFunction();
            aggregateFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BOOLEAN_LITERAL:
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::BYTE_STRING_LITERAL:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER:
        case GQLParser::ARRAY:
        case GQLParser::DATE:
        case GQLParser::DATETIME:
        case GQLParser::DURATION:
        case GQLParser::GROUP:
        case GQLParser::LIST:
        case GQLParser::NULL_KW:
        case GQLParser::RECORD:
        case GQLParser::SESSION_USER:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::GENERAL_PARAMETER_REFERENCE:
        case GQLParser::LEFT_BRACE:
        case GQLParser::LEFT_BRACKET: {
          setState(3928);
          {
            auto childCtxHolder = ctx->EnterUnsignedValueSpecification();
            unsignedValueSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::PATH: {
          setState(3929);
          {
            auto childCtxHolder = ctx->EnterPathValueConstructor();
            pathValueConstructor(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::VALUE: {
          setState(3930);
          {
            auto childCtxHolder = ctx->EnterValueQueryExpression();
            valueQueryExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CASE:
        case GQLParser::COALESCE:
        case GQLParser::NULLIF: {
          setState(3931);
          {
            auto childCtxHolder = ctx->EnterCaseExpression();
            caseExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CAST: {
          setState(3932);
          {
            auto childCtxHolder = ctx->EnterCastSpecification();
            castSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ELEMENT_ID: {
          setState(3933);
          {
            auto childCtxHolder = ctx->EnterElement_idFunction();
            element_idFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LET: {
          setState(3934);
          {
            auto childCtxHolder = ctx->EnterLetValueExpression();
            letValueExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          setState(3935);
          {
            auto childCtxHolder = ctx->EnterBindingVariableReference();
            bindingVariableReference(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
      _ctx->stop = _input->LT(-1);
      setState(3943);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 446, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          _localctx = _tracker.createInstance<ValueExpressionPrimaryContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleValueExpressionPrimary);
          ctx->PushValueExpressionPrimary();
          setState(3938);

          if (!(precpred(_ctx, 7))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(3939);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::PERIOD) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::PERIOD);
          setState(3940);
          {
            auto childCtxHolder = ctx->EnterPropertyName();
            propertyName(get_raw_pointer(childCtxHolder));
          } 
        }
        setState(3945);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 446, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }

  class  ParenthesizedValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    ParenthesizedValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ValueExpressionContext *valueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  ParenthesizedValueExpressionContext* parenthesizedValueExpression(ContextT* ctx) {
    ParenthesizedValueExpressionContext *_localctx = _tracker.createInstance<ParenthesizedValueExpressionContext>(_ctx, getState());
    enterRule(_localctx, 844, GQLParser::RuleParenthesizedValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3946);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(3947);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(3948);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NonParenthesizedValueExpressionPrimaryContext : public antlr4::ParserRuleContext {
  public:
    NonParenthesizedValueExpressionPrimaryContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NonParenthesizedValueExpressionPrimarySpecialCaseContext *nonParenthesizedValueExpressionPrimarySpecialCase();
    BindingVariableReferenceContext *bindingVariableReference();

   
  };

  template<typename ContextT>
  NonParenthesizedValueExpressionPrimaryContext* nonParenthesizedValueExpressionPrimary(ContextT* ctx) {
    NonParenthesizedValueExpressionPrimaryContext *_localctx = _tracker.createInstance<NonParenthesizedValueExpressionPrimaryContext>(_ctx, getState());
    enterRule(_localctx, 846, GQLParser::RuleNonParenthesizedValueExpressionPrimary);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3952);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 447, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3950);
        {
          auto childCtxHolder = ctx->EnterNonParenthesizedValueExpressionPrimarySpecialCase();
          nonParenthesizedValueExpressionPrimarySpecialCase(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3951);
        {
          auto childCtxHolder = ctx->EnterBindingVariableReference();
          bindingVariableReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NonParenthesizedValueExpressionPrimarySpecialCaseContext : public antlr4::ParserRuleContext {
  public:
    NonParenthesizedValueExpressionPrimarySpecialCaseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    AggregateFunctionContext *aggregateFunction();
    UnsignedValueSpecificationContext *unsignedValueSpecification();
    PathValueConstructorContext *pathValueConstructor();
    ValueExpressionPrimaryContext *valueExpressionPrimary();
    antlr4::tree::TerminalNode *PERIOD();
    PropertyNameContext *propertyName();
    ValueQueryExpressionContext *valueQueryExpression();
    CaseExpressionContext *caseExpression();
    CastSpecificationContext *castSpecification();
    Element_idFunctionContext *element_idFunction();
    LetValueExpressionContext *letValueExpression();

   
  };

  template<typename ContextT>
  NonParenthesizedValueExpressionPrimarySpecialCaseContext* nonParenthesizedValueExpressionPrimarySpecialCase(ContextT* ctx) {
    NonParenthesizedValueExpressionPrimarySpecialCaseContext *_localctx = _tracker.createInstance<NonParenthesizedValueExpressionPrimarySpecialCaseContext>(_ctx, getState());
    enterRule(_localctx, 848, GQLParser::RuleNonParenthesizedValueExpressionPrimarySpecialCase);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3966);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 448, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3954);
        {
          auto childCtxHolder = ctx->EnterAggregateFunction();
          aggregateFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3955);
        {
          auto childCtxHolder = ctx->EnterUnsignedValueSpecification();
          unsignedValueSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3956);
        {
          auto childCtxHolder = ctx->EnterPathValueConstructor();
          pathValueConstructor(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(3957);
        {
          auto childCtxHolder = ctx->EnterValueExpressionPrimary();
          valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
        }
        setState(3958);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::PERIOD) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::PERIOD);
        setState(3959);
        {
          auto childCtxHolder = ctx->EnterPropertyName();
          propertyName(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(3961);
        {
          auto childCtxHolder = ctx->EnterValueQueryExpression();
          valueQueryExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(3962);
        {
          auto childCtxHolder = ctx->EnterCaseExpression();
          caseExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(3963);
        {
          auto childCtxHolder = ctx->EnterCastSpecification();
          castSpecification(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(3964);
        {
          auto childCtxHolder = ctx->EnterElement_idFunction();
          element_idFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(3965);
        {
          auto childCtxHolder = ctx->EnterLetValueExpression();
          letValueExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  UnsignedValueSpecificationContext : public antlr4::ParserRuleContext {
  public:
    UnsignedValueSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UnsignedLiteralContext *unsignedLiteral();
    GeneralValueSpecificationContext *generalValueSpecification();

   
  };

  template<typename ContextT>
  UnsignedValueSpecificationContext* unsignedValueSpecification(ContextT* ctx) {
    UnsignedValueSpecificationContext *_localctx = _tracker.createInstance<UnsignedValueSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 850, GQLParser::RuleUnsignedValueSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3970);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BOOLEAN_LITERAL:
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::BYTE_STRING_LITERAL:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER:
        case GQLParser::ARRAY:
        case GQLParser::DATE:
        case GQLParser::DATETIME:
        case GQLParser::DURATION:
        case GQLParser::GROUP:
        case GQLParser::LIST:
        case GQLParser::NULL_KW:
        case GQLParser::RECORD:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::LEFT_BRACE:
        case GQLParser::LEFT_BRACKET: {
          enterOuterAlt(_localctx, 1);
          setState(3968);
          {
            auto childCtxHolder = ctx->EnterUnsignedLiteral();
            unsignedLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::SESSION_USER:
        case GQLParser::GENERAL_PARAMETER_REFERENCE: {
          enterOuterAlt(_localctx, 2);
          setState(3969);
          {
            auto childCtxHolder = ctx->EnterGeneralValueSpecification();
            generalValueSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NonNegativeIntegerSpecificationContext : public antlr4::ParserRuleContext {
  public:
    NonNegativeIntegerSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UnsignedIntegerContext *unsignedInteger();
    DynamicParameterSpecificationContext *dynamicParameterSpecification();

   
  };

  template<typename ContextT>
  NonNegativeIntegerSpecificationContext* nonNegativeIntegerSpecification(ContextT* ctx) {
    NonNegativeIntegerSpecificationContext *_localctx = _tracker.createInstance<NonNegativeIntegerSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 852, GQLParser::RuleNonNegativeIntegerSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3974);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER: {
          enterOuterAlt(_localctx, 1);
          setState(3972);
          {
            auto childCtxHolder = ctx->EnterUnsignedInteger();
            unsignedInteger(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::GENERAL_PARAMETER_REFERENCE: {
          enterOuterAlt(_localctx, 2);
          setState(3973);
          {
            auto childCtxHolder = ctx->EnterDynamicParameterSpecification();
            dynamicParameterSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GeneralValueSpecificationContext : public antlr4::ParserRuleContext {
  public:
    GeneralValueSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DynamicParameterSpecificationContext *dynamicParameterSpecification();
    antlr4::tree::TerminalNode *SESSION_USER();

   
  };

  template<typename ContextT>
  GeneralValueSpecificationContext* generalValueSpecification(ContextT* ctx) {
    GeneralValueSpecificationContext *_localctx = _tracker.createInstance<GeneralValueSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 854, GQLParser::RuleGeneralValueSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3978);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::GENERAL_PARAMETER_REFERENCE: {
          enterOuterAlt(_localctx, 1);
          setState(3976);
          {
            auto childCtxHolder = ctx->EnterDynamicParameterSpecification();
            dynamicParameterSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::SESSION_USER: {
          enterOuterAlt(_localctx, 2);
          setState(3977);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::SESSION_USER) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::SESSION_USER);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DynamicParameterSpecificationContext : public antlr4::ParserRuleContext {
  public:
    DynamicParameterSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *GENERAL_PARAMETER_REFERENCE();

   
  };

  template<typename ContextT>
  DynamicParameterSpecificationContext* dynamicParameterSpecification(ContextT* ctx) {
    DynamicParameterSpecificationContext *_localctx = _tracker.createInstance<DynamicParameterSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 856, GQLParser::RuleDynamicParameterSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3980);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::GENERAL_PARAMETER_REFERENCE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::GENERAL_PARAMETER_REFERENCE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LetValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    LetValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LET();
    LetVariableDefinitionListContext *letVariableDefinitionList();
    antlr4::tree::TerminalNode *IN();
    ValueExpressionContext *valueExpression();
    antlr4::tree::TerminalNode *END();

   
  };

  template<typename ContextT>
  LetValueExpressionContext* letValueExpression(ContextT* ctx) {
    LetValueExpressionContext *_localctx = _tracker.createInstance<LetValueExpressionContext>(_ctx, getState());
    enterRule(_localctx, 858, GQLParser::RuleLetValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3982);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LET);
      setState(3983);
      {
        auto childCtxHolder = ctx->EnterLetVariableDefinitionList();
        letVariableDefinitionList(get_raw_pointer(childCtxHolder));
      }
      setState(3984);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::IN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::IN);
      setState(3985);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(3986);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::END) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::END);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ValueQueryExpressionContext : public antlr4::ParserRuleContext {
  public:
    ValueQueryExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *VALUE();
    NestedQuerySpecificationContext *nestedQuerySpecification();

   
  };

  template<typename ContextT>
  ValueQueryExpressionContext* valueQueryExpression(ContextT* ctx) {
    ValueQueryExpressionContext *_localctx = _tracker.createInstance<ValueQueryExpressionContext>(_ctx, getState());
    enterRule(_localctx, 860, GQLParser::RuleValueQueryExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(3988);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::VALUE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::VALUE);
      setState(3989);
      {
        auto childCtxHolder = ctx->EnterNestedQuerySpecification();
        nestedQuerySpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CaseExpressionContext : public antlr4::ParserRuleContext {
  public:
    CaseExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CaseAbbreviationContext *caseAbbreviation();
    CaseSpecificationContext *caseSpecification();

   
  };

  template<typename ContextT>
  CaseExpressionContext* caseExpression(ContextT* ctx) {
    CaseExpressionContext *_localctx = _tracker.createInstance<CaseExpressionContext>(_ctx, getState());
    enterRule(_localctx, 862, GQLParser::RuleCaseExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(3993);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::COALESCE:
        case GQLParser::NULLIF: {
          enterOuterAlt(_localctx, 1);
          setState(3991);
          {
            auto childCtxHolder = ctx->EnterCaseAbbreviation();
            caseAbbreviation(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CASE: {
          enterOuterAlt(_localctx, 2);
          setState(3992);
          {
            auto childCtxHolder = ctx->EnterCaseSpecification();
            caseSpecification(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CaseAbbreviationContext : public antlr4::ParserRuleContext {
  public:
    CaseAbbreviationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
   
    CaseAbbreviationContext() = default;
    void copyFrom(CaseAbbreviationContext *context);
    using antlr4::ParserRuleContext::copyFrom;

    virtual size_t getRuleIndex() const override;

   
  };

  class  NullIfExprAltContext : public CaseAbbreviationContext {
  public:
    NullIfExprAltContext(CaseAbbreviationContext *ctx);

    antlr4::tree::TerminalNode *NULLIF();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ValueExpressionContext *> valueExpression();
    ValueExpressionContext* valueExpression(size_t i);
    antlr4::tree::TerminalNode *COMMA();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
  };

  class  CoalesceExprAltContext : public CaseAbbreviationContext {
  public:
    CoalesceExprAltContext(CaseAbbreviationContext *ctx);

    antlr4::tree::TerminalNode *COALESCE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    std::vector<ValueExpressionContext *> valueExpression();
    ValueExpressionContext* valueExpression(size_t i);
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
  };

  template<typename ContextT>
  CaseAbbreviationContext* caseAbbreviation(ContextT* ctx) {
    CaseAbbreviationContext *_localctx = _tracker.createInstance<CaseAbbreviationContext>(_ctx, getState());
    enterRule(_localctx, 864, GQLParser::RuleCaseAbbreviation);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4013);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::NULLIF: {
          _localctx = _tracker.createInstance<GQLParser::NullIfExprAltContext>(_localctx);
          auto ctxHolder = ctx->EnterNullIfExprAlt();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          enterOuterAlt(_localctx, 1);
          setState(3995);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::NULLIF) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::NULLIF);
          setState(3996);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(3997);
          {
            auto childCtxHolder = ctx->EnterValueExpression();
            valueExpression(0, get_raw_pointer(childCtxHolder));
          }
          setState(3998);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COMMA) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COMMA);
          setState(3999);
          {
            auto childCtxHolder = ctx->EnterValueExpression();
            valueExpression(0, get_raw_pointer(childCtxHolder));
          }
          setState(4000);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

        case GQLParser::COALESCE: {
          _localctx = _tracker.createInstance<GQLParser::CoalesceExprAltContext>(_localctx);
          auto ctxHolder = ctx->EnterCoalesceExprAlt();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          enterOuterAlt(_localctx, 2);
          setState(4002);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::COALESCE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::COALESCE);
          setState(4003);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(4004);
          {
            auto childCtxHolder = ctx->EnterValueExpression();
            valueExpression(0, get_raw_pointer(childCtxHolder));
          }
          setState(4007); 
          _errHandler->sync(this);
          _la = _input->LA(1);
          do {
            setState(4005);
            if constexpr (has_OnToken<decltype(ctx)>::value) {
              if (_input->LA(1) == GQLParser::COMMA) {
                ctx->OnToken(_input->LT(1));
              }
            }
            match(GQLParser::COMMA);
            setState(4006);
            {
              auto childCtxHolder = ctx->EnterValueExpression();
              valueExpression(0, get_raw_pointer(childCtxHolder));
            }
            setState(4009); 
            _errHandler->sync(this);
            _la = _input->LA(1);
          } while (_la == GQLParser::COMMA);
          setState(4011);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CaseSpecificationContext : public antlr4::ParserRuleContext {
  public:
    CaseSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    SimpleCaseContext *simpleCase();
    SearchedCaseContext *searchedCase();

   
  };

  template<typename ContextT>
  CaseSpecificationContext* caseSpecification(ContextT* ctx) {
    CaseSpecificationContext *_localctx = _tracker.createInstance<CaseSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 866, GQLParser::RuleCaseSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4017);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 455, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4015);
        {
          auto childCtxHolder = ctx->EnterSimpleCase();
          simpleCase(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4016);
        {
          auto childCtxHolder = ctx->EnterSearchedCase();
          searchedCase(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimpleCaseContext : public antlr4::ParserRuleContext {
  public:
    SimpleCaseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CASE();
    CaseOperandContext *caseOperand();
    antlr4::tree::TerminalNode *END();
    std::vector<SimpleWhenClauseContext *> simpleWhenClause();
    SimpleWhenClauseContext* simpleWhenClause(size_t i);
    ElseClauseContext *elseClause();

   
  };

  template<typename ContextT>
  SimpleCaseContext* simpleCase(ContextT* ctx) {
    SimpleCaseContext *_localctx = _tracker.createInstance<SimpleCaseContext>(_ctx, getState());
    enterRule(_localctx, 868, GQLParser::RuleSimpleCase);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4019);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CASE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CASE);
      setState(4020);
      {
        auto childCtxHolder = ctx->EnterCaseOperand();
        caseOperand(get_raw_pointer(childCtxHolder));
      }
      setState(4022); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(4021);
        {
          auto childCtxHolder = ctx->EnterSimpleWhenClause();
          simpleWhenClause(get_raw_pointer(childCtxHolder));
        }
        setState(4024); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == GQLParser::WHEN);
      setState(4027);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ELSE) {
        setState(4026);
        {
          auto childCtxHolder = ctx->EnterElseClause();
          elseClause(get_raw_pointer(childCtxHolder));
        }
      }
      setState(4029);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::END) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::END);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SearchedCaseContext : public antlr4::ParserRuleContext {
  public:
    SearchedCaseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CASE();
    antlr4::tree::TerminalNode *END();
    std::vector<SearchedWhenClauseContext *> searchedWhenClause();
    SearchedWhenClauseContext* searchedWhenClause(size_t i);
    ElseClauseContext *elseClause();

   
  };

  template<typename ContextT>
  SearchedCaseContext* searchedCase(ContextT* ctx) {
    SearchedCaseContext *_localctx = _tracker.createInstance<SearchedCaseContext>(_ctx, getState());
    enterRule(_localctx, 870, GQLParser::RuleSearchedCase);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4031);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CASE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CASE);
      setState(4033); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(4032);
        {
          auto childCtxHolder = ctx->EnterSearchedWhenClause();
          searchedWhenClause(get_raw_pointer(childCtxHolder));
        }
        setState(4035); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == GQLParser::WHEN);
      setState(4038);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ELSE) {
        setState(4037);
        {
          auto childCtxHolder = ctx->EnterElseClause();
          elseClause(get_raw_pointer(childCtxHolder));
        }
      }
      setState(4040);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::END) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::END);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SimpleWhenClauseContext : public antlr4::ParserRuleContext {
  public:
    SimpleWhenClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    WhenOperandListContext *whenOperandList();
    antlr4::tree::TerminalNode *THEN();
    ResultContext *result();

   
  };

  template<typename ContextT>
  SimpleWhenClauseContext* simpleWhenClause(ContextT* ctx) {
    SimpleWhenClauseContext *_localctx = _tracker.createInstance<SimpleWhenClauseContext>(_ctx, getState());
    enterRule(_localctx, 872, GQLParser::RuleSimpleWhenClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4042);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::WHEN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::WHEN);
      setState(4043);
      {
        auto childCtxHolder = ctx->EnterWhenOperandList();
        whenOperandList(get_raw_pointer(childCtxHolder));
      }
      setState(4044);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::THEN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::THEN);
      setState(4045);
      {
        auto childCtxHolder = ctx->EnterResult();
        result(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SearchedWhenClauseContext : public antlr4::ParserRuleContext {
  public:
    SearchedWhenClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *WHEN();
    SearchConditionContext *searchCondition();
    antlr4::tree::TerminalNode *THEN();
    ResultContext *result();

   
  };

  template<typename ContextT>
  SearchedWhenClauseContext* searchedWhenClause(ContextT* ctx) {
    SearchedWhenClauseContext *_localctx = _tracker.createInstance<SearchedWhenClauseContext>(_ctx, getState());
    enterRule(_localctx, 874, GQLParser::RuleSearchedWhenClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4047);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::WHEN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::WHEN);
      setState(4048);
      {
        auto childCtxHolder = ctx->EnterSearchCondition();
        searchCondition(get_raw_pointer(childCtxHolder));
      }
      setState(4049);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::THEN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::THEN);
      setState(4050);
      {
        auto childCtxHolder = ctx->EnterResult();
        result(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ElseClauseContext : public antlr4::ParserRuleContext {
  public:
    ElseClauseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELSE();
    ResultContext *result();

   
  };

  template<typename ContextT>
  ElseClauseContext* elseClause(ContextT* ctx) {
    ElseClauseContext *_localctx = _tracker.createInstance<ElseClauseContext>(_ctx, getState());
    enterRule(_localctx, 876, GQLParser::RuleElseClause);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4052);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ELSE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ELSE);
      setState(4053);
      {
        auto childCtxHolder = ctx->EnterResult();
        result(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CaseOperandContext : public antlr4::ParserRuleContext {
  public:
    CaseOperandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NonParenthesizedValueExpressionPrimaryContext *nonParenthesizedValueExpressionPrimary();
    ElementVariableReferenceContext *elementVariableReference();

   
  };

  template<typename ContextT>
  CaseOperandContext* caseOperand(ContextT* ctx) {
    CaseOperandContext *_localctx = _tracker.createInstance<CaseOperandContext>(_ctx, getState());
    enterRule(_localctx, 878, GQLParser::RuleCaseOperand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4057);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 460, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4055);
        {
          auto childCtxHolder = ctx->EnterNonParenthesizedValueExpressionPrimary();
          nonParenthesizedValueExpressionPrimary(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4056);
        {
          auto childCtxHolder = ctx->EnterElementVariableReference();
          elementVariableReference(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  WhenOperandListContext : public antlr4::ParserRuleContext {
  public:
    WhenOperandListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<WhenOperandContext *> whenOperand();
    WhenOperandContext* whenOperand(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  WhenOperandListContext* whenOperandList(ContextT* ctx) {
    WhenOperandListContext *_localctx = _tracker.createInstance<WhenOperandListContext>(_ctx, getState());
    enterRule(_localctx, 880, GQLParser::RuleWhenOperandList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4059);
      {
        auto childCtxHolder = ctx->EnterWhenOperand();
        whenOperand(get_raw_pointer(childCtxHolder));
      }
      setState(4064);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(4060);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(4061);
        {
          auto childCtxHolder = ctx->EnterWhenOperand();
          whenOperand(get_raw_pointer(childCtxHolder));
        }
        setState(4066);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  WhenOperandContext : public antlr4::ParserRuleContext {
  public:
    WhenOperandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NonParenthesizedValueExpressionPrimaryContext *nonParenthesizedValueExpressionPrimary();
    CompOpContext *compOp();
    ValueExpressionContext *valueExpression();
    NullPredicatePart2Context *nullPredicatePart2();
    ValueTypePredicatePart2Context *valueTypePredicatePart2();
    NormalizedPredicatePart2Context *normalizedPredicatePart2();
    DirectedPredicatePart2Context *directedPredicatePart2();
    LabeledPredicatePart2Context *labeledPredicatePart2();
    SourcePredicatePart2Context *sourcePredicatePart2();
    DestinationPredicatePart2Context *destinationPredicatePart2();

   
  };

  template<typename ContextT>
  WhenOperandContext* whenOperand(ContextT* ctx) {
    WhenOperandContext *_localctx = _tracker.createInstance<WhenOperandContext>(_ctx, getState());
    enterRule(_localctx, 882, GQLParser::RuleWhenOperand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4078);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 462, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4067);
        {
          auto childCtxHolder = ctx->EnterNonParenthesizedValueExpressionPrimary();
          nonParenthesizedValueExpressionPrimary(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4068);
        {
          auto childCtxHolder = ctx->EnterCompOp();
          compOp(get_raw_pointer(childCtxHolder));
        }
        setState(4069);
        {
          auto childCtxHolder = ctx->EnterValueExpression();
          valueExpression(0, get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(4071);
        {
          auto childCtxHolder = ctx->EnterNullPredicatePart2();
          nullPredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(4072);
        {
          auto childCtxHolder = ctx->EnterValueTypePredicatePart2();
          valueTypePredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(4073);
        {
          auto childCtxHolder = ctx->EnterNormalizedPredicatePart2();
          normalizedPredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(4074);
        {
          auto childCtxHolder = ctx->EnterDirectedPredicatePart2();
          directedPredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(4075);
        {
          auto childCtxHolder = ctx->EnterLabeledPredicatePart2();
          labeledPredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(4076);
        {
          auto childCtxHolder = ctx->EnterSourcePredicatePart2();
          sourcePredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(4077);
        {
          auto childCtxHolder = ctx->EnterDestinationPredicatePart2();
          destinationPredicatePart2(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ResultContext : public antlr4::ParserRuleContext {
  public:
    ResultContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ResultExpressionContext *resultExpression();
    NullLiteralContext *nullLiteral();

   
  };

  template<typename ContextT>
  ResultContext* result(ContextT* ctx) {
    ResultContext *_localctx = _tracker.createInstance<ResultContext>(_ctx, getState());
    enterRule(_localctx, 884, GQLParser::RuleResult);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4082);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 463, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4080);
        {
          auto childCtxHolder = ctx->EnterResultExpression();
          resultExpression(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4081);
        {
          auto childCtxHolder = ctx->EnterNullLiteral();
          nullLiteral(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ResultExpressionContext : public antlr4::ParserRuleContext {
  public:
    ResultExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  ResultExpressionContext* resultExpression(ContextT* ctx) {
    ResultExpressionContext *_localctx = _tracker.createInstance<ResultExpressionContext>(_ctx, getState());
    enterRule(_localctx, 886, GQLParser::RuleResultExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4084);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CastSpecificationContext : public antlr4::ParserRuleContext {
  public:
    CastSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CAST();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    CastOperandContext *castOperand();
    antlr4::tree::TerminalNode *AS();
    CastTargetContext *castTarget();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  CastSpecificationContext* castSpecification(ContextT* ctx) {
    CastSpecificationContext *_localctx = _tracker.createInstance<CastSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 888, GQLParser::RuleCastSpecification);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4086);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::CAST) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::CAST);
      setState(4087);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4088);
      {
        auto childCtxHolder = ctx->EnterCastOperand();
        castOperand(get_raw_pointer(childCtxHolder));
      }
      setState(4089);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::AS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::AS);
      setState(4090);
      {
        auto childCtxHolder = ctx->EnterCastTarget();
        castTarget(get_raw_pointer(childCtxHolder));
      }
      setState(4091);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CastOperandContext : public antlr4::ParserRuleContext {
  public:
    CastOperandContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();
    NullLiteralContext *nullLiteral();

   
  };

  template<typename ContextT>
  CastOperandContext* castOperand(ContextT* ctx) {
    CastOperandContext *_localctx = _tracker.createInstance<CastOperandContext>(_ctx, getState());
    enterRule(_localctx, 890, GQLParser::RuleCastOperand);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4095);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 464, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4093);
        {
          auto childCtxHolder = ctx->EnterValueExpression();
          valueExpression(0, get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4094);
        {
          auto childCtxHolder = ctx->EnterNullLiteral();
          nullLiteral(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CastTargetContext : public antlr4::ParserRuleContext {
  public:
    CastTargetContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueTypeContext *valueType();

   
  };

  template<typename ContextT>
  CastTargetContext* castTarget(ContextT* ctx) {
    CastTargetContext *_localctx = _tracker.createInstance<CastTargetContext>(_ctx, getState());
    enterRule(_localctx, 892, GQLParser::RuleCastTarget);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4097);
      {
        auto childCtxHolder = ctx->EnterValueType();
        valueType(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  AggregateFunctionContext : public antlr4::ParserRuleContext {
  public:
    AggregateFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *COUNT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *ASTERISK();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    GeneralSetFunctionContext *generalSetFunction();
    BinarySetFunctionContext *binarySetFunction();

   
  };

  template<typename ContextT>
  AggregateFunctionContext* aggregateFunction(ContextT* ctx) {
    AggregateFunctionContext *_localctx = _tracker.createInstance<AggregateFunctionContext>(_ctx, getState());
    enterRule(_localctx, 894, GQLParser::RuleAggregateFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4105);
      _errHandler->sync(this);
      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 465, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4099);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COUNT) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COUNT);
        setState(4100);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(4101);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::ASTERISK) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::ASTERISK);
        setState(4102);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4103);
        {
          auto childCtxHolder = ctx->EnterGeneralSetFunction();
          generalSetFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(4104);
        {
          auto childCtxHolder = ctx->EnterBinarySetFunction();
          binarySetFunction(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GeneralSetFunctionContext : public antlr4::ParserRuleContext {
  public:
    GeneralSetFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    GeneralSetFunctionTypeContext *generalSetFunctionType();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ValueExpressionContext *valueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    SetQuantifierContext *setQuantifier();

   
  };

  template<typename ContextT>
  GeneralSetFunctionContext* generalSetFunction(ContextT* ctx) {
    GeneralSetFunctionContext *_localctx = _tracker.createInstance<GeneralSetFunctionContext>(_ctx, getState());
    enterRule(_localctx, 896, GQLParser::RuleGeneralSetFunction);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4107);
      {
        auto childCtxHolder = ctx->EnterGeneralSetFunctionType();
        generalSetFunctionType(get_raw_pointer(childCtxHolder));
      }
      setState(4108);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4110);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ALL

      || _la == GQLParser::DISTINCT) {
        setState(4109);
        {
          auto childCtxHolder = ctx->EnterSetQuantifier();
          setQuantifier(get_raw_pointer(childCtxHolder));
        }
      }
      setState(4112);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4113);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BinarySetFunctionContext : public antlr4::ParserRuleContext {
  public:
    BinarySetFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BinarySetFunctionTypeContext *binarySetFunctionType();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    DependentValueExpressionContext *dependentValueExpression();
    antlr4::tree::TerminalNode *COMMA();
    IndependentValueExpressionContext *independentValueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  BinarySetFunctionContext* binarySetFunction(ContextT* ctx) {
    BinarySetFunctionContext *_localctx = _tracker.createInstance<BinarySetFunctionContext>(_ctx, getState());
    enterRule(_localctx, 898, GQLParser::RuleBinarySetFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4115);
      {
        auto childCtxHolder = ctx->EnterBinarySetFunctionType();
        binarySetFunctionType(get_raw_pointer(childCtxHolder));
      }
      setState(4116);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4117);
      {
        auto childCtxHolder = ctx->EnterDependentValueExpression();
        dependentValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4118);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4119);
      {
        auto childCtxHolder = ctx->EnterIndependentValueExpression();
        independentValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4120);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GeneralSetFunctionTypeContext : public antlr4::ParserRuleContext {
  public:
    GeneralSetFunctionTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *AVG();
    antlr4::tree::TerminalNode *COUNT();
    antlr4::tree::TerminalNode *MAX();
    antlr4::tree::TerminalNode *MIN();
    antlr4::tree::TerminalNode *SUM();
    antlr4::tree::TerminalNode *COLLECT_LIST();
    antlr4::tree::TerminalNode *STDDEV_SAMP();
    antlr4::tree::TerminalNode *STDDEV_POP();

   
  };

  template<typename ContextT>
  GeneralSetFunctionTypeContext* generalSetFunctionType(ContextT* ctx) {
    GeneralSetFunctionTypeContext *_localctx = _tracker.createInstance<GeneralSetFunctionTypeContext>(_ctx, getState());
    enterRule(_localctx, 900, GQLParser::RuleGeneralSetFunctionType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4122);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 4683743621055250432) != 0) || ((((_la - 144) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 144)) & 792633534417207299) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SetQuantifierContext : public antlr4::ParserRuleContext {
  public:
    SetQuantifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DISTINCT();
    antlr4::tree::TerminalNode *ALL();

   
  };

  template<typename ContextT>
  SetQuantifierContext* setQuantifier(ContextT* ctx) {
    SetQuantifierContext *_localctx = _tracker.createInstance<SetQuantifierContext>(_ctx, getState());
    enterRule(_localctx, 902, GQLParser::RuleSetQuantifier);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4124);
      _la = _input->LA(1);
      if (!(_la == GQLParser::ALL

      || _la == GQLParser::DISTINCT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BinarySetFunctionTypeContext : public antlr4::ParserRuleContext {
  public:
    BinarySetFunctionTypeContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PERCENTILE_CONT();
    antlr4::tree::TerminalNode *PERCENTILE_DISC();

   
  };

  template<typename ContextT>
  BinarySetFunctionTypeContext* binarySetFunctionType(ContextT* ctx) {
    BinarySetFunctionTypeContext *_localctx = _tracker.createInstance<BinarySetFunctionTypeContext>(_ctx, getState());
    enterRule(_localctx, 904, GQLParser::RuleBinarySetFunctionType);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4126);
      _la = _input->LA(1);
      if (!(_la == GQLParser::PERCENTILE_CONT

      || _la == GQLParser::PERCENTILE_DISC)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DependentValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    DependentValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NumericValueExpressionContext *numericValueExpression();
    SetQuantifierContext *setQuantifier();

   
  };

  template<typename ContextT>
  DependentValueExpressionContext* dependentValueExpression(ContextT* ctx) {
    DependentValueExpressionContext *_localctx = _tracker.createInstance<DependentValueExpressionContext>(_ctx, getState());
    enterRule(_localctx, 906, GQLParser::RuleDependentValueExpression);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4129);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ALL

      || _la == GQLParser::DISTINCT) {
        setState(4128);
        {
          auto childCtxHolder = ctx->EnterSetQuantifier();
          setQuantifier(get_raw_pointer(childCtxHolder));
        }
      }
      setState(4131);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  IndependentValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    IndependentValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NumericValueExpressionContext *numericValueExpression();

   
  };

  template<typename ContextT>
  IndependentValueExpressionContext* independentValueExpression(ContextT* ctx) {
    IndependentValueExpressionContext *_localctx = _tracker.createInstance<IndependentValueExpressionContext>(_ctx, getState());
    enterRule(_localctx, 908, GQLParser::RuleIndependentValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4133);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  Element_idFunctionContext : public antlr4::ParserRuleContext {
  public:
    Element_idFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELEMENT_ID();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ElementVariableReferenceContext *elementVariableReference();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  Element_idFunctionContext* element_idFunction(ContextT* ctx) {
    Element_idFunctionContext *_localctx = _tracker.createInstance<Element_idFunctionContext>(_ctx, getState());
    enterRule(_localctx, 910, GQLParser::RuleElement_idFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4135);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ELEMENT_ID) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ELEMENT_ID);
      setState(4136);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4137);
      {
        auto childCtxHolder = ctx->EnterElementVariableReference();
        elementVariableReference(get_raw_pointer(childCtxHolder));
      }
      setState(4138);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BindingVariableReferenceContext : public antlr4::ParserRuleContext {
  public:
    BindingVariableReferenceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BindingVariableContext *bindingVariable();

   
  };

  template<typename ContextT>
  BindingVariableReferenceContext* bindingVariableReference(ContextT* ctx) {
    BindingVariableReferenceContext *_localctx = _tracker.createInstance<BindingVariableReferenceContext>(_ctx, getState());
    enterRule(_localctx, 912, GQLParser::RuleBindingVariableReference);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4140);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    PathValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  PathValueExpressionContext* pathValueExpression(ContextT* ctx) {
    PathValueExpressionContext *_localctx = _tracker.createInstance<PathValueExpressionContext>(_ctx, getState());
    enterRule(_localctx, 914, GQLParser::RulePathValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4142);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathValueConstructorContext : public antlr4::ParserRuleContext {
  public:
    PathValueConstructorContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PathValueConstructorByEnumerationContext *pathValueConstructorByEnumeration();

   
  };

  template<typename ContextT>
  PathValueConstructorContext* pathValueConstructor(ContextT* ctx) {
    PathValueConstructorContext *_localctx = _tracker.createInstance<PathValueConstructorContext>(_ctx, getState());
    enterRule(_localctx, 916, GQLParser::RulePathValueConstructor);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4144);
      {
        auto childCtxHolder = ctx->EnterPathValueConstructorByEnumeration();
        pathValueConstructorByEnumeration(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathValueConstructorByEnumerationContext : public antlr4::ParserRuleContext {
  public:
    PathValueConstructorByEnumerationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PATH();
    antlr4::tree::TerminalNode *LEFT_BRACKET();
    PathElementListContext *pathElementList();
    antlr4::tree::TerminalNode *RIGHT_BRACKET();

   
  };

  template<typename ContextT>
  PathValueConstructorByEnumerationContext* pathValueConstructorByEnumeration(ContextT* ctx) {
    PathValueConstructorByEnumerationContext *_localctx = _tracker.createInstance<PathValueConstructorByEnumerationContext>(_ctx, getState());
    enterRule(_localctx, 918, GQLParser::RulePathValueConstructorByEnumeration);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4146);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::PATH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::PATH);
      setState(4147);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACKET);
      setState(4148);
      {
        auto childCtxHolder = ctx->EnterPathElementList();
        pathElementList(get_raw_pointer(childCtxHolder));
      }
      setState(4149);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathElementListContext : public antlr4::ParserRuleContext {
  public:
    PathElementListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    PathElementListStartContext *pathElementListStart();
    std::vector<PathElementListStepContext *> pathElementListStep();
    PathElementListStepContext* pathElementListStep(size_t i);

   
  };

  template<typename ContextT>
  PathElementListContext* pathElementList(ContextT* ctx) {
    PathElementListContext *_localctx = _tracker.createInstance<PathElementListContext>(_ctx, getState());
    enterRule(_localctx, 920, GQLParser::RulePathElementList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4151);
      {
        auto childCtxHolder = ctx->EnterPathElementListStart();
        pathElementListStart(get_raw_pointer(childCtxHolder));
      }
      setState(4155);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(4152);
        {
          auto childCtxHolder = ctx->EnterPathElementListStep();
          pathElementListStep(get_raw_pointer(childCtxHolder));
        }
        setState(4157);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathElementListStartContext : public antlr4::ParserRuleContext {
  public:
    PathElementListStartContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NodeReferenceValueExpressionContext *nodeReferenceValueExpression();

   
  };

  template<typename ContextT>
  PathElementListStartContext* pathElementListStart(ContextT* ctx) {
    PathElementListStartContext *_localctx = _tracker.createInstance<PathElementListStartContext>(_ctx, getState());
    enterRule(_localctx, 922, GQLParser::RulePathElementListStart);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4158);
      {
        auto childCtxHolder = ctx->EnterNodeReferenceValueExpression();
        nodeReferenceValueExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathElementListStepContext : public antlr4::ParserRuleContext {
  public:
    PathElementListStepContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);
    EdgeReferenceValueExpressionContext *edgeReferenceValueExpression();
    NodeReferenceValueExpressionContext *nodeReferenceValueExpression();

   
  };

  template<typename ContextT>
  PathElementListStepContext* pathElementListStep(ContextT* ctx) {
    PathElementListStepContext *_localctx = _tracker.createInstance<PathElementListStepContext>(_ctx, getState());
    enterRule(_localctx, 924, GQLParser::RulePathElementListStep);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4160);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4161);
      {
        auto childCtxHolder = ctx->EnterEdgeReferenceValueExpression();
        edgeReferenceValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4162);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4163);
      {
        auto childCtxHolder = ctx->EnterNodeReferenceValueExpression();
        nodeReferenceValueExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ListValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    ListValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  ListValueExpressionContext* listValueExpression(ContextT* ctx) {
    ListValueExpressionContext *_localctx = _tracker.createInstance<ListValueExpressionContext>(_ctx, getState());
    enterRule(_localctx, 926, GQLParser::RuleListValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4165);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ListValueFunctionContext : public antlr4::ParserRuleContext {
  public:
    ListValueFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    TrimListFunctionContext *trimListFunction();
    ElementsFunctionContext *elementsFunction();

   
  };

  template<typename ContextT>
  ListValueFunctionContext* listValueFunction(ContextT* ctx) {
    ListValueFunctionContext *_localctx = _tracker.createInstance<ListValueFunctionContext>(_ctx, getState());
    enterRule(_localctx, 928, GQLParser::RuleListValueFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4169);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::TRIM: {
          enterOuterAlt(_localctx, 1);
          setState(4167);
          {
            auto childCtxHolder = ctx->EnterTrimListFunction();
            trimListFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ELEMENTS: {
          enterOuterAlt(_localctx, 2);
          setState(4168);
          {
            auto childCtxHolder = ctx->EnterElementsFunction();
            elementsFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TrimListFunctionContext : public antlr4::ParserRuleContext {
  public:
    TrimListFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TRIM();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ListValueExpressionContext *listValueExpression();
    antlr4::tree::TerminalNode *COMMA();
    NumericValueExpressionContext *numericValueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  TrimListFunctionContext* trimListFunction(ContextT* ctx) {
    TrimListFunctionContext *_localctx = _tracker.createInstance<TrimListFunctionContext>(_ctx, getState());
    enterRule(_localctx, 930, GQLParser::RuleTrimListFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4171);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TRIM) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TRIM);
      setState(4172);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4173);
      {
        auto childCtxHolder = ctx->EnterListValueExpression();
        listValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4174);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4175);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4176);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ElementsFunctionContext : public antlr4::ParserRuleContext {
  public:
    ElementsFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ELEMENTS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    PathValueExpressionContext *pathValueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  ElementsFunctionContext* elementsFunction(ContextT* ctx) {
    ElementsFunctionContext *_localctx = _tracker.createInstance<ElementsFunctionContext>(_ctx, getState());
    enterRule(_localctx, 932, GQLParser::RuleElementsFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4178);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ELEMENTS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ELEMENTS);
      setState(4179);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4180);
      {
        auto childCtxHolder = ctx->EnterPathValueExpression();
        pathValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4181);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ListValueConstructorContext : public antlr4::ParserRuleContext {
  public:
    ListValueConstructorContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ListValueConstructorByEnumerationContext *listValueConstructorByEnumeration();

   
  };

  template<typename ContextT>
  ListValueConstructorContext* listValueConstructor(ContextT* ctx) {
    ListValueConstructorContext *_localctx = _tracker.createInstance<ListValueConstructorContext>(_ctx, getState());
    enterRule(_localctx, 934, GQLParser::RuleListValueConstructor);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4183);
      {
        auto childCtxHolder = ctx->EnterListValueConstructorByEnumeration();
        listValueConstructorByEnumeration(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ListValueConstructorByEnumerationContext : public antlr4::ParserRuleContext {
  public:
    ListValueConstructorByEnumerationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_BRACKET();
    antlr4::tree::TerminalNode *RIGHT_BRACKET();
    ListValueTypeNameContext *listValueTypeName();
    ListElementListContext *listElementList();

   
  };

  template<typename ContextT>
  ListValueConstructorByEnumerationContext* listValueConstructorByEnumeration(ContextT* ctx) {
    ListValueConstructorByEnumerationContext *_localctx = _tracker.createInstance<ListValueConstructorByEnumerationContext>(_ctx, getState());
    enterRule(_localctx, 936, GQLParser::RuleListValueConstructorByEnumeration);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4186);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::ARRAY || _la == GQLParser::GROUP

      || _la == GQLParser::LIST) {
        setState(4185);
        {
          auto childCtxHolder = ctx->EnterListValueTypeName();
          listValueTypeName(get_raw_pointer(childCtxHolder));
        }
      }
      setState(4188);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACKET);
      setState(4190);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8762849302180528028) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 309341980913) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 129)) & -8011702113698201677) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 193)) & 26393111092643) != 0) || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 1686650837008383) != 0) || ((((_la - 369) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 369)) & 151) != 0)) {
        setState(4189);
        {
          auto childCtxHolder = ctx->EnterListElementList();
          listElementList(get_raw_pointer(childCtxHolder));
        }
      }
      setState(4192);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACKET) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACKET);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ListElementListContext : public antlr4::ParserRuleContext {
  public:
    ListElementListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<ListElementContext *> listElement();
    ListElementContext* listElement(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  ListElementListContext* listElementList(ContextT* ctx) {
    ListElementListContext *_localctx = _tracker.createInstance<ListElementListContext>(_ctx, getState());
    enterRule(_localctx, 938, GQLParser::RuleListElementList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4194);
      {
        auto childCtxHolder = ctx->EnterListElement();
        listElement(get_raw_pointer(childCtxHolder));
      }
      setState(4199);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(4195);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(4196);
        {
          auto childCtxHolder = ctx->EnterListElement();
          listElement(get_raw_pointer(childCtxHolder));
        }
        setState(4201);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ListElementContext : public antlr4::ParserRuleContext {
  public:
    ListElementContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  ListElementContext* listElement(ContextT* ctx) {
    ListElementContext *_localctx = _tracker.createInstance<ListElementContext>(_ctx, getState());
    enterRule(_localctx, 940, GQLParser::RuleListElement);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4202);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  RecordConstructorContext : public antlr4::ParserRuleContext {
  public:
    RecordConstructorContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    FieldsSpecificationContext *fieldsSpecification();
    antlr4::tree::TerminalNode *RECORD();

   
  };

  template<typename ContextT>
  RecordConstructorContext* recordConstructor(ContextT* ctx) {
    RecordConstructorContext *_localctx = _tracker.createInstance<RecordConstructorContext>(_ctx, getState());
    enterRule(_localctx, 942, GQLParser::RuleRecordConstructor);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4205);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::RECORD) {
        setState(4204);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RECORD) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RECORD);
      }
      setState(4207);
      {
        auto childCtxHolder = ctx->EnterFieldsSpecification();
        fieldsSpecification(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FieldsSpecificationContext : public antlr4::ParserRuleContext {
  public:
    FieldsSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_BRACE();
    antlr4::tree::TerminalNode *RIGHT_BRACE();
    FieldListContext *fieldList();

   
  };

  template<typename ContextT>
  FieldsSpecificationContext* fieldsSpecification(ContextT* ctx) {
    FieldsSpecificationContext *_localctx = _tracker.createInstance<FieldsSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 944, GQLParser::RuleFieldsSpecification);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4209);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_BRACE);
      setState(4211);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE

      || _la == GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE || ((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 560750930165759) != 0)) {
        setState(4210);
        {
          auto childCtxHolder = ctx->EnterFieldList();
          fieldList(get_raw_pointer(childCtxHolder));
        }
      }
      setState(4213);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_BRACE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_BRACE);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FieldListContext : public antlr4::ParserRuleContext {
  public:
    FieldListContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    std::vector<FieldContext *> field();
    FieldContext* field(size_t i);
    std::vector<antlr4::tree::TerminalNode *> COMMA();
    antlr4::tree::TerminalNode* COMMA(size_t i);

   
  };

  template<typename ContextT>
  FieldListContext* fieldList(ContextT* ctx) {
    FieldListContext *_localctx = _tracker.createInstance<FieldListContext>(_ctx, getState());
    enterRule(_localctx, 946, GQLParser::RuleFieldList);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4215);
      {
        auto childCtxHolder = ctx->EnterField();
        field(get_raw_pointer(childCtxHolder));
      }
      setState(4220);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == GQLParser::COMMA) {
        setState(4216);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::COMMA) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::COMMA);
        setState(4217);
        {
          auto childCtxHolder = ctx->EnterField();
          field(get_raw_pointer(childCtxHolder));
        }
        setState(4222);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FieldContext : public antlr4::ParserRuleContext {
  public:
    FieldContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    FieldNameContext *fieldName();
    antlr4::tree::TerminalNode *COLON();
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  FieldContext* field(ContextT* ctx) {
    FieldContext *_localctx = _tracker.createInstance<FieldContext>(_ctx, getState());
    enterRule(_localctx, 948, GQLParser::RuleField);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4223);
      {
        auto childCtxHolder = ctx->EnterFieldName();
        fieldName(get_raw_pointer(childCtxHolder));
      }
      setState(4224);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COLON) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COLON);
      setState(4225);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TruthValueContext : public antlr4::ParserRuleContext {
  public:
    TruthValueContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BOOLEAN_LITERAL();

   
  };

  template<typename ContextT>
  TruthValueContext* truthValue(ContextT* ctx) {
    TruthValueContext *_localctx = _tracker.createInstance<TruthValueContext>(_ctx, getState());
    enterRule(_localctx, 950, GQLParser::RuleTruthValue);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4227);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::BOOLEAN_LITERAL) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::BOOLEAN_LITERAL);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NumericValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    NumericValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
   
    NumericValueExpressionContext() = default;
    void copyFrom(NumericValueExpressionContext *context);
    using antlr4::ParserRuleContext::copyFrom;

    virtual size_t getRuleIndex() const override;

   
  };

  class  MultDivExprAlt2Context : public NumericValueExpressionContext {
  public:
    MultDivExprAlt2Context(NumericValueExpressionContext *ctx);

    antlr4::Token *operator_ = nullptr;
    std::vector<NumericValueExpressionContext *> numericValueExpression();
    NumericValueExpressionContext* numericValueExpression(size_t i);
    antlr4::tree::TerminalNode *ASTERISK();
    antlr4::tree::TerminalNode *SOLIDUS();
  };

  class  NumericValueFunctionExprAltContext : public NumericValueExpressionContext {
  public:
    NumericValueFunctionExprAltContext(NumericValueExpressionContext *ctx);

    NumericValueFunctionContext *numericValueFunction();
  };

  class  SignedExprAlt2Context : public NumericValueExpressionContext {
  public:
    SignedExprAlt2Context(NumericValueExpressionContext *ctx);

    antlr4::Token *sign = nullptr;
    NumericValueExpressionContext *numericValueExpression();
    antlr4::tree::TerminalNode *PLUS_SIGN();
    antlr4::tree::TerminalNode *MINUS_SIGN();
  };

  class  PrimaryExprAlt2Context : public NumericValueExpressionContext {
  public:
    PrimaryExprAlt2Context(NumericValueExpressionContext *ctx);

    ValueExpressionPrimaryContext *valueExpressionPrimary();
  };

  class  AddSubtractExprAlt2Context : public NumericValueExpressionContext {
  public:
    AddSubtractExprAlt2Context(NumericValueExpressionContext *ctx);

    antlr4::Token *operator_ = nullptr;
    std::vector<NumericValueExpressionContext *> numericValueExpression();
    NumericValueExpressionContext* numericValueExpression(size_t i);
    antlr4::tree::TerminalNode *PLUS_SIGN();
    antlr4::tree::TerminalNode *MINUS_SIGN();
  };


  template<typename ContextT>
  NumericValueExpressionContext* numericValueExpression(ContextT* ctx) {
     return numericValueExpression(0, ctx);
  }

  template<typename ContextT>
  NumericValueExpressionContext* numericValueExpression(int precedence, ContextT* ctx) {
    antlr4::ParserRuleContext *parentContext = _ctx;
    size_t parentState = getState();
    GQLParser::NumericValueExpressionContext *_localctx = _tracker.createInstance<NumericValueExpressionContext>(_ctx, parentState);
    GQLParser::NumericValueExpressionContext *previousContext = _localctx;
    (void)previousContext; // Silence compiler, in case the context is not used by generated code.
    size_t startState = 952;
    enterRecursionRule(_localctx, 952, GQLParser::RuleNumericValueExpression, precedence);

      size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
      if constexpr (has_ExitRule<decltype(ctx)>::value) {
        ctx->ExitRule(_localctx);
      }
      unrollRecursionContexts(parentContext);
    });
    try {
      size_t alt;
      enterOuterAlt(_localctx, 1);
      setState(4234);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::MINUS_SIGN:
        case GQLParser::PLUS_SIGN: {
          _localctx = _tracker.createInstance<SignedExprAlt2Context>(_localctx);
          _ctx = _localctx;
          previousContext = _localctx;
          auto ctxHolder = ctx->EnterSignedExprAlt2();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });

          setState(4230);
          antlrcpp::downCast<SignedExprAlt2Context *>(_localctx)->sign = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == GQLParser::MINUS_SIGN

          || _la == GQLParser::PLUS_SIGN)) {
            antlrcpp::downCast<SignedExprAlt2Context *>(_localctx)->sign = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            antlr4::Token * token = consume();
            ctx->OnToken(token);
          }
          setState(4231);
          {
            auto childCtxHolder = ctx->EnterNumericValueExpression();
            numericValueExpression(5, get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BOOLEAN_LITERAL:
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::BYTE_STRING_LITERAL:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER:
        case GQLParser::ARRAY:
        case GQLParser::AVG:
        case GQLParser::CASE:
        case GQLParser::CAST:
        case GQLParser::COALESCE:
        case GQLParser::COLLECT_LIST:
        case GQLParser::COUNT:
        case GQLParser::DATE:
        case GQLParser::DATETIME:
        case GQLParser::DURATION:
        case GQLParser::ELEMENT_ID:
        case GQLParser::GROUP:
        case GQLParser::LET:
        case GQLParser::LIST:
        case GQLParser::MAX:
        case GQLParser::MIN:
        case GQLParser::NULL_KW:
        case GQLParser::NULLIF:
        case GQLParser::PATH:
        case GQLParser::PERCENTILE_CONT:
        case GQLParser::PERCENTILE_DISC:
        case GQLParser::RECORD:
        case GQLParser::SESSION_USER:
        case GQLParser::STDDEV_POP:
        case GQLParser::STDDEV_SAMP:
        case GQLParser::SUM:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::VALUE:
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER:
        case GQLParser::GENERAL_PARAMETER_REFERENCE:
        case GQLParser::LEFT_BRACE:
        case GQLParser::LEFT_BRACKET:
        case GQLParser::LEFT_PAREN: {
          _localctx = _tracker.createInstance<PrimaryExprAlt2Context>(_localctx);
          _ctx = _localctx;
          previousContext = _localctx;
          auto ctxHolder = ctx->EnterPrimaryExprAlt2();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          setState(4232);
          {
            auto childCtxHolder = ctx->EnterValueExpressionPrimary();
            valueExpressionPrimary(0, get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ABS:
        case GQLParser::ACOS:
        case GQLParser::ASIN:
        case GQLParser::ATAN:
        case GQLParser::BYTE_LENGTH:
        case GQLParser::CARDINALITY:
        case GQLParser::CEIL:
        case GQLParser::CEILING:
        case GQLParser::CHAR_LENGTH:
        case GQLParser::CHARACTER_LENGTH:
        case GQLParser::COS:
        case GQLParser::COSH:
        case GQLParser::COT:
        case GQLParser::DEGREES:
        case GQLParser::EXP:
        case GQLParser::FLOOR:
        case GQLParser::LN:
        case GQLParser::LOG_KW:
        case GQLParser::LOG10:
        case GQLParser::MOD:
        case GQLParser::OCTET_LENGTH:
        case GQLParser::PATH_LENGTH:
        case GQLParser::POWER:
        case GQLParser::RADIANS:
        case GQLParser::SIN:
        case GQLParser::SINH:
        case GQLParser::SIZE:
        case GQLParser::SQRT:
        case GQLParser::TAN:
        case GQLParser::TANH: {
          _localctx = _tracker.createInstance<NumericValueFunctionExprAltContext>(_localctx);
          _ctx = _localctx;
          previousContext = _localctx;
          auto ctxHolder = ctx->EnterNumericValueFunctionExprAlt();
          auto ctx = get_raw_pointer(ctxHolder);
          auto onExit = antlrcpp::finally([ctx, _localctx] {
            (void)_localctx;
            if constexpr (has_ExitRule<decltype(ctx)>::value)
              ctx->ExitRule(_localctx);
            else
              (void)ctx;
          });
          setState(4233);
          {
            auto childCtxHolder = ctx->EnterNumericValueFunction();
            numericValueFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
      _ctx->stop = _input->LT(-1);
      setState(4244);
      _errHandler->sync(this);
      alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 478, _ctx);
      while (alt != 2 && alt != antlr4::atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          if (!_parseListeners.empty())
            triggerExitRuleEvent();
          if constexpr (has_ExitRule<decltype(ctx)>::value) {
            ctx->ExitRule(_ctx);
          }
          previousContext = _localctx;
          setState(4242);
          _errHandler->sync(this);
          switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 477, _ctx)) {
          case 1: {
            auto newContext = _tracker.createInstance<MultDivExprAlt2Context>(_tracker.createInstance<NumericValueExpressionContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleNumericValueExpression);
            auto ctxHolder = ctx->PushMultDivExprAlt2_NumericValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(4236);

            if (!(precpred(_ctx, 4))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 4)");
            setState(4237);
            antlrcpp::downCast<MultDivExprAlt2Context *>(_localctx)->operator_ = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == GQLParser::ASTERISK

            || _la == GQLParser::SOLIDUS)) {
              antlrcpp::downCast<MultDivExprAlt2Context *>(_localctx)->operator_ = _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              antlr4::Token * token = consume();
              ctx->OnToken(token);
            }
            setState(4238);
            {
              auto childCtxHolder = ctx->EnterNumericValueExpression();
              numericValueExpression(5, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          case 2: {
            auto newContext = _tracker.createInstance<AddSubtractExprAlt2Context>(_tracker.createInstance<NumericValueExpressionContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleNumericValueExpression);
            auto ctxHolder = ctx->PushAddSubtractExprAlt2_NumericValueExpression();
            auto ctx = get_raw_pointer(ctxHolder);
            auto onExit = antlrcpp::finally([ctx, _localctx] {
              (void)_localctx;
              if constexpr (has_ExitRule<decltype(ctx)>::value)
                ctx->ExitRule(_localctx);
              else
                (void)ctx;
            });
            setState(4239);

            if (!(precpred(_ctx, 3))) throw antlr4::FailedPredicateException(this, "precpred(_ctx, 3)");
            setState(4240);
            antlrcpp::downCast<AddSubtractExprAlt2Context *>(_localctx)->operator_ = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == GQLParser::MINUS_SIGN

            || _la == GQLParser::PLUS_SIGN)) {
              antlrcpp::downCast<AddSubtractExprAlt2Context *>(_localctx)->operator_ = _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              antlr4::Token * token = consume();
              ctx->OnToken(token);
            }
            setState(4241);
            {
              auto childCtxHolder = ctx->EnterNumericValueExpression();
              numericValueExpression(4, get_raw_pointer(childCtxHolder));
            }
            break;
          }

          default:
            break;
          } 
        }
        setState(4246);
        _errHandler->sync(this);
        alt = getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 478, _ctx);
      }
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }
    return _localctx;
  }

  class  NumericValueFunctionContext : public antlr4::ParserRuleContext {
  public:
    NumericValueFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    LengthExpressionContext *lengthExpression();
    CardinalityExpressionContext *cardinalityExpression();
    AbsoluteValueExpressionContext *absoluteValueExpression();
    ModulusExpressionContext *modulusExpression();
    TrigonometricFunctionContext *trigonometricFunction();
    GeneralLogarithmFunctionContext *generalLogarithmFunction();
    CommonLogarithmContext *commonLogarithm();
    NaturalLogarithmContext *naturalLogarithm();
    ExponentialFunctionContext *exponentialFunction();
    PowerFunctionContext *powerFunction();
    SquareRootContext *squareRoot();
    FloorFunctionContext *floorFunction();
    CeilingFunctionContext *ceilingFunction();

   
  };

  template<typename ContextT>
  NumericValueFunctionContext* numericValueFunction(ContextT* ctx) {
    NumericValueFunctionContext *_localctx = _tracker.createInstance<NumericValueFunctionContext>(_ctx, getState());
    enterRule(_localctx, 954, GQLParser::RuleNumericValueFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4260);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BYTE_LENGTH:
        case GQLParser::CHAR_LENGTH:
        case GQLParser::CHARACTER_LENGTH:
        case GQLParser::OCTET_LENGTH:
        case GQLParser::PATH_LENGTH: {
          enterOuterAlt(_localctx, 1);
          setState(4247);
          {
            auto childCtxHolder = ctx->EnterLengthExpression();
            lengthExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CARDINALITY:
        case GQLParser::SIZE: {
          enterOuterAlt(_localctx, 2);
          setState(4248);
          {
            auto childCtxHolder = ctx->EnterCardinalityExpression();
            cardinalityExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ABS: {
          enterOuterAlt(_localctx, 3);
          setState(4249);
          {
            auto childCtxHolder = ctx->EnterAbsoluteValueExpression();
            absoluteValueExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::MOD: {
          enterOuterAlt(_localctx, 4);
          setState(4250);
          {
            auto childCtxHolder = ctx->EnterModulusExpression();
            modulusExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ACOS:
        case GQLParser::ASIN:
        case GQLParser::ATAN:
        case GQLParser::COS:
        case GQLParser::COSH:
        case GQLParser::COT:
        case GQLParser::DEGREES:
        case GQLParser::RADIANS:
        case GQLParser::SIN:
        case GQLParser::SINH:
        case GQLParser::TAN:
        case GQLParser::TANH: {
          enterOuterAlt(_localctx, 5);
          setState(4251);
          {
            auto childCtxHolder = ctx->EnterTrigonometricFunction();
            trigonometricFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LOG_KW: {
          enterOuterAlt(_localctx, 6);
          setState(4252);
          {
            auto childCtxHolder = ctx->EnterGeneralLogarithmFunction();
            generalLogarithmFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LOG10: {
          enterOuterAlt(_localctx, 7);
          setState(4253);
          {
            auto childCtxHolder = ctx->EnterCommonLogarithm();
            commonLogarithm(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LN: {
          enterOuterAlt(_localctx, 8);
          setState(4254);
          {
            auto childCtxHolder = ctx->EnterNaturalLogarithm();
            naturalLogarithm(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::EXP: {
          enterOuterAlt(_localctx, 9);
          setState(4255);
          {
            auto childCtxHolder = ctx->EnterExponentialFunction();
            exponentialFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::POWER: {
          enterOuterAlt(_localctx, 10);
          setState(4256);
          {
            auto childCtxHolder = ctx->EnterPowerFunction();
            powerFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::SQRT: {
          enterOuterAlt(_localctx, 11);
          setState(4257);
          {
            auto childCtxHolder = ctx->EnterSquareRoot();
            squareRoot(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::FLOOR: {
          enterOuterAlt(_localctx, 12);
          setState(4258);
          {
            auto childCtxHolder = ctx->EnterFloorFunction();
            floorFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CEIL:
        case GQLParser::CEILING: {
          enterOuterAlt(_localctx, 13);
          setState(4259);
          {
            auto childCtxHolder = ctx->EnterCeilingFunction();
            ceilingFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LengthExpressionContext : public antlr4::ParserRuleContext {
  public:
    LengthExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CharLengthExpressionContext *charLengthExpression();
    ByteLengthExpressionContext *byteLengthExpression();
    PathLengthExpressionContext *pathLengthExpression();

   
  };

  template<typename ContextT>
  LengthExpressionContext* lengthExpression(ContextT* ctx) {
    LengthExpressionContext *_localctx = _tracker.createInstance<LengthExpressionContext>(_ctx, getState());
    enterRule(_localctx, 956, GQLParser::RuleLengthExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4265);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CHAR_LENGTH:
        case GQLParser::CHARACTER_LENGTH: {
          enterOuterAlt(_localctx, 1);
          setState(4262);
          {
            auto childCtxHolder = ctx->EnterCharLengthExpression();
            charLengthExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BYTE_LENGTH:
        case GQLParser::OCTET_LENGTH: {
          enterOuterAlt(_localctx, 2);
          setState(4263);
          {
            auto childCtxHolder = ctx->EnterByteLengthExpression();
            byteLengthExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::PATH_LENGTH: {
          enterOuterAlt(_localctx, 3);
          setState(4264);
          {
            auto childCtxHolder = ctx->EnterPathLengthExpression();
            pathLengthExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CardinalityExpressionContext : public antlr4::ParserRuleContext {
  public:
    CardinalityExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CARDINALITY();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    CardinalityExpressionArgumentContext *cardinalityExpressionArgument();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *SIZE();
    ListValueExpressionContext *listValueExpression();

   
  };

  template<typename ContextT>
  CardinalityExpressionContext* cardinalityExpression(ContextT* ctx) {
    CardinalityExpressionContext *_localctx = _tracker.createInstance<CardinalityExpressionContext>(_ctx, getState());
    enterRule(_localctx, 958, GQLParser::RuleCardinalityExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4277);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CARDINALITY: {
          enterOuterAlt(_localctx, 1);
          setState(4267);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::CARDINALITY) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::CARDINALITY);
          setState(4268);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(4269);
          {
            auto childCtxHolder = ctx->EnterCardinalityExpressionArgument();
            cardinalityExpressionArgument(get_raw_pointer(childCtxHolder));
          }
          setState(4270);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

        case GQLParser::SIZE: {
          enterOuterAlt(_localctx, 2);
          setState(4272);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::SIZE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::SIZE);
          setState(4273);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(4274);
          {
            auto childCtxHolder = ctx->EnterListValueExpression();
            listValueExpression(get_raw_pointer(childCtxHolder));
          }
          setState(4275);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CardinalityExpressionArgumentContext : public antlr4::ParserRuleContext {
  public:
    CardinalityExpressionArgumentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  CardinalityExpressionArgumentContext* cardinalityExpressionArgument(ContextT* ctx) {
    CardinalityExpressionArgumentContext *_localctx = _tracker.createInstance<CardinalityExpressionArgumentContext>(_ctx, getState());
    enterRule(_localctx, 960, GQLParser::RuleCardinalityExpressionArgument);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4279);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CharLengthExpressionContext : public antlr4::ParserRuleContext {
  public:
    CharLengthExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    CharacterStringValueExpressionContext *characterStringValueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *CHAR_LENGTH();
    antlr4::tree::TerminalNode *CHARACTER_LENGTH();

   
  };

  template<typename ContextT>
  CharLengthExpressionContext* charLengthExpression(ContextT* ctx) {
    CharLengthExpressionContext *_localctx = _tracker.createInstance<CharLengthExpressionContext>(_ctx, getState());
    enterRule(_localctx, 962, GQLParser::RuleCharLengthExpression);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4281);
      _la = _input->LA(1);
      if (!(_la == GQLParser::CHAR_LENGTH

      || _la == GQLParser::CHARACTER_LENGTH)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(4282);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4283);
      {
        auto childCtxHolder = ctx->EnterCharacterStringValueExpression();
        characterStringValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4284);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ByteLengthExpressionContext : public antlr4::ParserRuleContext {
  public:
    ByteLengthExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ByteStringValueExpressionContext *byteStringValueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *BYTE_LENGTH();
    antlr4::tree::TerminalNode *OCTET_LENGTH();

   
  };

  template<typename ContextT>
  ByteLengthExpressionContext* byteLengthExpression(ContextT* ctx) {
    ByteLengthExpressionContext *_localctx = _tracker.createInstance<ByteLengthExpressionContext>(_ctx, getState());
    enterRule(_localctx, 964, GQLParser::RuleByteLengthExpression);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4286);
      _la = _input->LA(1);
      if (!(_la == GQLParser::BYTE_LENGTH || _la == GQLParser::OCTET_LENGTH)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(4287);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4288);
      {
        auto childCtxHolder = ctx->EnterByteStringValueExpression();
        byteStringValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4289);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathLengthExpressionContext : public antlr4::ParserRuleContext {
  public:
    PathLengthExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *PATH_LENGTH();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    PathValueExpressionContext *pathValueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  PathLengthExpressionContext* pathLengthExpression(ContextT* ctx) {
    PathLengthExpressionContext *_localctx = _tracker.createInstance<PathLengthExpressionContext>(_ctx, getState());
    enterRule(_localctx, 966, GQLParser::RulePathLengthExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4291);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::PATH_LENGTH) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::PATH_LENGTH);
      setState(4292);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4293);
      {
        auto childCtxHolder = ctx->EnterPathValueExpression();
        pathValueExpression(get_raw_pointer(childCtxHolder));
      }
      setState(4294);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  AbsoluteValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    AbsoluteValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ABS();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    ValueExpressionContext *valueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  AbsoluteValueExpressionContext* absoluteValueExpression(ContextT* ctx) {
    AbsoluteValueExpressionContext *_localctx = _tracker.createInstance<AbsoluteValueExpressionContext>(_ctx, getState());
    enterRule(_localctx, 968, GQLParser::RuleAbsoluteValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4296);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::ABS) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::ABS);
      setState(4297);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4298);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4299);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ModulusExpressionContext : public antlr4::ParserRuleContext {
  public:
    ModulusExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *MOD();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    NumericValueExpressionDividendContext *numericValueExpressionDividend();
    antlr4::tree::TerminalNode *COMMA();
    NumericValueExpressionDivisorContext *numericValueExpressionDivisor();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  ModulusExpressionContext* modulusExpression(ContextT* ctx) {
    ModulusExpressionContext *_localctx = _tracker.createInstance<ModulusExpressionContext>(_ctx, getState());
    enterRule(_localctx, 970, GQLParser::RuleModulusExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4301);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::MOD) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::MOD);
      setState(4302);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4303);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpressionDividend();
        numericValueExpressionDividend(get_raw_pointer(childCtxHolder));
      }
      setState(4304);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4305);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpressionDivisor();
        numericValueExpressionDivisor(get_raw_pointer(childCtxHolder));
      }
      setState(4306);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NumericValueExpressionDividendContext : public antlr4::ParserRuleContext {
  public:
    NumericValueExpressionDividendContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NumericValueExpressionContext *numericValueExpression();

   
  };

  template<typename ContextT>
  NumericValueExpressionDividendContext* numericValueExpressionDividend(ContextT* ctx) {
    NumericValueExpressionDividendContext *_localctx = _tracker.createInstance<NumericValueExpressionDividendContext>(_ctx, getState());
    enterRule(_localctx, 972, GQLParser::RuleNumericValueExpressionDividend);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4308);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NumericValueExpressionDivisorContext : public antlr4::ParserRuleContext {
  public:
    NumericValueExpressionDivisorContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NumericValueExpressionContext *numericValueExpression();

   
  };

  template<typename ContextT>
  NumericValueExpressionDivisorContext* numericValueExpressionDivisor(ContextT* ctx) {
    NumericValueExpressionDivisorContext *_localctx = _tracker.createInstance<NumericValueExpressionDivisorContext>(_ctx, getState());
    enterRule(_localctx, 974, GQLParser::RuleNumericValueExpressionDivisor);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4310);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TrigonometricFunctionContext : public antlr4::ParserRuleContext {
  public:
    TrigonometricFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    TrigonometricFunctionNameContext *trigonometricFunctionName();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    NumericValueExpressionContext *numericValueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  TrigonometricFunctionContext* trigonometricFunction(ContextT* ctx) {
    TrigonometricFunctionContext *_localctx = _tracker.createInstance<TrigonometricFunctionContext>(_ctx, getState());
    enterRule(_localctx, 976, GQLParser::RuleTrigonometricFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4312);
      {
        auto childCtxHolder = ctx->EnterTrigonometricFunctionName();
        trigonometricFunctionName(get_raw_pointer(childCtxHolder));
      }
      setState(4313);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4314);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4315);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TrigonometricFunctionNameContext : public antlr4::ParserRuleContext {
  public:
    TrigonometricFunctionNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SIN();
    antlr4::tree::TerminalNode *COS();
    antlr4::tree::TerminalNode *TAN();
    antlr4::tree::TerminalNode *COT();
    antlr4::tree::TerminalNode *SINH();
    antlr4::tree::TerminalNode *COSH();
    antlr4::tree::TerminalNode *TANH();
    antlr4::tree::TerminalNode *ASIN();
    antlr4::tree::TerminalNode *ACOS();
    antlr4::tree::TerminalNode *ATAN();
    antlr4::tree::TerminalNode *DEGREES();
    antlr4::tree::TerminalNode *RADIANS();

   
  };

  template<typename ContextT>
  TrigonometricFunctionNameContext* trigonometricFunctionName(ContextT* ctx) {
    TrigonometricFunctionNameContext *_localctx = _tracker.createInstance<TrigonometricFunctionNameContext>(_ctx, getState());
    enterRule(_localctx, 978, GQLParser::RuleTrigonometricFunctionName);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4317);
      _la = _input->LA(1);
      if (!(((((_la - 21) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 21)) & 18016322654833153) != 0) || ((((_la - 174) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 174)) & 3222011905) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GeneralLogarithmFunctionContext : public antlr4::ParserRuleContext {
  public:
    GeneralLogarithmFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOG_KW();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    GeneralLogarithmBaseContext *generalLogarithmBase();
    antlr4::tree::TerminalNode *COMMA();
    GeneralLogarithmArgumentContext *generalLogarithmArgument();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  GeneralLogarithmFunctionContext* generalLogarithmFunction(ContextT* ctx) {
    GeneralLogarithmFunctionContext *_localctx = _tracker.createInstance<GeneralLogarithmFunctionContext>(_ctx, getState());
    enterRule(_localctx, 980, GQLParser::RuleGeneralLogarithmFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4319);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LOG_KW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LOG_KW);
      setState(4320);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4321);
      {
        auto childCtxHolder = ctx->EnterGeneralLogarithmBase();
        generalLogarithmBase(get_raw_pointer(childCtxHolder));
      }
      setState(4322);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4323);
      {
        auto childCtxHolder = ctx->EnterGeneralLogarithmArgument();
        generalLogarithmArgument(get_raw_pointer(childCtxHolder));
      }
      setState(4324);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GeneralLogarithmBaseContext : public antlr4::ParserRuleContext {
  public:
    GeneralLogarithmBaseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NumericValueExpressionContext *numericValueExpression();

   
  };

  template<typename ContextT>
  GeneralLogarithmBaseContext* generalLogarithmBase(ContextT* ctx) {
    GeneralLogarithmBaseContext *_localctx = _tracker.createInstance<GeneralLogarithmBaseContext>(_ctx, getState());
    enterRule(_localctx, 982, GQLParser::RuleGeneralLogarithmBase);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4326);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GeneralLogarithmArgumentContext : public antlr4::ParserRuleContext {
  public:
    GeneralLogarithmArgumentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NumericValueExpressionContext *numericValueExpression();

   
  };

  template<typename ContextT>
  GeneralLogarithmArgumentContext* generalLogarithmArgument(ContextT* ctx) {
    GeneralLogarithmArgumentContext *_localctx = _tracker.createInstance<GeneralLogarithmArgumentContext>(_ctx, getState());
    enterRule(_localctx, 984, GQLParser::RuleGeneralLogarithmArgument);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4328);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CommonLogarithmContext : public antlr4::ParserRuleContext {
  public:
    CommonLogarithmContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOG10();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    NumericValueExpressionContext *numericValueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  CommonLogarithmContext* commonLogarithm(ContextT* ctx) {
    CommonLogarithmContext *_localctx = _tracker.createInstance<CommonLogarithmContext>(_ctx, getState());
    enterRule(_localctx, 986, GQLParser::RuleCommonLogarithm);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4330);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LOG10) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LOG10);
      setState(4331);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4332);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4333);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NaturalLogarithmContext : public antlr4::ParserRuleContext {
  public:
    NaturalLogarithmContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    NumericValueExpressionContext *numericValueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  NaturalLogarithmContext* naturalLogarithm(ContextT* ctx) {
    NaturalLogarithmContext *_localctx = _tracker.createInstance<NaturalLogarithmContext>(_ctx, getState());
    enterRule(_localctx, 988, GQLParser::RuleNaturalLogarithm);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4335);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LN);
      setState(4336);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4337);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4338);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ExponentialFunctionContext : public antlr4::ParserRuleContext {
  public:
    ExponentialFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EXP();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    NumericValueExpressionContext *numericValueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  ExponentialFunctionContext* exponentialFunction(ContextT* ctx) {
    ExponentialFunctionContext *_localctx = _tracker.createInstance<ExponentialFunctionContext>(_ctx, getState());
    enterRule(_localctx, 990, GQLParser::RuleExponentialFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4340);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::EXP) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::EXP);
      setState(4341);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4342);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4343);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PowerFunctionContext : public antlr4::ParserRuleContext {
  public:
    PowerFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *POWER();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    NumericValueExpressionBaseContext *numericValueExpressionBase();
    antlr4::tree::TerminalNode *COMMA();
    NumericValueExpressionExponentContext *numericValueExpressionExponent();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  PowerFunctionContext* powerFunction(ContextT* ctx) {
    PowerFunctionContext *_localctx = _tracker.createInstance<PowerFunctionContext>(_ctx, getState());
    enterRule(_localctx, 992, GQLParser::RulePowerFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4345);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::POWER) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::POWER);
      setState(4346);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4347);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpressionBase();
        numericValueExpressionBase(get_raw_pointer(childCtxHolder));
      }
      setState(4348);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4349);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpressionExponent();
        numericValueExpressionExponent(get_raw_pointer(childCtxHolder));
      }
      setState(4350);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NumericValueExpressionBaseContext : public antlr4::ParserRuleContext {
  public:
    NumericValueExpressionBaseContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NumericValueExpressionContext *numericValueExpression();

   
  };

  template<typename ContextT>
  NumericValueExpressionBaseContext* numericValueExpressionBase(ContextT* ctx) {
    NumericValueExpressionBaseContext *_localctx = _tracker.createInstance<NumericValueExpressionBaseContext>(_ctx, getState());
    enterRule(_localctx, 994, GQLParser::RuleNumericValueExpressionBase);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4352);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NumericValueExpressionExponentContext : public antlr4::ParserRuleContext {
  public:
    NumericValueExpressionExponentContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NumericValueExpressionContext *numericValueExpression();

   
  };

  template<typename ContextT>
  NumericValueExpressionExponentContext* numericValueExpressionExponent(ContextT* ctx) {
    NumericValueExpressionExponentContext *_localctx = _tracker.createInstance<NumericValueExpressionExponentContext>(_ctx, getState());
    enterRule(_localctx, 996, GQLParser::RuleNumericValueExpressionExponent);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4354);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SquareRootContext : public antlr4::ParserRuleContext {
  public:
    SquareRootContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SQRT();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    NumericValueExpressionContext *numericValueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  SquareRootContext* squareRoot(ContextT* ctx) {
    SquareRootContext *_localctx = _tracker.createInstance<SquareRootContext>(_ctx, getState());
    enterRule(_localctx, 998, GQLParser::RuleSquareRoot);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4356);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::SQRT) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::SQRT);
      setState(4357);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4358);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4359);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FloorFunctionContext : public antlr4::ParserRuleContext {
  public:
    FloorFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *FLOOR();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    NumericValueExpressionContext *numericValueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  FloorFunctionContext* floorFunction(ContextT* ctx) {
    FloorFunctionContext *_localctx = _tracker.createInstance<FloorFunctionContext>(_ctx, getState());
    enterRule(_localctx, 1000, GQLParser::RuleFloorFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4361);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::FLOOR) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::FLOOR);
      setState(4362);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4363);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4364);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CeilingFunctionContext : public antlr4::ParserRuleContext {
  public:
    CeilingFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEFT_PAREN();
    NumericValueExpressionContext *numericValueExpression();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    antlr4::tree::TerminalNode *CEIL();
    antlr4::tree::TerminalNode *CEILING();

   
  };

  template<typename ContextT>
  CeilingFunctionContext* ceilingFunction(ContextT* ctx) {
    CeilingFunctionContext *_localctx = _tracker.createInstance<CeilingFunctionContext>(_ctx, getState());
    enterRule(_localctx, 1002, GQLParser::RuleCeilingFunction);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4366);
      _la = _input->LA(1);
      if (!(_la == GQLParser::CEIL

      || _la == GQLParser::CEILING)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(4367);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4368);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
      setState(4369);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CharacterStringValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    CharacterStringValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  CharacterStringValueExpressionContext* characterStringValueExpression(ContextT* ctx) {
    CharacterStringValueExpressionContext *_localctx = _tracker.createInstance<CharacterStringValueExpressionContext>(_ctx, getState());
    enterRule(_localctx, 1004, GQLParser::RuleCharacterStringValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4371);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ByteStringValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    ByteStringValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  ByteStringValueExpressionContext* byteStringValueExpression(ContextT* ctx) {
    ByteStringValueExpressionContext *_localctx = _tracker.createInstance<ByteStringValueExpressionContext>(_ctx, getState());
    enterRule(_localctx, 1006, GQLParser::RuleByteStringValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4373);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TrimOperandsContext : public antlr4::ParserRuleContext {
  public:
    TrimOperandsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    TrimCharacterOrByteStringSourceContext *trimCharacterOrByteStringSource();
    antlr4::tree::TerminalNode *FROM();
    TrimSpecificationContext *trimSpecification();
    TrimCharacterOrByteStringContext *trimCharacterOrByteString();

   
  };

  template<typename ContextT>
  TrimOperandsContext* trimOperands(ContextT* ctx) {
    TrimOperandsContext *_localctx = _tracker.createInstance<TrimOperandsContext>(_ctx, getState());
    enterRule(_localctx, 1008, GQLParser::RuleTrimOperands);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4382);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 484, _ctx)) {
      case 1: {
        setState(4376);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::BOTH || _la == GQLParser::LEADING || _la == GQLParser::TRAILING) {
          setState(4375);
          {
            auto childCtxHolder = ctx->EnterTrimSpecification();
            trimSpecification(get_raw_pointer(childCtxHolder));
          }
        }
        setState(4379);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 8762849302180528028) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & 309341980913) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 129)) & -8011702113698201677) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 193)) & 26393111092643) != 0) || ((((_la - 277) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 277)) & 1686650837008383) != 0) || ((((_la - 369) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 369)) & 151) != 0)) {
          setState(4378);
          {
            auto childCtxHolder = ctx->EnterTrimCharacterOrByteString();
            trimCharacterOrByteString(get_raw_pointer(childCtxHolder));
          }
        }
        setState(4381);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::FROM) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::FROM);
        break;
      }

      default:
        break;
      }
      setState(4384);
      {
        auto childCtxHolder = ctx->EnterTrimCharacterOrByteStringSource();
        trimCharacterOrByteStringSource(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TrimCharacterOrByteStringSourceContext : public antlr4::ParserRuleContext {
  public:
    TrimCharacterOrByteStringSourceContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  TrimCharacterOrByteStringSourceContext* trimCharacterOrByteStringSource(ContextT* ctx) {
    TrimCharacterOrByteStringSourceContext *_localctx = _tracker.createInstance<TrimCharacterOrByteStringSourceContext>(_ctx, getState());
    enterRule(_localctx, 1010, GQLParser::RuleTrimCharacterOrByteStringSource);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4386);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TrimSpecificationContext : public antlr4::ParserRuleContext {
  public:
    TrimSpecificationContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LEADING();
    antlr4::tree::TerminalNode *TRAILING();
    antlr4::tree::TerminalNode *BOTH();

   
  };

  template<typename ContextT>
  TrimSpecificationContext* trimSpecification(ContextT* ctx) {
    TrimSpecificationContext *_localctx = _tracker.createInstance<TrimSpecificationContext>(_ctx, getState());
    enterRule(_localctx, 1012, GQLParser::RuleTrimSpecification);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4388);
      _la = _input->LA(1);
      if (!(_la == GQLParser::BOTH || _la == GQLParser::LEADING || _la == GQLParser::TRAILING)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TrimCharacterOrByteStringContext : public antlr4::ParserRuleContext {
  public:
    TrimCharacterOrByteStringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  TrimCharacterOrByteStringContext* trimCharacterOrByteString(ContextT* ctx) {
    TrimCharacterOrByteStringContext *_localctx = _tracker.createInstance<TrimCharacterOrByteStringContext>(_ctx, getState());
    enterRule(_localctx, 1014, GQLParser::RuleTrimCharacterOrByteString);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4390);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NormalFormContext : public antlr4::ParserRuleContext {
  public:
    NormalFormContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NFC();
    antlr4::tree::TerminalNode *NFD();
    antlr4::tree::TerminalNode *NFKC();
    antlr4::tree::TerminalNode *NFKD();

   
  };

  template<typename ContextT>
  NormalFormContext* normalForm(ContextT* ctx) {
    NormalFormContext *_localctx = _tracker.createInstance<NormalFormContext>(_ctx, getState());
    enterRule(_localctx, 1016, GQLParser::RuleNormalForm);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4392);
      _la = _input->LA(1);
      if (!(((((_la - 296) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 296)) & 15) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  StringLengthContext : public antlr4::ParserRuleContext {
  public:
    StringLengthContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    NumericValueExpressionContext *numericValueExpression();

   
  };

  template<typename ContextT>
  StringLengthContext* stringLength(ContextT* ctx) {
    StringLengthContext *_localctx = _tracker.createInstance<StringLengthContext>(_ctx, getState());
    enterRule(_localctx, 1018, GQLParser::RuleStringLength);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4394);
      {
        auto childCtxHolder = ctx->EnterNumericValueExpression();
        numericValueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DatetimeValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    DatetimeValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  DatetimeValueExpressionContext* datetimeValueExpression(ContextT* ctx) {
    DatetimeValueExpressionContext *_localctx = _tracker.createInstance<DatetimeValueExpressionContext>(_ctx, getState());
    enterRule(_localctx, 1020, GQLParser::RuleDatetimeValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4396);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DatetimeValueFunctionContext : public antlr4::ParserRuleContext {
  public:
    DatetimeValueFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DateFunctionContext *dateFunction();
    TimeFunctionContext *timeFunction();
    DatetimeFunctionContext *datetimeFunction();
    LocaltimeFunctionContext *localtimeFunction();
    LocaldatetimeFunctionContext *localdatetimeFunction();

   
  };

  template<typename ContextT>
  DatetimeValueFunctionContext* datetimeValueFunction(ContextT* ctx) {
    DatetimeValueFunctionContext *_localctx = _tracker.createInstance<DatetimeValueFunctionContext>(_ctx, getState());
    enterRule(_localctx, 1022, GQLParser::RuleDatetimeValueFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4403);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CURRENT_DATE:
        case GQLParser::DATE: {
          enterOuterAlt(_localctx, 1);
          setState(4398);
          {
            auto childCtxHolder = ctx->EnterDateFunction();
            dateFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CURRENT_TIME:
        case GQLParser::ZONED_TIME: {
          enterOuterAlt(_localctx, 2);
          setState(4399);
          {
            auto childCtxHolder = ctx->EnterTimeFunction();
            timeFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::CURRENT_TIMESTAMP:
        case GQLParser::ZONED_DATETIME: {
          enterOuterAlt(_localctx, 3);
          setState(4400);
          {
            auto childCtxHolder = ctx->EnterDatetimeFunction();
            datetimeFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LOCAL_TIME: {
          enterOuterAlt(_localctx, 4);
          setState(4401);
          {
            auto childCtxHolder = ctx->EnterLocaltimeFunction();
            localtimeFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::LOCAL_DATETIME:
        case GQLParser::LOCAL_TIMESTAMP: {
          enterOuterAlt(_localctx, 5);
          setState(4402);
          {
            auto childCtxHolder = ctx->EnterLocaldatetimeFunction();
            localdatetimeFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DateFunctionContext : public antlr4::ParserRuleContext {
  public:
    DateFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CURRENT_DATE();
    antlr4::tree::TerminalNode *DATE();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    DateFunctionParametersContext *dateFunctionParameters();

   
  };

  template<typename ContextT>
  DateFunctionContext* dateFunction(ContextT* ctx) {
    DateFunctionContext *_localctx = _tracker.createInstance<DateFunctionContext>(_ctx, getState());
    enterRule(_localctx, 1024, GQLParser::RuleDateFunction);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4412);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CURRENT_DATE: {
          enterOuterAlt(_localctx, 1);
          setState(4405);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::CURRENT_DATE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::CURRENT_DATE);
          break;
        }

        case GQLParser::DATE: {
          enterOuterAlt(_localctx, 2);
          setState(4406);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::DATE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::DATE);
          setState(4407);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(4409);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE

          || _la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParser::RECORD || _la == GQLParser::LEFT_BRACE) {
            setState(4408);
            {
              auto childCtxHolder = ctx->EnterDateFunctionParameters();
              dateFunctionParameters(get_raw_pointer(childCtxHolder));
            }
          }
          setState(4411);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TimeFunctionContext : public antlr4::ParserRuleContext {
  public:
    TimeFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CURRENT_TIME();
    antlr4::tree::TerminalNode *ZONED_TIME();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    TimeFunctionParametersContext *timeFunctionParameters();

   
  };

  template<typename ContextT>
  TimeFunctionContext* timeFunction(ContextT* ctx) {
    TimeFunctionContext *_localctx = _tracker.createInstance<TimeFunctionContext>(_ctx, getState());
    enterRule(_localctx, 1026, GQLParser::RuleTimeFunction);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4421);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CURRENT_TIME: {
          enterOuterAlt(_localctx, 1);
          setState(4414);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::CURRENT_TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::CURRENT_TIME);
          break;
        }

        case GQLParser::ZONED_TIME: {
          enterOuterAlt(_localctx, 2);
          setState(4415);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONED_TIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONED_TIME);
          setState(4416);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(4418);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE

          || _la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParser::RECORD || _la == GQLParser::LEFT_BRACE) {
            setState(4417);
            {
              auto childCtxHolder = ctx->EnterTimeFunctionParameters();
              timeFunctionParameters(get_raw_pointer(childCtxHolder));
            }
          }
          setState(4420);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LocaltimeFunctionContext : public antlr4::ParserRuleContext {
  public:
    LocaltimeFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOCAL_TIME();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    TimeFunctionParametersContext *timeFunctionParameters();

   
  };

  template<typename ContextT>
  LocaltimeFunctionContext* localtimeFunction(ContextT* ctx) {
    LocaltimeFunctionContext *_localctx = _tracker.createInstance<LocaltimeFunctionContext>(_ctx, getState());
    enterRule(_localctx, 1028, GQLParser::RuleLocaltimeFunction);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4423);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LOCAL_TIME) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LOCAL_TIME);
      setState(4429);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 491, _ctx)) {
      case 1: {
        setState(4424);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::LEFT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::LEFT_PAREN);
        setState(4426);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE

        || _la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParser::RECORD || _la == GQLParser::LEFT_BRACE) {
          setState(4425);
          {
            auto childCtxHolder = ctx->EnterTimeFunctionParameters();
            timeFunctionParameters(get_raw_pointer(childCtxHolder));
          }
        }
        setState(4428);
        if constexpr (has_OnToken<decltype(ctx)>::value) {
          if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
            ctx->OnToken(_input->LT(1));
          }
        }
        match(GQLParser::RIGHT_PAREN);
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DatetimeFunctionContext : public antlr4::ParserRuleContext {
  public:
    DatetimeFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *CURRENT_TIMESTAMP();
    antlr4::tree::TerminalNode *ZONED_DATETIME();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    DatetimeFunctionParametersContext *datetimeFunctionParameters();

   
  };

  template<typename ContextT>
  DatetimeFunctionContext* datetimeFunction(ContextT* ctx) {
    DatetimeFunctionContext *_localctx = _tracker.createInstance<DatetimeFunctionContext>(_ctx, getState());
    enterRule(_localctx, 1030, GQLParser::RuleDatetimeFunction);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4438);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::CURRENT_TIMESTAMP: {
          enterOuterAlt(_localctx, 1);
          setState(4431);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::CURRENT_TIMESTAMP) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::CURRENT_TIMESTAMP);
          break;
        }

        case GQLParser::ZONED_DATETIME: {
          enterOuterAlt(_localctx, 2);
          setState(4432);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ZONED_DATETIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ZONED_DATETIME);
          setState(4433);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(4435);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE

          || _la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParser::RECORD || _la == GQLParser::LEFT_BRACE) {
            setState(4434);
            {
              auto childCtxHolder = ctx->EnterDatetimeFunctionParameters();
              datetimeFunctionParameters(get_raw_pointer(childCtxHolder));
            }
          }
          setState(4437);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LocaldatetimeFunctionContext : public antlr4::ParserRuleContext {
  public:
    LocaldatetimeFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *LOCAL_TIMESTAMP();
    antlr4::tree::TerminalNode *LOCAL_DATETIME();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    DatetimeFunctionParametersContext *datetimeFunctionParameters();

   
  };

  template<typename ContextT>
  LocaldatetimeFunctionContext* localdatetimeFunction(ContextT* ctx) {
    LocaldatetimeFunctionContext *_localctx = _tracker.createInstance<LocaldatetimeFunctionContext>(_ctx, getState());
    enterRule(_localctx, 1032, GQLParser::RuleLocaldatetimeFunction);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4447);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::LOCAL_TIMESTAMP: {
          enterOuterAlt(_localctx, 1);
          setState(4440);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LOCAL_TIMESTAMP) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LOCAL_TIMESTAMP);
          break;
        }

        case GQLParser::LOCAL_DATETIME: {
          enterOuterAlt(_localctx, 2);
          setState(4441);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LOCAL_DATETIME) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LOCAL_DATETIME);
          setState(4442);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::LEFT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::LEFT_PAREN);
          setState(4444);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE

          || _la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE || _la == GQLParser::RECORD || _la == GQLParser::LEFT_BRACE) {
            setState(4443);
            {
              auto childCtxHolder = ctx->EnterDatetimeFunctionParameters();
              datetimeFunctionParameters(get_raw_pointer(childCtxHolder));
            }
          }
          setState(4446);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::RIGHT_PAREN);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DateFunctionParametersContext : public antlr4::ParserRuleContext {
  public:
    DateFunctionParametersContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DateStringContext *dateString();
    RecordConstructorContext *recordConstructor();

   
  };

  template<typename ContextT>
  DateFunctionParametersContext* dateFunctionParameters(ContextT* ctx) {
    DateFunctionParametersContext *_localctx = _tracker.createInstance<DateFunctionParametersContext>(_ctx, getState());
    enterRule(_localctx, 1034, GQLParser::RuleDateFunctionParameters);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4451);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 1);
          setState(4449);
          {
            auto childCtxHolder = ctx->EnterDateString();
            dateString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::RECORD:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(4450);
          {
            auto childCtxHolder = ctx->EnterRecordConstructor();
            recordConstructor(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TimeFunctionParametersContext : public antlr4::ParserRuleContext {
  public:
    TimeFunctionParametersContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    TimeStringContext *timeString();
    RecordConstructorContext *recordConstructor();

   
  };

  template<typename ContextT>
  TimeFunctionParametersContext* timeFunctionParameters(ContextT* ctx) {
    TimeFunctionParametersContext *_localctx = _tracker.createInstance<TimeFunctionParametersContext>(_ctx, getState());
    enterRule(_localctx, 1036, GQLParser::RuleTimeFunctionParameters);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4455);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 1);
          setState(4453);
          {
            auto childCtxHolder = ctx->EnterTimeString();
            timeString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::RECORD:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(4454);
          {
            auto childCtxHolder = ctx->EnterRecordConstructor();
            recordConstructor(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DatetimeFunctionParametersContext : public antlr4::ParserRuleContext {
  public:
    DatetimeFunctionParametersContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DatetimeStringContext *datetimeString();
    RecordConstructorContext *recordConstructor();

   
  };

  template<typename ContextT>
  DatetimeFunctionParametersContext* datetimeFunctionParameters(ContextT* ctx) {
    DatetimeFunctionParametersContext *_localctx = _tracker.createInstance<DatetimeFunctionParametersContext>(_ctx, getState());
    enterRule(_localctx, 1038, GQLParser::RuleDatetimeFunctionParameters);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4459);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 1);
          setState(4457);
          {
            auto childCtxHolder = ctx->EnterDatetimeString();
            datetimeString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::RECORD:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(4458);
          {
            auto childCtxHolder = ctx->EnterRecordConstructor();
            recordConstructor(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DurationValueExpressionContext : public antlr4::ParserRuleContext {
  public:
    DurationValueExpressionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ValueExpressionContext *valueExpression();

   
  };

  template<typename ContextT>
  DurationValueExpressionContext* durationValueExpression(ContextT* ctx) {
    DurationValueExpressionContext *_localctx = _tracker.createInstance<DurationValueExpressionContext>(_ctx, getState());
    enterRule(_localctx, 1040, GQLParser::RuleDurationValueExpression);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4461);
      {
        auto childCtxHolder = ctx->EnterValueExpression();
        valueExpression(0, get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DatetimeSubtractionContext : public antlr4::ParserRuleContext {
  public:
    DatetimeSubtractionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DURATION_BETWEEN();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    DatetimeSubtractionParametersContext *datetimeSubtractionParameters();
    antlr4::tree::TerminalNode *RIGHT_PAREN();
    TemporalDurationQualifierContext *temporalDurationQualifier();

   
  };

  template<typename ContextT>
  DatetimeSubtractionContext* datetimeSubtraction(ContextT* ctx) {
    DatetimeSubtractionContext *_localctx = _tracker.createInstance<DatetimeSubtractionContext>(_ctx, getState());
    enterRule(_localctx, 1042, GQLParser::RuleDatetimeSubtraction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4463);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DURATION_BETWEEN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DURATION_BETWEEN);
      setState(4464);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4465);
      {
        auto childCtxHolder = ctx->EnterDatetimeSubtractionParameters();
        datetimeSubtractionParameters(get_raw_pointer(childCtxHolder));
      }
      setState(4466);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
      setState(4468);
      _errHandler->sync(this);

      switch (getInterpreter<antlr4::atn::ParserATNSimulator>()->adaptivePredict(_input, 499, _ctx)) {
      case 1: {
        setState(4467);
        {
          auto childCtxHolder = ctx->EnterTemporalDurationQualifier();
          temporalDurationQualifier(get_raw_pointer(childCtxHolder));
        }
        break;
      }

      default:
        break;
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DatetimeSubtractionParametersContext : public antlr4::ParserRuleContext {
  public:
    DatetimeSubtractionParametersContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DatetimeValueExpression1Context *datetimeValueExpression1();
    antlr4::tree::TerminalNode *COMMA();
    DatetimeValueExpression2Context *datetimeValueExpression2();

   
  };

  template<typename ContextT>
  DatetimeSubtractionParametersContext* datetimeSubtractionParameters(ContextT* ctx) {
    DatetimeSubtractionParametersContext *_localctx = _tracker.createInstance<DatetimeSubtractionParametersContext>(_ctx, getState());
    enterRule(_localctx, 1044, GQLParser::RuleDatetimeSubtractionParameters);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4470);
      {
        auto childCtxHolder = ctx->EnterDatetimeValueExpression1();
        datetimeValueExpression1(get_raw_pointer(childCtxHolder));
      }
      setState(4471);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::COMMA) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::COMMA);
      setState(4472);
      {
        auto childCtxHolder = ctx->EnterDatetimeValueExpression2();
        datetimeValueExpression2(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DatetimeValueExpression1Context : public antlr4::ParserRuleContext {
  public:
    DatetimeValueExpression1Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DatetimeValueExpressionContext *datetimeValueExpression();

   
  };

  template<typename ContextT>
  DatetimeValueExpression1Context* datetimeValueExpression1(ContextT* ctx) {
    DatetimeValueExpression1Context *_localctx = _tracker.createInstance<DatetimeValueExpression1Context>(_ctx, getState());
    enterRule(_localctx, 1046, GQLParser::RuleDatetimeValueExpression1);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4474);
      {
        auto childCtxHolder = ctx->EnterDatetimeValueExpression();
        datetimeValueExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DatetimeValueExpression2Context : public antlr4::ParserRuleContext {
  public:
    DatetimeValueExpression2Context(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DatetimeValueExpressionContext *datetimeValueExpression();

   
  };

  template<typename ContextT>
  DatetimeValueExpression2Context* datetimeValueExpression2(ContextT* ctx) {
    DatetimeValueExpression2Context *_localctx = _tracker.createInstance<DatetimeValueExpression2Context>(_ctx, getState());
    enterRule(_localctx, 1048, GQLParser::RuleDatetimeValueExpression2);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4476);
      {
        auto childCtxHolder = ctx->EnterDatetimeValueExpression();
        datetimeValueExpression(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DurationValueFunctionContext : public antlr4::ParserRuleContext {
  public:
    DurationValueFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DurationFunctionContext *durationFunction();
    AbsoluteValueExpressionContext *absoluteValueExpression();

   
  };

  template<typename ContextT>
  DurationValueFunctionContext* durationValueFunction(ContextT* ctx) {
    DurationValueFunctionContext *_localctx = _tracker.createInstance<DurationValueFunctionContext>(_ctx, getState());
    enterRule(_localctx, 1050, GQLParser::RuleDurationValueFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4480);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::DURATION: {
          enterOuterAlt(_localctx, 1);
          setState(4478);
          {
            auto childCtxHolder = ctx->EnterDurationFunction();
            durationFunction(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ABS: {
          enterOuterAlt(_localctx, 2);
          setState(4479);
          {
            auto childCtxHolder = ctx->EnterAbsoluteValueExpression();
            absoluteValueExpression(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DurationFunctionContext : public antlr4::ParserRuleContext {
  public:
    DurationFunctionContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DURATION();
    antlr4::tree::TerminalNode *LEFT_PAREN();
    DurationFunctionParametersContext *durationFunctionParameters();
    antlr4::tree::TerminalNode *RIGHT_PAREN();

   
  };

  template<typename ContextT>
  DurationFunctionContext* durationFunction(ContextT* ctx) {
    DurationFunctionContext *_localctx = _tracker.createInstance<DurationFunctionContext>(_ctx, getState());
    enterRule(_localctx, 1052, GQLParser::RuleDurationFunction);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4482);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DURATION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DURATION);
      setState(4483);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::LEFT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::LEFT_PAREN);
      setState(4484);
      {
        auto childCtxHolder = ctx->EnterDurationFunctionParameters();
        durationFunctionParameters(get_raw_pointer(childCtxHolder));
      }
      setState(4485);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::RIGHT_PAREN) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::RIGHT_PAREN);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DurationFunctionParametersContext : public antlr4::ParserRuleContext {
  public:
    DurationFunctionParametersContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DurationStringContext *durationString();
    RecordConstructorContext *recordConstructor();

   
  };

  template<typename ContextT>
  DurationFunctionParametersContext* durationFunctionParameters(ContextT* ctx) {
    DurationFunctionParametersContext *_localctx = _tracker.createInstance<DurationFunctionParametersContext>(_ctx, getState());
    enterRule(_localctx, 1054, GQLParser::RuleDurationFunctionParameters);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4489);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 1);
          setState(4487);
          {
            auto childCtxHolder = ctx->EnterDurationString();
            durationString(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::RECORD:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 2);
          setState(4488);
          {
            auto childCtxHolder = ctx->EnterRecordConstructor();
            recordConstructor(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ObjectNameContext : public antlr4::ParserRuleContext {
  public:
    ObjectNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

   
  };

  template<typename ContextT>
  ObjectNameContext* objectName(ContextT* ctx) {
    ObjectNameContext *_localctx = _tracker.createInstance<ObjectNameContext>(_ctx, getState());
    enterRule(_localctx, 1056, GQLParser::RuleObjectName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4491);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ObjectNameOrBindingVariableContext : public antlr4::ParserRuleContext {
  public:
    ObjectNameOrBindingVariableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    RegularIdentifierContext *regularIdentifier();

   
  };

  template<typename ContextT>
  ObjectNameOrBindingVariableContext* objectNameOrBindingVariable(ContextT* ctx) {
    ObjectNameOrBindingVariableContext *_localctx = _tracker.createInstance<ObjectNameOrBindingVariableContext>(_ctx, getState());
    enterRule(_localctx, 1058, GQLParser::RuleObjectNameOrBindingVariable);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4493);
      {
        auto childCtxHolder = ctx->EnterRegularIdentifier();
        regularIdentifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DirectoryNameContext : public antlr4::ParserRuleContext {
  public:
    DirectoryNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

   
  };

  template<typename ContextT>
  DirectoryNameContext* directoryName(ContextT* ctx) {
    DirectoryNameContext *_localctx = _tracker.createInstance<DirectoryNameContext>(_ctx, getState());
    enterRule(_localctx, 1060, GQLParser::RuleDirectoryName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4495);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SchemaNameContext : public antlr4::ParserRuleContext {
  public:
    SchemaNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

   
  };

  template<typename ContextT>
  SchemaNameContext* schemaName(ContextT* ctx) {
    SchemaNameContext *_localctx = _tracker.createInstance<SchemaNameContext>(_ctx, getState());
    enterRule(_localctx, 1062, GQLParser::RuleSchemaName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4497);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphNameContext : public antlr4::ParserRuleContext {
  public:
    GraphNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    RegularIdentifierContext *regularIdentifier();
    DelimitedGraphNameContext *delimitedGraphName();

   
  };

  template<typename ContextT>
  GraphNameContext* graphName(ContextT* ctx) {
    GraphNameContext *_localctx = _tracker.createInstance<GraphNameContext>(_ctx, getState());
    enterRule(_localctx, 1064, GQLParser::RuleGraphName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4501);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 1);
          setState(4499);
          {
            auto childCtxHolder = ctx->EnterRegularIdentifier();
            regularIdentifier(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 2);
          setState(4500);
          {
            auto childCtxHolder = ctx->EnterDelimitedGraphName();
            delimitedGraphName(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DelimitedGraphNameContext : public antlr4::ParserRuleContext {
  public:
    DelimitedGraphNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DOUBLE_QUOTED_CHARACTER_SEQUENCE();
    antlr4::tree::TerminalNode *ACCENT_QUOTED_CHARACTER_SEQUENCE();

   
  };

  template<typename ContextT>
  DelimitedGraphNameContext* delimitedGraphName(ContextT* ctx) {
    DelimitedGraphNameContext *_localctx = _tracker.createInstance<DelimitedGraphNameContext>(_ctx, getState());
    enterRule(_localctx, 1066, GQLParser::RuleDelimitedGraphName);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4503);
      _la = _input->LA(1);
      if (!(_la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE

      || _la == GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GraphTypeNameContext : public antlr4::ParserRuleContext {
  public:
    GraphTypeNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

   
  };

  template<typename ContextT>
  GraphTypeNameContext* graphTypeName(ContextT* ctx) {
    GraphTypeNameContext *_localctx = _tracker.createInstance<GraphTypeNameContext>(_ctx, getState());
    enterRule(_localctx, 1068, GQLParser::RuleGraphTypeName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4505);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NodeTypeNameContext : public antlr4::ParserRuleContext {
  public:
    NodeTypeNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

   
  };

  template<typename ContextT>
  NodeTypeNameContext* nodeTypeName(ContextT* ctx) {
    NodeTypeNameContext *_localctx = _tracker.createInstance<NodeTypeNameContext>(_ctx, getState());
    enterRule(_localctx, 1070, GQLParser::RuleNodeTypeName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4507);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeTypeNameContext : public antlr4::ParserRuleContext {
  public:
    EdgeTypeNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

   
  };

  template<typename ContextT>
  EdgeTypeNameContext* edgeTypeName(ContextT* ctx) {
    EdgeTypeNameContext *_localctx = _tracker.createInstance<EdgeTypeNameContext>(_ctx, getState());
    enterRule(_localctx, 1072, GQLParser::RuleEdgeTypeName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4509);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BindingTableNameContext : public antlr4::ParserRuleContext {
  public:
    BindingTableNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    RegularIdentifierContext *regularIdentifier();
    DelimitedBindingTableNameContext *delimitedBindingTableName();

   
  };

  template<typename ContextT>
  BindingTableNameContext* bindingTableName(ContextT* ctx) {
    BindingTableNameContext *_localctx = _tracker.createInstance<BindingTableNameContext>(_ctx, getState());
    enterRule(_localctx, 1074, GQLParser::RuleBindingTableName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4513);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 1);
          setState(4511);
          {
            auto childCtxHolder = ctx->EnterRegularIdentifier();
            regularIdentifier(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 2);
          setState(4512);
          {
            auto childCtxHolder = ctx->EnterDelimitedBindingTableName();
            delimitedBindingTableName(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DelimitedBindingTableNameContext : public antlr4::ParserRuleContext {
  public:
    DelimitedBindingTableNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DOUBLE_QUOTED_CHARACTER_SEQUENCE();
    antlr4::tree::TerminalNode *ACCENT_QUOTED_CHARACTER_SEQUENCE();

   
  };

  template<typename ContextT>
  DelimitedBindingTableNameContext* delimitedBindingTableName(ContextT* ctx) {
    DelimitedBindingTableNameContext *_localctx = _tracker.createInstance<DelimitedBindingTableNameContext>(_ctx, getState());
    enterRule(_localctx, 1076, GQLParser::RuleDelimitedBindingTableName);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4515);
      _la = _input->LA(1);
      if (!(_la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE

      || _la == GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ProcedureNameContext : public antlr4::ParserRuleContext {
  public:
    ProcedureNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

   
  };

  template<typename ContextT>
  ProcedureNameContext* procedureName(ContextT* ctx) {
    ProcedureNameContext *_localctx = _tracker.createInstance<ProcedureNameContext>(_ctx, getState());
    enterRule(_localctx, 1078, GQLParser::RuleProcedureName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4517);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  LabelNameContext : public antlr4::ParserRuleContext {
  public:
    LabelNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

   
  };

  template<typename ContextT>
  LabelNameContext* labelName(ContextT* ctx) {
    LabelNameContext *_localctx = _tracker.createInstance<LabelNameContext>(_ctx, getState());
    enterRule(_localctx, 1080, GQLParser::RuleLabelName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4519);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PropertyNameContext : public antlr4::ParserRuleContext {
  public:
    PropertyNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

   
  };

  template<typename ContextT>
  PropertyNameContext* propertyName(ContextT* ctx) {
    PropertyNameContext *_localctx = _tracker.createInstance<PropertyNameContext>(_ctx, getState());
    enterRule(_localctx, 1082, GQLParser::RulePropertyName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4521);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  FieldNameContext : public antlr4::ParserRuleContext {
  public:
    FieldNameContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    IdentifierContext *identifier();

   
  };

  template<typename ContextT>
  FieldNameContext* fieldName(ContextT* ctx) {
    FieldNameContext *_localctx = _tracker.createInstance<FieldNameContext>(_ctx, getState());
    enterRule(_localctx, 1084, GQLParser::RuleFieldName);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4523);
      {
        auto childCtxHolder = ctx->EnterIdentifier();
        identifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ElementVariableContext : public antlr4::ParserRuleContext {
  public:
    ElementVariableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BindingVariableContext *bindingVariable();

   
  };

  template<typename ContextT>
  ElementVariableContext* elementVariable(ContextT* ctx) {
    ElementVariableContext *_localctx = _tracker.createInstance<ElementVariableContext>(_ctx, getState());
    enterRule(_localctx, 1086, GQLParser::RuleElementVariable);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4525);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  PathVariableContext : public antlr4::ParserRuleContext {
  public:
    PathVariableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    BindingVariableContext *bindingVariable();

   
  };

  template<typename ContextT>
  PathVariableContext* pathVariable(ContextT* ctx) {
    PathVariableContext *_localctx = _tracker.createInstance<PathVariableContext>(_ctx, getState());
    enterRule(_localctx, 1088, GQLParser::RulePathVariable);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4527);
      {
        auto childCtxHolder = ctx->EnterBindingVariable();
        bindingVariable(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  SubpathVariableContext : public antlr4::ParserRuleContext {
  public:
    SubpathVariableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    RegularIdentifierContext *regularIdentifier();

   
  };

  template<typename ContextT>
  SubpathVariableContext* subpathVariable(ContextT* ctx) {
    SubpathVariableContext *_localctx = _tracker.createInstance<SubpathVariableContext>(_ctx, getState());
    enterRule(_localctx, 1090, GQLParser::RuleSubpathVariable);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4529);
      {
        auto childCtxHolder = ctx->EnterRegularIdentifier();
        regularIdentifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  BindingVariableContext : public antlr4::ParserRuleContext {
  public:
    BindingVariableContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    RegularIdentifierContext *regularIdentifier();

   
  };

  template<typename ContextT>
  BindingVariableContext* bindingVariable(ContextT* ctx) {
    BindingVariableContext *_localctx = _tracker.createInstance<BindingVariableContext>(_ctx, getState());
    enterRule(_localctx, 1092, GQLParser::RuleBindingVariable);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4531);
      {
        auto childCtxHolder = ctx->EnterRegularIdentifier();
        regularIdentifier(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  UnsignedLiteralContext : public antlr4::ParserRuleContext {
  public:
    UnsignedLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    UnsignedNumericLiteralContext *unsignedNumericLiteral();
    GeneralLiteralContext *generalLiteral();

   
  };

  template<typename ContextT>
  UnsignedLiteralContext* unsignedLiteral(ContextT* ctx) {
    UnsignedLiteralContext *_localctx = _tracker.createInstance<UnsignedLiteralContext>(_ctx, getState());
    enterRule(_localctx, 1094, GQLParser::RuleUnsignedLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4535);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER: {
          enterOuterAlt(_localctx, 1);
          setState(4533);
          {
            auto childCtxHolder = ctx->EnterUnsignedNumericLiteral();
            unsignedNumericLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BOOLEAN_LITERAL:
        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::BYTE_STRING_LITERAL:
        case GQLParser::ARRAY:
        case GQLParser::DATE:
        case GQLParser::DATETIME:
        case GQLParser::DURATION:
        case GQLParser::GROUP:
        case GQLParser::LIST:
        case GQLParser::NULL_KW:
        case GQLParser::RECORD:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP:
        case GQLParser::LEFT_BRACE:
        case GQLParser::LEFT_BRACKET: {
          enterOuterAlt(_localctx, 2);
          setState(4534);
          {
            auto childCtxHolder = ctx->EnterGeneralLiteral();
            generalLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  GeneralLiteralContext : public antlr4::ParserRuleContext {
  public:
    GeneralLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *BOOLEAN_LITERAL();
    CharacterStringLiteralContext *characterStringLiteral();
    antlr4::tree::TerminalNode *BYTE_STRING_LITERAL();
    TemporalLiteralContext *temporalLiteral();
    DurationLiteralContext *durationLiteral();
    NullLiteralContext *nullLiteral();
    ListLiteralContext *listLiteral();
    RecordLiteralContext *recordLiteral();

   
  };

  template<typename ContextT>
  GeneralLiteralContext* generalLiteral(ContextT* ctx) {
    GeneralLiteralContext *_localctx = _tracker.createInstance<GeneralLiteralContext>(_ctx, getState());
    enterRule(_localctx, 1096, GQLParser::RuleGeneralLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4545);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::BOOLEAN_LITERAL: {
          enterOuterAlt(_localctx, 1);
          setState(4537);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::BOOLEAN_LITERAL) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::BOOLEAN_LITERAL);
          break;
        }

        case GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE:
        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 2);
          setState(4538);
          {
            auto childCtxHolder = ctx->EnterCharacterStringLiteral();
            characterStringLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::BYTE_STRING_LITERAL: {
          enterOuterAlt(_localctx, 3);
          setState(4539);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::BYTE_STRING_LITERAL) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::BYTE_STRING_LITERAL);
          break;
        }

        case GQLParser::DATE:
        case GQLParser::DATETIME:
        case GQLParser::TIME:
        case GQLParser::TIMESTAMP: {
          enterOuterAlt(_localctx, 4);
          setState(4540);
          {
            auto childCtxHolder = ctx->EnterTemporalLiteral();
            temporalLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DURATION: {
          enterOuterAlt(_localctx, 5);
          setState(4541);
          {
            auto childCtxHolder = ctx->EnterDurationLiteral();
            durationLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::NULL_KW: {
          enterOuterAlt(_localctx, 6);
          setState(4542);
          {
            auto childCtxHolder = ctx->EnterNullLiteral();
            nullLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::ARRAY:
        case GQLParser::GROUP:
        case GQLParser::LIST:
        case GQLParser::LEFT_BRACKET: {
          enterOuterAlt(_localctx, 7);
          setState(4543);
          {
            auto childCtxHolder = ctx->EnterListLiteral();
            listLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::RECORD:
        case GQLParser::LEFT_BRACE: {
          enterOuterAlt(_localctx, 8);
          setState(4544);
          {
            auto childCtxHolder = ctx->EnterRecordLiteral();
            recordLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TemporalLiteralContext : public antlr4::ParserRuleContext {
  public:
    TemporalLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DateLiteralContext *dateLiteral();
    TimeLiteralContext *timeLiteral();
    DatetimeLiteralContext *datetimeLiteral();

   
  };

  template<typename ContextT>
  TemporalLiteralContext* temporalLiteral(ContextT* ctx) {
    TemporalLiteralContext *_localctx = _tracker.createInstance<TemporalLiteralContext>(_ctx, getState());
    enterRule(_localctx, 1098, GQLParser::RuleTemporalLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4550);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::DATE: {
          enterOuterAlt(_localctx, 1);
          setState(4547);
          {
            auto childCtxHolder = ctx->EnterDateLiteral();
            dateLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::TIME: {
          enterOuterAlt(_localctx, 2);
          setState(4548);
          {
            auto childCtxHolder = ctx->EnterTimeLiteral();
            timeLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DATETIME:
        case GQLParser::TIMESTAMP: {
          enterOuterAlt(_localctx, 3);
          setState(4549);
          {
            auto childCtxHolder = ctx->EnterDatetimeLiteral();
            datetimeLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DateLiteralContext : public antlr4::ParserRuleContext {
  public:
    DateLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DATE();
    DateStringContext *dateString();

   
  };

  template<typename ContextT>
  DateLiteralContext* dateLiteral(ContextT* ctx) {
    DateLiteralContext *_localctx = _tracker.createInstance<DateLiteralContext>(_ctx, getState());
    enterRule(_localctx, 1100, GQLParser::RuleDateLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4552);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DATE) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DATE);
      setState(4553);
      {
        auto childCtxHolder = ctx->EnterDateString();
        dateString(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TimeLiteralContext : public antlr4::ParserRuleContext {
  public:
    TimeLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *TIME();
    TimeStringContext *timeString();

   
  };

  template<typename ContextT>
  TimeLiteralContext* timeLiteral(ContextT* ctx) {
    TimeLiteralContext *_localctx = _tracker.createInstance<TimeLiteralContext>(_ctx, getState());
    enterRule(_localctx, 1102, GQLParser::RuleTimeLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4555);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::TIME) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::TIME);
      setState(4556);
      {
        auto childCtxHolder = ctx->EnterTimeString();
        timeString(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DatetimeLiteralContext : public antlr4::ParserRuleContext {
  public:
    DatetimeLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    DatetimeStringContext *datetimeString();
    antlr4::tree::TerminalNode *DATETIME();
    antlr4::tree::TerminalNode *TIMESTAMP();

   
  };

  template<typename ContextT>
  DatetimeLiteralContext* datetimeLiteral(ContextT* ctx) {
    DatetimeLiteralContext *_localctx = _tracker.createInstance<DatetimeLiteralContext>(_ctx, getState());
    enterRule(_localctx, 1104, GQLParser::RuleDatetimeLiteral);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4558);
      _la = _input->LA(1);
      if (!(_la == GQLParser::DATETIME || _la == GQLParser::TIMESTAMP)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
      setState(4559);
      {
        auto childCtxHolder = ctx->EnterDatetimeString();
        datetimeString(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ListLiteralContext : public antlr4::ParserRuleContext {
  public:
    ListLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ListValueConstructorByEnumerationContext *listValueConstructorByEnumeration();

   
  };

  template<typename ContextT>
  ListLiteralContext* listLiteral(ContextT* ctx) {
    ListLiteralContext *_localctx = _tracker.createInstance<ListLiteralContext>(_ctx, getState());
    enterRule(_localctx, 1106, GQLParser::RuleListLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4561);
      {
        auto childCtxHolder = ctx->EnterListValueConstructorByEnumeration();
        listValueConstructorByEnumeration(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  RecordLiteralContext : public antlr4::ParserRuleContext {
  public:
    RecordLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    RecordConstructorContext *recordConstructor();

   
  };

  template<typename ContextT>
  RecordLiteralContext* recordLiteral(ContextT* ctx) {
    RecordLiteralContext *_localctx = _tracker.createInstance<RecordLiteralContext>(_ctx, getState());
    enterRule(_localctx, 1108, GQLParser::RuleRecordLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4563);
      {
        auto childCtxHolder = ctx->EnterRecordConstructor();
        recordConstructor(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  IdentifierContext : public antlr4::ParserRuleContext {
  public:
    IdentifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    RegularIdentifierContext *regularIdentifier();
    antlr4::tree::TerminalNode *DOUBLE_QUOTED_CHARACTER_SEQUENCE();
    antlr4::tree::TerminalNode *ACCENT_QUOTED_CHARACTER_SEQUENCE();

   
  };

  template<typename ContextT>
  IdentifierContext* identifier(ContextT* ctx) {
    IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
    enterRule(_localctx, 1110, GQLParser::RuleIdentifier);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4568);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE:
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 1);
          setState(4565);
          {
            auto childCtxHolder = ctx->EnterRegularIdentifier();
            regularIdentifier(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 2);
          setState(4566);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE);
          break;
        }

        case GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE: {
          enterOuterAlt(_localctx, 3);
          setState(4567);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::ACCENT_QUOTED_CHARACTER_SEQUENCE);
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  RegularIdentifierContext : public antlr4::ParserRuleContext {
  public:
    RegularIdentifierContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *REGULAR_IDENTIFIER();
    NonReservedWordsContext *nonReservedWords();

   
  };

  template<typename ContextT>
  RegularIdentifierContext* regularIdentifier(ContextT* ctx) {
    RegularIdentifierContext *_localctx = _tracker.createInstance<RegularIdentifierContext>(_ctx, getState());
    enterRule(_localctx, 1112, GQLParser::RuleRegularIdentifier);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4572);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::REGULAR_IDENTIFIER: {
          enterOuterAlt(_localctx, 1);
          setState(4570);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::REGULAR_IDENTIFIER) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::REGULAR_IDENTIFIER);
          break;
        }

        case GQLParser::ACYCLIC:
        case GQLParser::BINDING:
        case GQLParser::BINDINGS:
        case GQLParser::CONNECTING:
        case GQLParser::DESTINATION:
        case GQLParser::DIFFERENT:
        case GQLParser::DIRECTED:
        case GQLParser::EDGE:
        case GQLParser::EDGES:
        case GQLParser::ELEMENT:
        case GQLParser::ELEMENTS:
        case GQLParser::FIRST:
        case GQLParser::GRAPH:
        case GQLParser::GROUPS:
        case GQLParser::KEEP:
        case GQLParser::LABEL:
        case GQLParser::LABELED:
        case GQLParser::LABELS:
        case GQLParser::LAST:
        case GQLParser::NFC:
        case GQLParser::NFD:
        case GQLParser::NFKC:
        case GQLParser::NFKD:
        case GQLParser::NO:
        case GQLParser::NODE:
        case GQLParser::NORMALIZED:
        case GQLParser::ONLY:
        case GQLParser::ORDINALITY:
        case GQLParser::PROPERTY:
        case GQLParser::READ:
        case GQLParser::RELATIONSHIP:
        case GQLParser::RELATIONSHIPS:
        case GQLParser::REPEATABLE:
        case GQLParser::SHORTEST:
        case GQLParser::SIMPLE:
        case GQLParser::SOURCE:
        case GQLParser::TABLE:
        case GQLParser::TEMP:
        case GQLParser::TO:
        case GQLParser::TRAIL:
        case GQLParser::TRANSACTION:
        case GQLParser::UNDIRECTED:
        case GQLParser::VERTEX:
        case GQLParser::WALK:
        case GQLParser::WITHOUT:
        case GQLParser::WRITE:
        case GQLParser::ZONE: {
          enterOuterAlt(_localctx, 2);
          setState(4571);
          {
            auto childCtxHolder = ctx->EnterNonReservedWords();
            nonReservedWords(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TimeZoneStringContext : public antlr4::ParserRuleContext {
  public:
    TimeZoneStringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CharacterStringLiteralContext *characterStringLiteral();

   
  };

  template<typename ContextT>
  TimeZoneStringContext* timeZoneString(ContextT* ctx) {
    TimeZoneStringContext *_localctx = _tracker.createInstance<TimeZoneStringContext>(_ctx, getState());
    enterRule(_localctx, 1114, GQLParser::RuleTimeZoneString);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4574);
      {
        auto childCtxHolder = ctx->EnterCharacterStringLiteral();
        characterStringLiteral(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  CharacterStringLiteralContext : public antlr4::ParserRuleContext {
  public:
    CharacterStringLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *SINGLE_QUOTED_CHARACTER_SEQUENCE();
    antlr4::tree::TerminalNode *DOUBLE_QUOTED_CHARACTER_SEQUENCE();

   
  };

  template<typename ContextT>
  CharacterStringLiteralContext* characterStringLiteral(ContextT* ctx) {
    CharacterStringLiteralContext *_localctx = _tracker.createInstance<CharacterStringLiteralContext>(_ctx, getState());
    enterRule(_localctx, 1116, GQLParser::RuleCharacterStringLiteral);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4576);
      _la = _input->LA(1);
      if (!(_la == GQLParser::SINGLE_QUOTED_CHARACTER_SEQUENCE

      || _la == GQLParser::DOUBLE_QUOTED_CHARACTER_SEQUENCE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  UnsignedNumericLiteralContext : public antlr4::ParserRuleContext {
  public:
    UnsignedNumericLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    ExactNumericLiteralContext *exactNumericLiteral();
    ApproximateNumericLiteralContext *approximateNumericLiteral();

   
  };

  template<typename ContextT>
  UnsignedNumericLiteralContext* unsignedNumericLiteral(ContextT* ctx) {
    UnsignedNumericLiteralContext *_localctx = _tracker.createInstance<UnsignedNumericLiteralContext>(_ctx, getState());
    enterRule(_localctx, 1118, GQLParser::RuleUnsignedNumericLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4580);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER: {
          enterOuterAlt(_localctx, 1);
          setState(4578);
          {
            auto childCtxHolder = ctx->EnterExactNumericLiteral();
            exactNumericLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX:
        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX: {
          enterOuterAlt(_localctx, 2);
          setState(4579);
          {
            auto childCtxHolder = ctx->EnterApproximateNumericLiteral();
            approximateNumericLiteral(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ExactNumericLiteralContext : public antlr4::ParserRuleContext {
  public:
    ExactNumericLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX();
    antlr4::tree::TerminalNode *UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX();
    antlr4::tree::TerminalNode *UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX();
    antlr4::tree::TerminalNode *UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX();
    UnsignedIntegerContext *unsignedInteger();

   
  };

  template<typename ContextT>
  ExactNumericLiteralContext* exactNumericLiteral(ContextT* ctx) {
    ExactNumericLiteralContext *_localctx = _tracker.createInstance<ExactNumericLiteralContext>(_ctx, getState());
    enterRule(_localctx, 1120, GQLParser::RuleExactNumericLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      setState(4587);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX: {
          enterOuterAlt(_localctx, 1);
          setState(4582);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_EXACT_NUMBER_SUFFIX);
          break;
        }

        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX: {
          enterOuterAlt(_localctx, 2);
          setState(4583);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_EXACT_NUMBER_SUFFIX);
          break;
        }

        case GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX: {
          enterOuterAlt(_localctx, 3);
          setState(4584);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITHOUT_SUFFIX);
          break;
        }

        case GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX: {
          enterOuterAlt(_localctx, 4);
          setState(4585);
          if constexpr (has_OnToken<decltype(ctx)>::value) {
            if (_input->LA(1) == GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX) {
              ctx->OnToken(_input->LT(1));
            }
          }
          match(GQLParser::UNSIGNED_DECIMAL_INTEGER_WITH_EXACT_NUMBER_SUFFIX);
          break;
        }

        case GQLParser::UNSIGNED_DECIMAL_INTEGER:
        case GQLParser::UNSIGNED_HEXADECIMAL_INTEGER:
        case GQLParser::UNSIGNED_OCTAL_INTEGER:
        case GQLParser::UNSIGNED_BINARY_INTEGER: {
          enterOuterAlt(_localctx, 5);
          setState(4586);
          {
            auto childCtxHolder = ctx->EnterUnsignedInteger();
            unsignedInteger(get_raw_pointer(childCtxHolder));
          }
          break;
        }

      default:
        throw antlr4::NoViableAltException(this);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  ApproximateNumericLiteralContext : public antlr4::ParserRuleContext {
  public:
    ApproximateNumericLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX();
    antlr4::tree::TerminalNode *UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION_WITHOUT_SUFFIX();
    antlr4::tree::TerminalNode *UNSIGNED_DECIMAL_IN_COMMON_NOTATION_WITH_APPROXIMATE_NUMBER_SUFFIX();
    antlr4::tree::TerminalNode *UNSIGNED_DECIMAL_INTEGER_WITH_APPROXIMATE_NUMBER_SUFFIX();

   
  };

  template<typename ContextT>
  ApproximateNumericLiteralContext* approximateNumericLiteral(ContextT* ctx) {
    ApproximateNumericLiteralContext *_localctx = _tracker.createInstance<ApproximateNumericLiteralContext>(_ctx, getState());
    enterRule(_localctx, 1122, GQLParser::RuleApproximateNumericLiteral);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4589);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 42496) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  UnsignedIntegerContext : public antlr4::ParserRuleContext {
  public:
    UnsignedIntegerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_DECIMAL_INTEGER();
    antlr4::tree::TerminalNode *UNSIGNED_HEXADECIMAL_INTEGER();
    antlr4::tree::TerminalNode *UNSIGNED_OCTAL_INTEGER();
    antlr4::tree::TerminalNode *UNSIGNED_BINARY_INTEGER();

   
  };

  template<typename ContextT>
  UnsignedIntegerContext* unsignedInteger(ContextT* ctx) {
    UnsignedIntegerContext *_localctx = _tracker.createInstance<UnsignedIntegerContext>(_ctx, getState());
    enterRule(_localctx, 1124, GQLParser::RuleUnsignedInteger);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4591);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 983040) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  UnsignedDecimalIntegerContext : public antlr4::ParserRuleContext {
  public:
    UnsignedDecimalIntegerContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *UNSIGNED_DECIMAL_INTEGER();

   
  };

  template<typename ContextT>
  UnsignedDecimalIntegerContext* unsignedDecimalInteger(ContextT* ctx) {
    UnsignedDecimalIntegerContext *_localctx = _tracker.createInstance<UnsignedDecimalIntegerContext>(_ctx, getState());
    enterRule(_localctx, 1126, GQLParser::RuleUnsignedDecimalInteger);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4593);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::UNSIGNED_DECIMAL_INTEGER) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::UNSIGNED_DECIMAL_INTEGER);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NullLiteralContext : public antlr4::ParserRuleContext {
  public:
    NullLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NULL_KW();

   
  };

  template<typename ContextT>
  NullLiteralContext* nullLiteral(ContextT* ctx) {
    NullLiteralContext *_localctx = _tracker.createInstance<NullLiteralContext>(_ctx, getState());
    enterRule(_localctx, 1128, GQLParser::RuleNullLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4595);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::NULL_KW) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::NULL_KW);
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DateStringContext : public antlr4::ParserRuleContext {
  public:
    DateStringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CharacterStringLiteralContext *characterStringLiteral();

   
  };

  template<typename ContextT>
  DateStringContext* dateString(ContextT* ctx) {
    DateStringContext *_localctx = _tracker.createInstance<DateStringContext>(_ctx, getState());
    enterRule(_localctx, 1130, GQLParser::RuleDateString);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4597);
      {
        auto childCtxHolder = ctx->EnterCharacterStringLiteral();
        characterStringLiteral(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  TimeStringContext : public antlr4::ParserRuleContext {
  public:
    TimeStringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CharacterStringLiteralContext *characterStringLiteral();

   
  };

  template<typename ContextT>
  TimeStringContext* timeString(ContextT* ctx) {
    TimeStringContext *_localctx = _tracker.createInstance<TimeStringContext>(_ctx, getState());
    enterRule(_localctx, 1132, GQLParser::RuleTimeString);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4599);
      {
        auto childCtxHolder = ctx->EnterCharacterStringLiteral();
        characterStringLiteral(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DatetimeStringContext : public antlr4::ParserRuleContext {
  public:
    DatetimeStringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CharacterStringLiteralContext *characterStringLiteral();

   
  };

  template<typename ContextT>
  DatetimeStringContext* datetimeString(ContextT* ctx) {
    DatetimeStringContext *_localctx = _tracker.createInstance<DatetimeStringContext>(_ctx, getState());
    enterRule(_localctx, 1134, GQLParser::RuleDatetimeString);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4601);
      {
        auto childCtxHolder = ctx->EnterCharacterStringLiteral();
        characterStringLiteral(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DurationLiteralContext : public antlr4::ParserRuleContext {
  public:
    DurationLiteralContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *DURATION();
    DurationStringContext *durationString();

   
  };

  template<typename ContextT>
  DurationLiteralContext* durationLiteral(ContextT* ctx) {
    DurationLiteralContext *_localctx = _tracker.createInstance<DurationLiteralContext>(_ctx, getState());
    enterRule(_localctx, 1136, GQLParser::RuleDurationLiteral);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4603);
      if constexpr (has_OnToken<decltype(ctx)>::value) {
        if (_input->LA(1) == GQLParser::DURATION) {
          ctx->OnToken(_input->LT(1));
        }
      }
      match(GQLParser::DURATION);
      setState(4604);
      {
        auto childCtxHolder = ctx->EnterDurationString();
        durationString(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  DurationStringContext : public antlr4::ParserRuleContext {
  public:
    DurationStringContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    CharacterStringLiteralContext *characterStringLiteral();

   
  };

  template<typename ContextT>
  DurationStringContext* durationString(ContextT* ctx) {
    DurationStringContext *_localctx = _tracker.createInstance<DurationStringContext>(_ctx, getState());
    enterRule(_localctx, 1138, GQLParser::RuleDurationString);

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4606);
      {
        auto childCtxHolder = ctx->EnterCharacterStringLiteral();
        characterStringLiteral(get_raw_pointer(childCtxHolder));
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NodeSynonymContext : public antlr4::ParserRuleContext {
  public:
    NodeSynonymContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *NODE();
    antlr4::tree::TerminalNode *VERTEX();

   
  };

  template<typename ContextT>
  NodeSynonymContext* nodeSynonym(ContextT* ctx) {
    NodeSynonymContext *_localctx = _tracker.createInstance<NodeSynonymContext>(_ctx, getState());
    enterRule(_localctx, 1140, GQLParser::RuleNodeSynonym);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4608);
      _la = _input->LA(1);
      if (!(_la == GQLParser::NODE

      || _la == GQLParser::VERTEX)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgesSynonymContext : public antlr4::ParserRuleContext {
  public:
    EdgesSynonymContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EDGES();
    antlr4::tree::TerminalNode *RELATIONSHIPS();

   
  };

  template<typename ContextT>
  EdgesSynonymContext* edgesSynonym(ContextT* ctx) {
    EdgesSynonymContext *_localctx = _tracker.createInstance<EdgesSynonymContext>(_ctx, getState());
    enterRule(_localctx, 1142, GQLParser::RuleEdgesSynonym);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4610);
      _la = _input->LA(1);
      if (!(_la == GQLParser::EDGES

      || _la == GQLParser::RELATIONSHIPS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  EdgeSynonymContext : public antlr4::ParserRuleContext {
  public:
    EdgeSynonymContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *EDGE();
    antlr4::tree::TerminalNode *RELATIONSHIP();

   
  };

  template<typename ContextT>
  EdgeSynonymContext* edgeSynonym(ContextT* ctx) {
    EdgeSynonymContext *_localctx = _tracker.createInstance<EdgeSynonymContext>(_ctx, getState());
    enterRule(_localctx, 1144, GQLParser::RuleEdgeSynonym);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4612);
      _la = _input->LA(1);
      if (!(_la == GQLParser::EDGE

      || _la == GQLParser::RELATIONSHIP)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }

  class  NonReservedWordsContext : public antlr4::ParserRuleContext {
  public:
    NonReservedWordsContext(antlr4::ParserRuleContext *parent, size_t invokingState);
    virtual size_t getRuleIndex() const override;
    antlr4::tree::TerminalNode *ACYCLIC();
    antlr4::tree::TerminalNode *BINDING();
    antlr4::tree::TerminalNode *BINDINGS();
    antlr4::tree::TerminalNode *CONNECTING();
    antlr4::tree::TerminalNode *DESTINATION();
    antlr4::tree::TerminalNode *DIFFERENT();
    antlr4::tree::TerminalNode *DIRECTED();
    antlr4::tree::TerminalNode *EDGE();
    antlr4::tree::TerminalNode *EDGES();
    antlr4::tree::TerminalNode *ELEMENT();
    antlr4::tree::TerminalNode *ELEMENTS();
    antlr4::tree::TerminalNode *FIRST();
    antlr4::tree::TerminalNode *GRAPH();
    antlr4::tree::TerminalNode *GROUPS();
    antlr4::tree::TerminalNode *KEEP();
    antlr4::tree::TerminalNode *LABEL();
    antlr4::tree::TerminalNode *LABELED();
    antlr4::tree::TerminalNode *LABELS();
    antlr4::tree::TerminalNode *LAST();
    antlr4::tree::TerminalNode *NFC();
    antlr4::tree::TerminalNode *NFD();
    antlr4::tree::TerminalNode *NFKC();
    antlr4::tree::TerminalNode *NFKD();
    antlr4::tree::TerminalNode *NO();
    antlr4::tree::TerminalNode *NODE();
    antlr4::tree::TerminalNode *NORMALIZED();
    antlr4::tree::TerminalNode *ONLY();
    antlr4::tree::TerminalNode *ORDINALITY();
    antlr4::tree::TerminalNode *PROPERTY();
    antlr4::tree::TerminalNode *READ();
    antlr4::tree::TerminalNode *RELATIONSHIP();
    antlr4::tree::TerminalNode *RELATIONSHIPS();
    antlr4::tree::TerminalNode *REPEATABLE();
    antlr4::tree::TerminalNode *SHORTEST();
    antlr4::tree::TerminalNode *SIMPLE();
    antlr4::tree::TerminalNode *SOURCE();
    antlr4::tree::TerminalNode *TABLE();
    antlr4::tree::TerminalNode *TEMP();
    antlr4::tree::TerminalNode *TO();
    antlr4::tree::TerminalNode *TRAIL();
    antlr4::tree::TerminalNode *TRANSACTION();
    antlr4::tree::TerminalNode *UNDIRECTED();
    antlr4::tree::TerminalNode *VERTEX();
    antlr4::tree::TerminalNode *WALK();
    antlr4::tree::TerminalNode *WITHOUT();
    antlr4::tree::TerminalNode *WRITE();
    antlr4::tree::TerminalNode *ZONE();

   
  };

  template<typename ContextT>
  NonReservedWordsContext* nonReservedWords(ContextT* ctx) {
    NonReservedWordsContext *_localctx = _tracker.createInstance<NonReservedWordsContext>(_ctx, getState());
    enterRule(_localctx, 1146, GQLParser::RuleNonReservedWords);
    size_t _la = 0;

  #if __cplusplus > 201703L
    auto onExit = antlrcpp::finally([=, this] {
  #else
    auto onExit = antlrcpp::finally([=] {
  #endif
    exitRule();
    if constexpr (has_ExitRule<decltype(ctx)>::value) {
      ctx->ExitRule(_localctx);
    }
    });
    try {
      enterOuterAlt(_localctx, 1);
      setState(4614);
      _la = _input->LA(1);
      if (!(((((_la - 277) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 277)) & 279275953455103) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        antlr4::Token * token = consume();
        ctx->OnToken(token);
      }
     
    }
    catch (antlr4::RecognitionException &e) {
      _errHandler->reportError(this, e);
      _localctx->exception = std::current_exception();
      _errHandler->recover(this, _localctx->exception);
    }

    return _localctx;
  }


  bool sempred(antlr4::RuleContext *_localctx, size_t ruleIndex, size_t predicateIndex) override;

  bool compositeQueryExpressionSempred(CompositeQueryExpressionContext *_localctx, size_t predicateIndex);
  bool labelExpressionSempred(LabelExpressionContext *_localctx, size_t predicateIndex);
  bool simplifiedTermSempred(SimplifiedTermContext *_localctx, size_t predicateIndex);
  bool simplifiedFactorLowSempred(SimplifiedFactorLowContext *_localctx, size_t predicateIndex);
  bool valueTypeSempred(ValueTypeContext *_localctx, size_t predicateIndex);
  bool valueExpressionSempred(ValueExpressionContext *_localctx, size_t predicateIndex);
  bool valueExpressionPrimarySempred(ValueExpressionPrimaryContext *_localctx, size_t predicateIndex);
  bool numericValueExpressionSempred(NumericValueExpressionContext *_localctx, size_t predicateIndex);

  // By default the static state used to implement the parser is lazily initialized during the first
  // call to the constructor. You can call this function if you wish to initialize the static state
  // ahead of time.
  static void initialize();

private:
};

#ifdef _MSC_VER
#pragma warning( pop )
#endif

